        -:    0:Source:flex.c
        -:    0:Graph:flex.gcno
        -:    0:Data:flex.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* flex - tool to generate fast lexical analyzers */
        -:    2:
        -:    3:/*-
        -:    4: * Copyright (c) 1990 The Regents of the University of California.
        -:    5: * All rights reserved.
        -:    6: *
        -:    7: * This code is derived from software contributed to Berkeley by
        -:    8: * Vern Paxson.
        -:    9: * 
        -:   10: * The United States Government has rights in this work pursuant
        -:   11: * to contract no. DE-AC03-76SF00098 between the United States
        -:   12: * Department of Energy and the University of California.
        -:   13: *
        -:   14: * Redistribution and use in source and binary forms are permitted provided
        -:   15: * that: (1) source distributions retain this entire copyright notice and
        -:   16: * comment, and (2) distributions including binaries display the following
        -:   17: * acknowledgement:  ``This product includes software developed by the
        -:   18: * University of California, Berkeley and its contributors'' in the
        -:   19: * documentation or other materials provided with the distribution and in
        -:   20: * all advertising materials mentioning features or use of this software.
        -:   21: * Neither the name of the University nor the names of its contributors may
        -:   22: * be used to endorse or promote products derived from this software without
        -:   23: * specific prior written permission.
        -:   24: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -:   25: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -:   26: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -:   27: */
        -:   28:
        -:   29:#define LINUX 1
        -:   30:
        -:   31:#ifndef lint
        -:   32:char copyright[] =
        -:   33:"@(#) Copyright (c) 1990 The Regents of the University of California.\n\
        -:   34: All rights reserved.\n";
        -:   35:#endif /* not lint */
        -:   36:
        -:   37:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -:   38:
        -:   39:
        -:   40:#include "flexdef.h"
        -:   41:#include "version.h"
        -:   42:#include <ctype.h>
        -:   43:#include "parse.h"
        -:   44:#include "FaultSeeds.h"
        -:   45:
        -:   46:static char flex_version[] = FLEX_VERSION;
        -:   47:
        -:   48:
        -:   49:/* declare functions that have forward references */
        -:   50:
        -:   51:void flexinit PROTO((int, char**));
        -:   52:void readin PROTO((void));
        -:   53:void set_up_initial_allocations PROTO((void));
        -:   54:
        -:   55:
        -:   56:/* these globals are all defined and commented in flexdef.h */
        -:   57:int printstats, syntaxerror, eofseen, ddebug, trace, nowarn, spprdflt;
        -:   58:int interactive, caseins, lex_compat, useecs, fulltbl, usemecs;
        -:   59:int fullspd, gen_line_dirs, performance_report, backing_up_report;
        -:   60:int C_plus_plus, long_align, use_read, yytext_is_array, csize;
        -:   61:int yymore_used, reject, real_reject, continued_action;
        -:   62:int yymore_really_used, reject_really_used;
        -:   63:int datapos, dataline, linenum;
        -:   64:FILE *skelfile = NULL;
        -:   65:
        -:   66:/* ### add for testing ### */
        -:   67:FILE *err = NULL;
        -:   68:/* ####################### */
        -:   69:
        -:   70:int skel_ind = 0;
        -:   71:char *action_array;
        -:   72:int action_size, defs1_offset, prolog_offset, action_offset, action_index;
        -:   73:char *infilename = NULL;
        -:   74:int onestate[ONE_STACK_SIZE], onesym[ONE_STACK_SIZE];
        -:   75:int onenext[ONE_STACK_SIZE], onedef[ONE_STACK_SIZE], onesp;
        -:   76:int current_mns, num_rules, num_eof_rules, default_rule;
        -:   77:int current_max_rules, lastnfa;
        -:   78:int *firstst, *lastst, *finalst, *transchar, *trans1, *trans2;
        -:   79:int *accptnum, *assoc_rule, *state_type;
        -:   80:int *rule_type, *rule_linenum, *rule_useful;
        -:   81:int current_state_type;
        -:   82:int variable_trailing_context_rules;
        -:   83:int numtemps, numprots, protprev[MSP], protnext[MSP], prottbl[MSP];
        -:   84:int protcomst[MSP], firstprot, lastprot, protsave[PROT_SAVE_SIZE];
        -:   85:int numecs, nextecm[CSIZE + 1], ecgroup[CSIZE + 1], nummecs, tecfwd[CSIZE + 1];
        -:   86:int tecbck[CSIZE + 1];
        -:   87:int lastsc, current_max_scs, *scset, *scbol, *scxclu, *sceof, *actvsc;
        -:   88:char **scname;
        -:   89:int current_max_dfa_size, current_max_xpairs;
        -:   90:int current_max_template_xpairs, current_max_dfas;
        -:   91:int lastdfa, *nxt, *chk, *tnxt;
        -:   92:int *base, *def, *nultrans, NUL_ec, tblend, firstfree, **dss, *dfasiz;
        -:   93:union dfaacc_union *dfaacc;
        -:   94:int *accsiz, *dhash, numas;
        -:   95:int numsnpairs, jambase, jamstate;
        -:   96:int lastccl, current_maxccls, *cclmap, *ccllen, *cclng, cclreuse;
        -:   97:int current_max_ccl_tbl_size;
        -:   98:Char *ccltbl;
        -:   99:char nmstr[MAXLINE];
        -:  100:int sectnum, nummt, hshcol, dfaeql, numeps, eps2, num_reallocs;
        -:  101:int tmpuses, totnst, peakpairs, numuniq, numdup, hshsave;
        -:  102:int num_backing_up, bol_needed;
        -:  103:FILE *backing_up_file;
        -:  104:int end_of_buffer_state;
        -:  105:char **input_files;
        -:  106:int num_input_files;
        -:  107:char *program_name;
        -:  108:
        -:  109:#ifndef SHORT_FILE_NAMES
        -:  110:static char *outfile_template = "lex.%s.%s";
        -:  111:#else
        -:  112:static char *outfile_template = "lex%s.%s";
        -:  113:#endif
        -:  114:static char outfile_path[64];
        -:  115:
        -:  116:static int outfile_created = 0;
        -:  117:static int use_stdout;
        -:  118:static char *skelname = NULL;
        -:  119:static char *prefix = "yy";
        -:  120:
        -:  121:
        1:  122:int main( argc, argv )
        -:  123:int argc;
        -:  124:char **argv;
        -:  125:	{
        -:  126:	int i;
        -:  127:
        -:  128:/* ### add for testing ### */
        -:  129:
        1:  130:	if(--argc >0){
        1:  131:                err = fopen( *++argv, "w" );
        1:  132:                --argv; ++argc;
        -:  133:        }
        -:  134:/* ####################### */
        -:  135:
        -:  136:
        1:  137:	flexinit( argc, argv );
        -:  138:
        1:  139:	readin();
        -:  140:
        1:  141:	ntod();
        -:  142:
        2:  143:	for ( i = 1; i <= num_rules; ++i )
        1:  144:		if ( ! rule_useful[i] && i != default_rule )
    #####:  145:			line_warning( "rule cannot be matched",
    #####:  146:					rule_linenum[i] );
        -:  147:
        1:  148:	if ( spprdflt && ! reject && rule_useful[default_rule] )
    #####:  149:		line_warning( "-s option given but default rule can be matched",
    #####:  150:			rule_linenum[default_rule] );
        -:  151:
        -:  152:	/* Generate the C state transition tables from the DFA. */
        1:  153:	make_tables();
        -:  154:
        -:  155:	/* Note, flexend does not return.  It exits with its argument
        -:  156:	 * as status.
        -:  157:	 */
        1:  158:	flexend( 0 );
        -:  159:
    #####:  160:	return 0;	/* keep compilers/lint happy */
        -:  161:	}
        -:  162:
        -:  163:
        -:  164:/* flexend - terminate flex
        -:  165: *
        -:  166: * note
        -:  167: *    This routine does not return.
        -:  168: */
        -:  169:
        1:  170:void flexend( exit_status )
        -:  171:int exit_status;
        -:  172:
        -:  173:	{
        -:  174:	int tblsiz;
        -:  175:	int unlink();
        -:  176:
        1:  177:	if ( skelfile != NULL )
        -:  178:		{
    #####:  179:		if ( ferror( skelfile ) )
    #####:  180:			flexfatal(
        -:  181:				"error occurred when reading skeleton file" );
        -:  182:
    #####:  183:		else if ( fclose( skelfile ) )
    #####:  184:			flexfatal(
        -:  185:				"error occurred when closing skeleton file" );
        -:  186:		}
        -:  187:
        1:  188:	if ( exit_status != 0 && outfile_created )
        -:  189:		{
    #####:  190:		if ( ferror( stdout ) )
    #####:  191:			flexfatal( "error occurred when writing output file" );
        -:  192:
    #####:  193:		else if ( fclose( stdout ) )
    #####:  194:			flexfatal( "error occurred when closing output file" );
        -:  195:
    #####:  196:		else if ( unlink( outfile_path ) )
    #####:  197:			flexfatal( "error occurred when deleting output file" );
        -:  198:		}
        -:  199:
        1:  200:	if ( backing_up_report && backing_up_file )
        -:  201:		{
    #####:  202:		if ( num_backing_up == 0 )
    #####:  203:			fprintf( backing_up_file, "No backing up.\n" );
    #####:  204:		else if ( fullspd || fulltbl )
    #####:  205:			fprintf( backing_up_file,
        -:  206:				"%d backing up (non-accepting) states.\n",
        -:  207:				num_backing_up );
        -:  208:		else
    #####:  209:			fprintf( backing_up_file,
        -:  210:				"Compressed tables always back up.\n" );
        -:  211:
    #####:  212:		if ( ferror( backing_up_file ) )
    #####:  213:			flexfatal( "error occurred when writing backup file" );
        -:  214:
    #####:  215:		else if ( fclose( backing_up_file ) )
    #####:  216:			flexfatal( "error occurred when closing backup file" );
        -:  217:		}
        -:  218:
        1:  219:	if ( printstats )
        -:  220:		{
    #####:  221:		fprintf( err, "%s version %s usage statistics:\n",
        -:  222:			program_name, flex_version );
        -:  223:
    #####:  224:		fprintf( err, "  scanner options: -" );
        -:  225:
    #####:  226:		if ( C_plus_plus )
    #####:  227:			putc( '+', err );
    #####:  228:		if ( backing_up_report )
    #####:  229:			putc( 'b', err );
    #####:  230:		if ( ddebug )
    #####:  231:			putc( 'd', err );
    #####:  232:		if ( caseins )
    #####:  233:			putc( 'i', err );
    #####:  234:		if ( lex_compat )
    #####:  235:			putc( 'l', err );
    #####:  236:		if ( performance_report > 0 )
    #####:  237:			putc( 'p', err );
    #####:  238:		if ( performance_report > 1 )
    #####:  239:			putc( 'p', err );
    #####:  240:		if ( spprdflt )
    #####:  241:			putc( 's', err );
    #####:  242:		if ( use_stdout )
    #####:  243:			putc( 't', err );
    #####:  244:		if ( printstats )
    #####:  245:			putc( 'v', err );	/* always true! */
    #####:  246:		if ( nowarn )
    #####:  247:			putc( 'w', err );
    #####:  248:		if ( ! interactive )
    #####:  249:			putc( 'B', err );
    #####:  250:		if ( interactive )
    #####:  251:			putc( 'I', err );
    #####:  252:		if ( ! gen_line_dirs )
    #####:  253:			putc( 'L', err );
    #####:  254:		if ( trace )
    #####:  255:			putc( 'T', err );
    #####:  256:		if ( csize == 128 )
    #####:  257:			putc( '7', err );
        -:  258:		else
    #####:  259:			putc( '8', err );
        -:  260:
    #####:  261:		fprintf( err, " -C" );
        -:  262:
    #####:  263:		if ( long_align )
    #####:  264:			putc( 'a', err );
    #####:  265:		if ( fulltbl )
    #####:  266:			putc( 'f', err );
    #####:  267:		if ( fullspd )
    #####:  268:			putc( 'F', err );
    #####:  269:		if ( useecs )
    #####:  270:			putc( 'e', err );
    #####:  271:		if ( usemecs )
    #####:  272:			putc( 'm', err );
    #####:  273:		if ( use_read )
    #####:  274:			putc( 'r', err );
        -:  275:
    #####:  276:		if ( skelname )
    #####:  277:			fprintf( err, " -S%s", skelname );
        -:  278:
    #####:  279:		if ( strcmp( prefix, "yy" ) )
    #####:  280:			fprintf( err, " -P%s", prefix );
        -:  281:
    #####:  282:		putc( '\n', err );
        -:  283:
    #####:  284:		fprintf( err, "  %d/%d NFA states\n", lastnfa, current_mns );
    #####:  285:		fprintf( err, "  %d/%d DFA states (%d words)\n", lastdfa,
        -:  286:			current_max_dfas, totnst );
    #####:  287:		fprintf( err, "  %d rules\n",
    #####:  288:		num_rules + num_eof_rules - 1 /* - 1 for def. rule */ );
        -:  289:
    #####:  290:		if ( num_backing_up == 0 )
    #####:  291:			fprintf( err, "  No backing up\n" );
    #####:  292:		else if ( fullspd || fulltbl )
    #####:  293:			fprintf( err,
        -:  294:				"  %d backing-up (non-accepting) states\n",
        -:  295:				num_backing_up );
        -:  296:		else
    #####:  297:			fprintf( err,
        -:  298:				"  Compressed tables always back-up\n" );
        -:  299:
    #####:  300:		if ( bol_needed )
    #####:  301:			fprintf( err,
        -:  302:				"  Beginning-of-line patterns used\n" );
        -:  303:
    #####:  304:		fprintf( err, "  %d/%d start conditions\n", lastsc,
        -:  305:			current_max_scs );
    #####:  306:		fprintf( err,
        -:  307:			"  %d epsilon states, %d double epsilon states\n",
        -:  308:			numeps, eps2 );
        -:  309:
    #####:  310:		if ( lastccl == 0 )
    #####:  311:			fprintf( err, "  no character classes\n" );
        -:  312:		else
    #####:  313:			fprintf( err,
        -:  314:	"  %d/%d character classes needed %d/%d words of storage, %d reused\n",
        -:  315:				lastccl, current_maxccls,
    #####:  316:				cclmap[lastccl] + ccllen[lastccl],
        -:  317:				current_max_ccl_tbl_size, cclreuse );
        -:  318:
    #####:  319:		fprintf( err, "  %d state/nextstate pairs created\n",
        -:  320:			numsnpairs );
    #####:  321:		fprintf( err, "  %d/%d unique/duplicate transitions\n",
        -:  322:			numuniq, numdup );
        -:  323:
    #####:  324:		if ( fulltbl )
        -:  325:			{
    #####:  326:			tblsiz = lastdfa * numecs;
    #####:  327:			fprintf( err, "  %d table entries\n", tblsiz );
        -:  328:			}
        -:  329:
        -:  330:		else
        -:  331:			{
    #####:  332:			tblsiz = 2 * (lastdfa + numtemps) + 2 * tblend;
        -:  333:
    #####:  334:			fprintf( err, "  %d/%d base-def entries created\n",
        -:  335:				lastdfa + numtemps, current_max_dfas );
    #####:  336:			fprintf( err,
        -:  337:				"  %d/%d (peak %d) nxt-chk entries created\n",
        -:  338:				tblend, current_max_xpairs, peakpairs );
    #####:  339:			fprintf( err,
        -:  340:			"  %d/%d (peak %d) template nxt-chk entries created\n",
        -:  341:				numtemps * nummecs, current_max_template_xpairs,
        -:  342:				numtemps * numecs );
    #####:  343:			fprintf( err, "  %d empty table entries\n", nummt );
    #####:  344:			fprintf( err, "  %d protos created\n", numprots );
    #####:  345:			fprintf( err, "  %d templates created, %d uses\n",
        -:  346:				numtemps, tmpuses );
        -:  347:			}
        -:  348:
    #####:  349:		if ( useecs )
        -:  350:			{
    #####:  351:			tblsiz = tblsiz + csize;
    #####:  352:			fprintf( err,
        -:  353:				"  %d/%d equivalence classes created\n",
        -:  354:				numecs, csize );
        -:  355:			}
        -:  356:
    #####:  357:		if ( usemecs )
        -:  358:			{
    #####:  359:			tblsiz = tblsiz + numecs;
    #####:  360:			fprintf( err,
        -:  361:				"  %d/%d meta-equivalence classes created\n",
        -:  362:				nummecs, csize );
        -:  363:			}
        -:  364:
    #####:  365:		fprintf( err,
        -:  366:			"  %d (%d saved) hash collisions, %d DFAs equal\n",
        -:  367:			hshcol, hshsave, dfaeql );
    #####:  368:		fprintf( err, "  %d sets of reallocations needed\n",
        -:  369:			num_reallocs );
    #####:  370:		fprintf( err, "  %d total table entries needed\n", tblsiz );
        -:  371:		}
        -:  372:
        -:  373:#ifndef VMS
        1:  374:	exit( exit_status );
        -:  375:#else
        -:  376:	exit( exit_status + 1 );
        -:  377:#endif
        -:  378:	}
        -:  379:
        -:  380:
        -:  381:/* flexinit - initialize flex */
        -:  382:
        1:  383:void flexinit( argc, argv )
        -:  384:int argc;
        -:  385:char **argv;
        -:  386:	{
        -:  387:	int i, sawcmpflag;
        -:  388:	int csize_given, interactive_given;
        -:  389:	char *arg, *mktemp();
        -:  390:
        1:  391:	printstats = syntaxerror = trace = spprdflt = caseins = false;
        1:  392:	lex_compat = false;
        1:  393:	C_plus_plus = backing_up_report = ddebug = fulltbl = fullspd = false;
        1:  394:	long_align = nowarn = yymore_used = continued_action = reject = false;
        1:  395:	yytext_is_array = yymore_really_used = reject_really_used = false;
        1:  396:	gen_line_dirs = usemecs = useecs = true;
        1:  397:	performance_report = 0;
        -:  398:
        1:  399:	sawcmpflag = false;
        1:  400:	use_read = use_stdout = false;
        1:  401:	csize_given = false;
        1:  402:	interactive_given = false;
        -:  403:
        -:  404:	/* Initialize dynamic array for holding the rule actions. */
        1:  405:	action_size = 2048;	/* default size of action array in bytes */
        1:  406:	action_array = allocate_character_array( action_size );
        1:  407:	defs1_offset = prolog_offset = action_offset = action_index = 0;
        1:  408:	action_array[0] = '\0';
        -:  409:
        -:  410:/* Commented by Amit Goel on 5th September 2001 to remove nomdeterminism */
        -:  411:/*	program_name = argv[0];  */
        -:  412:/* Added by Amit Goel on 5th September 2001 */
        1:  413:        program_name = "Executable";
        -:  414:
        2:  415:	if ( program_name[0] != '\0' &&
        1:  416:	     program_name[strlen( program_name ) - 1] == '+' )
    #####:  417:		C_plus_plus = true;
        -:  418:
        -:  419:/* ### add for testing ### */
        1:  420:        ++argv;--argc;
        -:  421:/* ####################### */
        -:  422:
        -:  423:
        -:  424:	/* read flags */
        1:  425:	for ( --argc, ++argv; argc ; --argc, ++argv )
        -:  426:		{
        1:  427:		if ( argv[0][0] != '-' || argv[0][1] == '\0' )
        -:  428:			break;
        -:  429:
    #####:  430:		arg = argv[0];
        -:  431:
    #####:  432:		for ( i = 1; arg[i] != '\0'; ++i )
    #####:  433:			switch ( arg[i] )
        -:  434:				{
        -:  435:				case '+':
    #####:  436:					C_plus_plus = true;
    #####:  437:					break;
        -:  438:
        -:  439:				case 'B':
    #####:  440:					interactive = false;
    #####:  441:					interactive_given = true;
    #####:  442:					break;
        -:  443:
        -:  444:				case 'b':
    #####:  445:					backing_up_report = true;
    #####:  446:					break;
        -:  447:
        -:  448:				case 'c':
    #####:  449:					fprintf( err,
        -:  450:	"%s: Assuming use of deprecated -c flag is really intended to be -C\n",
        -:  451:					program_name );
        -:  452:
        -:  453:					/* fall through */
        -:  454:
        -:  455:				case 'C':
    #####:  456:					if ( i != 1 )
    #####:  457:						flexerror(
        -:  458:					"-C flag must be given separately" );
        -:  459:
    #####:  460:					if ( ! sawcmpflag )
        -:  461:						{
    #####:  462:						useecs = false;
    #####:  463:						usemecs = false;
    #####:  464:						fulltbl = false;
    #####:  465:						sawcmpflag = true;
        -:  466:						}
        -:  467:
    #####:  468:					for ( ++i; arg[i] != '\0'; ++i )
    #####:  469:						switch ( arg[i] )
        -:  470:							{
        -:  471:							case 'a':
    #####:  472:								long_align =
        -:  473:									true;
    #####:  474:								break;
        -:  475:
        -:  476:							case 'e':
    #####:  477:								useecs = true;
    #####:  478:								break;
        -:  479:
        -:  480:							case 'F':
    #####:  481:								fullspd = true;
    #####:  482:								break;
        -:  483:
        -:  484:							case 'f':
    #####:  485:								fulltbl = true;
    #####:  486:								break;
        -:  487:
        -:  488:							case 'm':
    #####:  489:								usemecs = true;
    #####:  490:								break;
        -:  491:
        -:  492:							case 'r':
    #####:  493:								use_read = true;
    #####:  494:								break;
        -:  495:
        -:  496:							default:
    #####:  497:								lerrif(
        -:  498:						"unknown -C option '%c'",
    #####:  499:								(int) arg[i] );
    #####:  500:								break;
        -:  501:							}
        -:  502:
    #####:  503:					goto get_next_arg;
        -:  504:
        -:  505:				case 'd':
    #####:  506:					ddebug = true;
    #####:  507:					break;
        -:  508:
        -:  509:				case 'f':
    #####:  510:					useecs = usemecs = false;
    #####:  511:					use_read = fulltbl = true;
    #####:  512:					break;
        -:  513:
        -:  514:				case 'F':
    #####:  515:					useecs = usemecs = false;
    #####:  516:					use_read = fullspd = true;
    #####:  517:					break;
        -:  518:
        -:  519:				case 'h':
    #####:  520:					usage();
    #####:  521:					exit( 0 );
        -:  522:
        -:  523:				case 'I':
    #####:  524:					interactive = true;
    #####:  525:					interactive_given = true;
    #####:  526:					break;
        -:  527:
        -:  528:				case 'i':
    #####:  529:					caseins = true;
    #####:  530:					break;
        -:  531:
        -:  532:				case 'l':
    #####:  533:					lex_compat = true;
    #####:  534:					break;
        -:  535:
        -:  536:				case 'L':
    #####:  537:					gen_line_dirs = false;
    #####:  538:					break;
        -:  539:
        -:  540:				case 'n':
        -:  541:					/* Stupid do-nothing deprecated
        -:  542:					 * option.
        -:  543:					 */
    #####:  544:					break;
        -:  545:
        -:  546:				case 'P':
    #####:  547:					if ( i != 1 )
    #####:  548:						flexerror(
        -:  549:					"-P flag must be given separately" );
        -:  550:
    #####:  551:					prefix = arg + i + 1;
    #####:  552:					goto get_next_arg;
        -:  553:
        -:  554:				case 'p':
    #####:  555:					++performance_report;
    #####:  556:					break;
        -:  557:
        -:  558:				case 'S':
    #####:  559:					if ( i != 1 )
    #####:  560:						flexerror(
        -:  561:					"-S flag must be given separately" );
        -:  562:
    #####:  563:					skelname = arg + i + 1;
    #####:  564:					goto get_next_arg;
        -:  565:
        -:  566:				case 's':
    #####:  567:					spprdflt = true;
    #####:  568:					break;
        -:  569:
        -:  570:				case 't':
    #####:  571:					use_stdout = true;
    #####:  572:					break;
        -:  573:
        -:  574:				case 'T':
    #####:  575:					trace = true;
    #####:  576:					break;
        -:  577:
        -:  578:				case 'v':
    #####:  579:					printstats = true;
    #####:  580:					break;
        -:  581:
        -:  582:				case 'V':
    #####:  583:					fprintf( err, "%s version %s\n",
        -:  584:						program_name, flex_version );
    #####:  585:					exit( 0 );
        -:  586:
        -:  587:				case 'w':
    #####:  588:					nowarn = true;
    #####:  589:					break;
        -:  590:
        -:  591:				case '7':
    #####:  592:					csize = 128;
    #####:  593:					csize_given = true;
    #####:  594:					break;
        -:  595:
        -:  596:				case '8':
    #####:  597:					csize = CSIZE;
    #####:  598:					csize_given = true;
    #####:  599:					break;
        -:  600:
        -:  601:				default:
    #####:  602:					fprintf( err,
        -:  603:						"%s: unknown flag '%c'\n",
    #####:  604:						program_name, (int) arg[i] );
    #####:  605:					usage();
    #####:  606:					exit( 1 );
        -:  607:				}
        -:  608:
        -:  609:		/* Used by -C, -S and -P flags in lieu of a "continue 2"
        -:  610:		 * control.
        -:  611:		 */
        -:  612:		get_next_arg: ;
        -:  613:		}
        -:  614:
        1:  615:	if ( ! csize_given )
        -:  616:		{
        1:  617:		if ( (fulltbl || fullspd) && ! useecs )
    #####:  618:			csize = DEFAULT_CSIZE;
        -:  619:		else
        1:  620:			csize = CSIZE;
        -:  621:		}
        -:  622:
        1:  623:	if ( ! interactive_given )
        -:  624:		{
        1:  625:		if ( fulltbl || fullspd )
    #####:  626:			interactive = false;
        -:  627:		else
        1:  628:			interactive = true;
        -:  629:		}
        -:  630:
        1:  631:	if ( lex_compat )
        -:  632:		{
    #####:  633:		if ( C_plus_plus )
    #####:  634:			flexerror( "Can't use -+ with -l option" );
        -:  635:
    #####:  636:		if ( fulltbl || fullspd )
    #####:  637:			flexerror( "Can't use -f or -F with -l option" );
        -:  638:
        -:  639:		/* Don't rely on detecting use of yymore() and REJECT,
        -:  640:		 * just assume they'll be used.
        -:  641:		 */
    #####:  642:		yymore_really_used = reject_really_used = true;
        -:  643:
    #####:  644:		yytext_is_array = true;
    #####:  645:		use_read = false;
        -:  646:		}
        -:  647:
        1:  648:	if ( (fulltbl || fullspd) && usemecs )
    #####:  649:		flexerror( "-Cf/-CF and -Cm don't make sense together" );
        -:  650:
        1:  651:	if ( (fulltbl || fullspd) && interactive )
    #####:  652:		flexerror( "-Cf/-CF and -I are incompatible" );
        -:  653:
        1:  654:	if ( fulltbl && fullspd )
    #####:  655:		flexerror( "-Cf and -CF are mutually exclusive" );
        -:  656:
        1:  657:	if ( C_plus_plus && fullspd )
    #####:  658:		flexerror( "Can't use -+ with -CF option" );
        -:  659:
        1:  660:	if ( ! use_stdout )
        -:  661:		{
        -:  662:		FILE *prev_stdout;
        -:  663:		char *suffix;
        -:  664:
        1:  665:		if ( C_plus_plus )
    #####:  666:			suffix = "cc";
        -:  667:		else
        1:  668:			suffix = "c";
        -:  669:
        1:  670:		sprintf( outfile_path, outfile_template, prefix, suffix );
        -:  671:
        1:  672:		prev_stdout = freopen( outfile_path, "w", stdout );
        -:  673:
        1:  674:		if ( prev_stdout == NULL )
    #####:  675:			lerrsf( "could not create %s", outfile_path );
        -:  676:
        1:  677:		outfile_created = 1;
        -:  678:		}
        -:  679:
        1:  680:	num_input_files = argc;
        1:  681:	input_files = argv;
        1:  682:	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
        -:  683:
        1:  684:	if ( backing_up_report )
        -:  685:		{
        -:  686:#ifndef SHORT_FILE_NAMES
    #####:  687:		backing_up_file = fopen( "lex.backup", "w" );
        -:  688:#else
        -:  689:		backing_up_file = fopen( "lex.bck", "w" );
        -:  690:#endif
        -:  691:
    #####:  692:		if ( backing_up_file == NULL )
    #####:  693:			flexerror( "could not create lex.backup" );
        -:  694:		}
        -:  695:
        -:  696:	else
        1:  697:		backing_up_file = NULL;
        -:  698:
        -:  699:
        1:  700:	lastccl = 0;
        1:  701:	lastsc = 0;
        -:  702:
        1:  703:	if ( skelname && (skelfile = fopen( skelname, "r" )) == NULL )
    #####:  704:		lerrsf( "can't open skeleton file %s", skelname );
        -:  705:#ifndef F_JR_1
        1:  706:	if ( strcmp( prefix, "yy" ) )
        -:  707:#else
        -:  708:    if ( yy_strcmp( prefix, "yy" ) )
        -:  709:#endif
        -:  710:		{
        -:  711:#define GEN_PREFIX(name) printf( "#define yy%s %s%s\n", name, prefix, name );
    #####:  712:		GEN_PREFIX( "FlexLexer" );
    #####:  713:		GEN_PREFIX( "_create_buffer" );
    #####:  714:		GEN_PREFIX( "_delete_buffer" );
    #####:  715:		GEN_PREFIX( "_flex_debug" );
    #####:  716:		GEN_PREFIX( "_init_buffer" );
    #####:  717:		GEN_PREFIX( "_load_buffer_state" );
    #####:  718:		GEN_PREFIX( "_switch_to_buffer" );
    #####:  719:		GEN_PREFIX( "in" );
    #####:  720:		GEN_PREFIX( "leng" );
    #####:  721:		GEN_PREFIX( "lex" );
    #####:  722:		GEN_PREFIX( "out" );
    #####:  723:		GEN_PREFIX( "restart" );
    #####:  724:		GEN_PREFIX( "text" );
    #####:  725:		GEN_PREFIX( "wrap" );
    #####:  726:		printf( "\n" );
        -:  727:		}
        -:  728:
        -:  729:
        1:  730:	lastdfa = lastnfa = 0;
        1:  731:	num_rules = num_eof_rules = default_rule = 0;
        1:  732:	numas = numsnpairs = tmpuses = 0;
        1:  733:	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
        1:  734:	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
        1:  735:	num_backing_up = onesp = numprots = 0;
        1:  736:	variable_trailing_context_rules = bol_needed = false;
        -:  737:
        1:  738:	linenum = sectnum = 1;
        1:  739:	firstprot = NIL;
        -:  740:
        -:  741:	/* Used in mkprot() so that the first proto goes in slot 1
        -:  742:	 * of the proto queue.
        -:  743:	 */
        1:  744:	lastprot = 1;
        -:  745:
        1:  746:	if ( useecs )
        -:  747:		{
        -:  748:		/* Set up doubly-linked equivalence classes. */
        -:  749:
        -:  750:		/* We loop all the way up to csize, since ecgroup[csize] is
        -:  751:		 * the position used for NUL characters.
        -:  752:		 */
        1:  753:		ecgroup[1] = NIL;
        -:  754:
      256:  755:		for ( i = 2; i <= csize; ++i )
        -:  756:			{
      255:  757:			ecgroup[i] = i - 1;
      255:  758:			nextecm[i - 1] = i;
        -:  759:			}
        -:  760:
        1:  761:		nextecm[csize] = NIL;
        -:  762:		}
        -:  763:
        -:  764:	else
        -:  765:		{
        -:  766:		/* Put everything in its own equivalence class. */
    #####:  767:		for ( i = 1; i <= csize; ++i )
        -:  768:			{
    #####:  769:			ecgroup[i] = i;
    #####:  770:			nextecm[i] = BAD_SUBSCRIPT;	/* to catch errors */
        -:  771:			}
        -:  772:		}
        -:  773:
        1:  774:	set_up_initial_allocations();
        1:  775:	}
        -:  776:
        -:  777:
        -:  778:/* readin - read in the rules section of the input file(s) */
        -:  779:
        1:  780:void readin()
        -:  781:	{
        1:  782:	skelout();
        -:  783:
        1:  784:	line_directive_out( (FILE *) 0 );
        -:  785:
        1:  786:	if ( yyparse() )
        -:  787:		{
    #####:  788:		pinpoint_message( "fatal parse error" );
    #####:  789:		flexend( 1 );
        -:  790:		}
        -:  791:
        1:  792:	if ( syntaxerror )
    #####:  793:		flexend( 1 );
        -:  794:
        -:  795:#ifndef F_AA_3
        1:  796:	if ( yymore_really_used == REALLY_USED )
        -:  797:#else
        -:  798:	if ( yymore_really_used = REALLY_NOT_USED )
        -:  799:#endif
        -:  800:
    #####:  801:		yymore_used = true;
        1:  802:	else if ( yymore_really_used == REALLY_NOT_USED )
    #####:  803:		yymore_used = false;
        -:  804:
        1:  805:	if ( reject_really_used == REALLY_USED )
    #####:  806:		reject = true;
        1:  807:	else if ( reject_really_used == REALLY_NOT_USED )
    #####:  808:		reject = false;
        -:  809:
        -:  810:#ifndef	F_HD_1
        -:  811:	if ( performance_report > 0 )
        -:  812:#else
        1:  813:	if ( performance_report >= 0 )
        -:  814:#endif
        -:  815:		{
        1:  816:		if ( lex_compat )
        -:  817:			{
    #####:  818:			fprintf( err,
        -:  819:"-l AT&T lex compatibility option entails a large performance penalty\n" );
    #####:  820:			fprintf( err,
        -:  821:" and may be the actual source of other reported performance penalties\n" );
        -:  822:			}
        -:  823:
        1:  824:		if ( performance_report > 1 )
        -:  825:			{
    #####:  826:			if ( interactive )
    #####:  827:				fprintf( err,
        -:  828:		"-I (interactive) entails a minor performance penalty\n" );
        -:  829:
    #####:  830:			if ( yymore_used )
    #####:  831:				fprintf( err,
        -:  832:			"yymore() entails a minor performance penalty\n" );
        -:  833:			}
        -:  834:
        1:  835:		if ( reject )
    #####:  836:			fprintf( err,
        -:  837:			"REJECT entails a large performance penalty\n" );
        -:  838:
        1:  839:		if ( variable_trailing_context_rules )
    #####:  840:			fprintf( err,
        -:  841:"Variable trailing context rules entail a large performance penalty\n" );
        -:  842:		}
        -:  843:
        1:  844:	if ( reject )
    #####:  845:		real_reject = true;
        -:  846:
        1:  847:	if ( variable_trailing_context_rules )
    #####:  848:		reject = true;
        -:  849:
        -:  850:#ifndef F_AA_6
        1:  851:	if ( (fulltbl || fullspd) && reject )
        -:  852:#else
        -:  853:	if ( fulltbl || (fullspd && reject) )
        -:  854:#endif
        -:  855:		{
    #####:  856:		if ( real_reject )
    #####:  857:			flexerror( "REJECT cannot be used with -f or -F" );
        -:  858:		else
    #####:  859:			flexerror(
        -:  860:	"variable trailing context rules cannot be used with -f or -F" );
        -:  861:		}
        -:  862:
        1:  863:	if ( csize == 256 )
        1:  864:		puts( "typedef unsigned char YY_CHAR;" );
        -:  865:	else
    #####:  866:		puts( "typedef char YY_CHAR;" );
        -:  867:
        1:  868:	if ( C_plus_plus )
        -:  869:		{
    #####:  870:		puts( "#define yytext_ptr yytext" );
        -:  871:
    #####:  872:		if ( interactive )
    #####:  873:			puts( "#define YY_INTERACTIVE" );
        -:  874:		}
        -:  875:
        1:  876:	if ( fullspd )
    #####:  877:		printf(
        -:  878:		"typedef const struct yy_trans_info *yy_state_type;\n" );
        1:  879:	else if ( ! C_plus_plus )
        1:  880:		printf( "typedef int yy_state_type;\n" );
        -:  881:
        1:  882:	if ( reject )
    #####:  883:		printf( "\n#define YY_USES_REJECT\n" );
        -:  884:
        1:  885:	if ( ddebug )
    #####:  886:		puts( "\n#define FLEX_DEBUG" );
        -:  887:
        1:  888:	if ( lex_compat )
        -:  889:		{
    #####:  890:		printf( "FILE *yyin = stdin, *yyout = stdout;\n" );
    #####:  891:		printf( "extern int yylineno;\n" );
    #####:  892:		printf( "int yylineno = 1;\n" );
        -:  893:		}
        1:  894:	else if ( ! C_plus_plus )
        1:  895:		printf( "FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;\n" );
        -:  896:
        1:  897:	if ( C_plus_plus )
    #####:  898:		printf( "\n#include <FlexLexer.h>\n" );
        -:  899:
        -:  900:	else
        -:  901:		{
        1:  902:		if ( yytext_is_array )
    #####:  903:			puts( "extern char yytext[];\n" );
        -:  904:
        -:  905:		else
        -:  906:			{
        1:  907:			puts( "extern char *yytext;" );
        1:  908:			puts( "#define yytext_ptr yytext" );
        -:  909:			}
        -:  910:		}
        -:  911:
        1:  912:	if ( useecs )
        1:  913:		numecs = cre8ecs( nextecm, ecgroup, csize );
        -:  914:	else
    #####:  915:		numecs = csize;
        -:  916:
        -:  917:	/* Now map the equivalence class for NUL to its expected place. */
        1:  918:	ecgroup[0] = ecgroup[csize];
        1:  919:	NUL_ec = ABS( ecgroup[0] );
        -:  920:
        1:  921:	if ( useecs )
        1:  922:		ccl2ecl();
        1:  923:	}
        -:  924:
        -:  925:
        -:  926:/* set_up_initial_allocations - allocate memory for internal tables */
        -:  927:
        1:  928:void set_up_initial_allocations()
        -:  929:	{
        1:  930:	current_mns = INITIAL_MNS;
        1:  931:	firstst = allocate_integer_array( current_mns );
        1:  932:	lastst = allocate_integer_array( current_mns );
        1:  933:	finalst = allocate_integer_array( current_mns );
        1:  934:	transchar = allocate_integer_array( current_mns );
        1:  935:	trans1 = allocate_integer_array( current_mns );
        1:  936:	trans2 = allocate_integer_array( current_mns );
        1:  937:	accptnum = allocate_integer_array( current_mns );
        1:  938:	assoc_rule = allocate_integer_array( current_mns );
        1:  939:	state_type = allocate_integer_array( current_mns );
        -:  940:
        1:  941:	current_max_rules = INITIAL_MAX_RULES;
        1:  942:	rule_type = allocate_integer_array( current_max_rules );
        1:  943:	rule_linenum = allocate_integer_array( current_max_rules );
        1:  944:	rule_useful = allocate_integer_array( current_max_rules );
        -:  945:
        1:  946:	current_max_scs = INITIAL_MAX_SCS;
        1:  947:	scset = allocate_integer_array( current_max_scs );
        1:  948:	scbol = allocate_integer_array( current_max_scs );
        1:  949:	scxclu = allocate_integer_array( current_max_scs );
        1:  950:	sceof = allocate_integer_array( current_max_scs );
        1:  951:	scname = allocate_char_ptr_array( current_max_scs );
        1:  952:	actvsc = allocate_integer_array( current_max_scs );
        -:  953:
        1:  954:	current_maxccls = INITIAL_MAX_CCLS;
        1:  955:	cclmap = allocate_integer_array( current_maxccls );
        1:  956:	ccllen = allocate_integer_array( current_maxccls );
        1:  957:	cclng = allocate_integer_array( current_maxccls );
        -:  958:
        1:  959:	current_max_ccl_tbl_size = INITIAL_MAX_CCL_TBL_SIZE;
        1:  960:	ccltbl = allocate_Character_array( current_max_ccl_tbl_size );
        -:  961:
        1:  962:	current_max_dfa_size = INITIAL_MAX_DFA_SIZE;
        -:  963:
        1:  964:	current_max_xpairs = INITIAL_MAX_XPAIRS;
        1:  965:	nxt = allocate_integer_array( current_max_xpairs );
        1:  966:	chk = allocate_integer_array( current_max_xpairs );
        -:  967:
        1:  968:	current_max_template_xpairs = INITIAL_MAX_TEMPLATE_XPAIRS;
        1:  969:	tnxt = allocate_integer_array( current_max_template_xpairs );
        -:  970:
        1:  971:	current_max_dfas = INITIAL_MAX_DFAS;
        1:  972:	base = allocate_integer_array( current_max_dfas );
        1:  973:	def = allocate_integer_array( current_max_dfas );
        1:  974:	dfasiz = allocate_integer_array( current_max_dfas );
        1:  975:	accsiz = allocate_integer_array( current_max_dfas );
        1:  976:	dhash = allocate_integer_array( current_max_dfas );
        1:  977:	dss = allocate_int_ptr_array( current_max_dfas );
        1:  978:	dfaacc = allocate_dfaacc_union( current_max_dfas );
        -:  979:
        1:  980:	nultrans = (int *) 0;
        1:  981:	}
        -:  982:
        -:  983:
    #####:  984:void usage()
        -:  985:	{
    #####:  986:	fprintf( err,
        -:  987:"%s [-bcdfhilnpstvwBFILTV78+ -C[aefFmr] -Pprefix -Sskeleton] [file ...]\n",
        -:  988:		program_name );
        -:  989:
    #####:  990:	fprintf( err,
        -:  991:		"\t-b  generate backing-up information to lex.backup\n" );
    #####:  992:	fprintf( err, "\t-c  do-nothing POSIX option\n" );
    #####:  993:	fprintf( err, "\t-d  turn on debug mode in generated scanner\n" );
    #####:  994:	fprintf( err, "\t-f  generate fast, large scanner\n" );
    #####:  995:	fprintf( err, "\t-h  produce this help message\n" );
    #####:  996:	fprintf( err, "\t-i  generate case-insensitive scanner\n" );
    #####:  997:	fprintf( err, "\t-l  maximal compatibility with original lex\n" );
    #####:  998:	fprintf( err, "\t-n  do-nothing POSIX option\n" );
    #####:  999:	fprintf( err, "\t-p  generate performance report to stderr\n" );
    #####: 1000:	fprintf( err,
        -: 1001:		"\t-s  suppress default rule to ECHO unmatched text\n" );
    #####: 1002:	fprintf( err,
        -: 1003:	"\t-t  write generated scanner on stdout instead of lex.yy.c\n" );
    #####: 1004:	fprintf( err,
        -: 1005:		"\t-v  write summary of scanner statistics to stderr\n" );
    #####: 1006:	fprintf( err, "\t-w  do not generate warnings\n" );
    #####: 1007:	fprintf( err, "\t-B  generate batch scanner (opposite of -I)\n" );
    #####: 1008:	fprintf( err,
        -: 1009:		"\t-F  use alternative fast scanner representation\n" );
    #####: 1010:	fprintf( err,
        -: 1011:		"\t-I  generate interactive scanner (opposite of -B)\n" );
    #####: 1012:	fprintf( err, "\t-L  suppress #line directives in scanner\n" );
    #####: 1013:	fprintf( err, "\t-T  %s should run in trace mode\n", program_name );
    #####: 1014:	fprintf( err, "\t-V  report %s version\n", program_name );
    #####: 1015:	fprintf( err, "\t-7  generate 7-bit scanner\n" );
    #####: 1016:	fprintf( err, "\t-8  generate 8-bit scanner\n" );
    #####: 1017:	fprintf( err, "\t-+  generate C++ scanner class\n" );
    #####: 1018:	fprintf( err,
        -: 1019:	"\t-C  specify degree of table compression (default is -Cem):\n" );
    #####: 1020:	fprintf( err,
        -: 1021:	"\t\t-Ca  trade off larger tables for better memory alignment\n" );
    #####: 1022:	fprintf( err, "\t\t-Ce  construct equivalence classes\n" );
    #####: 1023:	fprintf( err,
        -: 1024:	"\t\t-Cf  do not compress scanner tables; use -f representation\n" );
    #####: 1025:	fprintf( err,
        -: 1026:	"\t\t-CF  do not compress scanner tables; use -F representation\n" );
    #####: 1027:	fprintf( err, "\t\t-Cm  construct meta-equivalence classes\n" );
    #####: 1028:	fprintf( err,
        -: 1029:		"\t\t-Cr  use read() instead of stdio for scanner input\n" );
    #####: 1030:	fprintf( err, "\t-P  specify scanner prefix other than \"yy\"\n" );
    #####: 1031:	fprintf( err, "\t-S  specify skeleton file\n" );
    #####: 1032:	}
        -: 1033:/* ccl - routines for character classes */
        -: 1034:
        -: 1035:/*-
        -: 1036: * Copyright (c) 1990 The Regents of the University of California.
        -: 1037: * All rights reserved.
        -: 1038: *
        -: 1039: * This code is derived from software contributed to Berkeley by
        -: 1040: * Vern Paxson.
        -: 1041: * 
        -: 1042: * The United States Government has rights in this work pursuant
        -: 1043: * to contract no. DE-AC03-76SF00098 between the United States
        -: 1044: * Department of Energy and the University of California.
        -: 1045: *
        -: 1046: * Redistribution and use in source and binary forms are permitted provided
        -: 1047: * that: (1) source distributions retain this entire copyright notice and
        -: 1048: * comment, and (2) distributions including binaries display the following
        -: 1049: * acknowledgement:  ``This product includes software developed by the
        -: 1050: * University of California, Berkeley and its contributors'' in the
        -: 1051: * documentation or other materials provided with the distribution and in
        -: 1052: * all advertising materials mentioning features or use of this software.
        -: 1053: * Neither the name of the University nor the names of its contributors may
        -: 1054: * be used to endorse or promote products derived from this software without
        -: 1055: * specific prior written permission.
        -: 1056: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 1057: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 1058: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 1059: */
        -: 1060:
        -: 1061:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 1062:
        -: 1063:
        -: 1064:/* ccladd - add a single character to a ccl */
        -: 1065:
    #####: 1066:void ccladd( cclp, ch )
        -: 1067:int cclp;
        -: 1068:int ch;
        -: 1069:	{
        -: 1070:	int ind, len, newpos, i;
        -: 1071:
    #####: 1072:	check_char( ch );
        -: 1073:
    #####: 1074:	len = ccllen[cclp];
    #####: 1075:	ind = cclmap[cclp];
        -: 1076:
        -: 1077:	/* check to see if the character is already in the ccl */
        -: 1078:
    #####: 1079:	for ( i = 0; i < len; ++i )
    #####: 1080:		if ( ccltbl[ind + i] == ch )
    #####: 1081:			return;
        -: 1082:
    #####: 1083:	newpos = ind + len;
        -: 1084:
    #####: 1085:	if ( newpos >= current_max_ccl_tbl_size )
        -: 1086:		{
    #####: 1087:		current_max_ccl_tbl_size += MAX_CCL_TBL_SIZE_INCREMENT;
        -: 1088:
    #####: 1089:		++num_reallocs;
        -: 1090:
    #####: 1091:		ccltbl = reallocate_Character_array( ccltbl,
        -: 1092:						current_max_ccl_tbl_size );
        -: 1093:		}
        -: 1094:
    #####: 1095:	ccllen[cclp] = len + 1;
    #####: 1096:	ccltbl[newpos] = ch;
        -: 1097:	}
        -: 1098:
        -: 1099:
        -: 1100:/* cclinit - return an empty ccl */
        -: 1101:
        1: 1102:int cclinit()
        -: 1103:	{
        1: 1104:	if ( ++lastccl >= current_maxccls )
        -: 1105:		{
    #####: 1106:		current_maxccls += MAX_CCLS_INCREMENT;
        -: 1107:
    #####: 1108:		++num_reallocs;
        -: 1109:
    #####: 1110:		cclmap = reallocate_integer_array( cclmap, current_maxccls );
    #####: 1111:		ccllen = reallocate_integer_array( ccllen, current_maxccls );
    #####: 1112:		cclng = reallocate_integer_array( cclng, current_maxccls );
        -: 1113:		}
        -: 1114:
        1: 1115:	if ( lastccl == 1 )
        -: 1116:		/* we're making the first ccl */
        1: 1117:		cclmap[lastccl] = 0;
        -: 1118:
        -: 1119:	else
        -: 1120:		/* The new pointer is just past the end of the last ccl.
        -: 1121:		 * Since the cclmap points to the \first/ character of a
        -: 1122:		 * ccl, adding the length of the ccl to the cclmap pointer
        -: 1123:		 * will produce a cursor to the first free space.
        -: 1124:		 */
    #####: 1125:		cclmap[lastccl] = cclmap[lastccl - 1] + ccllen[lastccl - 1];
        -: 1126:
        1: 1127:	ccllen[lastccl] = 0;
        1: 1128:	cclng[lastccl] = 0;	/* ccl's start out life un-negated */
        -: 1129:
        1: 1130:	return lastccl;
        -: 1131:	}
        -: 1132:
        -: 1133:
        -: 1134:/* cclnegate - negate the given ccl */
        -: 1135:
        1: 1136:void cclnegate( cclp )
        -: 1137:int cclp;
        -: 1138:	{
        1: 1139:	cclng[cclp] = 1;
        1: 1140:	}
        -: 1141:
        -: 1142:
        -: 1143:/* list_character_set - list the members of a set of characters in CCL form
        -: 1144: *
        -: 1145: * Writes to the given file a character-class representation of those
        -: 1146: * characters present in the given CCL.  A character is present if it
        -: 1147: * has a non-zero value in the cset array.
        -: 1148: */
        -: 1149:
    #####: 1150:void list_character_set( file, cset )
        -: 1151:FILE *file;
        -: 1152:int cset[];
        -: 1153:	{
        -: 1154:	register int i;
        -: 1155:
    #####: 1156:	putc( '[', file );
        -: 1157:
    #####: 1158:	for ( i = 0; i < csize; ++i )
        -: 1159:		{
    #####: 1160:		if ( cset[i] )
        -: 1161:			{
    #####: 1162:			register int start_char = i;
        -: 1163:
    #####: 1164:			putc( ' ', file );
        -: 1165:
    #####: 1166:			fputs( readable_form( i ), file );
        -: 1167:
    #####: 1168:			while ( ++i < csize && cset[i] )
        -: 1169:				;
        -: 1170:
    #####: 1171:			if ( i - 1 > start_char )
        -: 1172:				/* this was a run */
    #####: 1173:				fprintf( file, "-%s", readable_form( i - 1 ) );
        -: 1174:
    #####: 1175:			putc( ' ', file );
        -: 1176:			}
        -: 1177:		}
        -: 1178:
    #####: 1179:	putc( ']', file );
    #####: 1180:	}
        -: 1181:/* dfa - DFA construction routines */
        -: 1182:
        -: 1183:/*-
        -: 1184: * Copyright (c) 1990 The Regents of the University of California.
        -: 1185: * All rights reserved.
        -: 1186: *
        -: 1187: * This code is derived from software contributed to Berkeley by
        -: 1188: * Vern Paxson.
        -: 1189: * 
        -: 1190: * The United States Government has rights in this work pursuant
        -: 1191: * to contract no. DE-AC03-76SF00098 between the United States
        -: 1192: * Department of Energy and the University of California.
        -: 1193: *
        -: 1194: * Redistribution and use in source and binary forms are permitted provided
        -: 1195: * that: (1) source distributions retain this entire copyright notice and
        -: 1196: * comment, and (2) distributions including binaries display the following
        -: 1197: * acknowledgement:  ``This product includes software developed by the
        -: 1198: * University of California, Berkeley and its contributors'' in the
        -: 1199: * documentation or other materials provided with the distribution and in
        -: 1200: * all advertising materials mentioning features or use of this software.
        -: 1201: * Neither the name of the University nor the names of its contributors may
        -: 1202: * be used to endorse or promote products derived from this software without
        -: 1203: * specific prior written permission.
        -: 1204: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 1205: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 1206: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 1207: */
        -: 1208:
        -: 1209:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 1210:
        -: 1211:
        -: 1212:
        -: 1213:/* declare functions that have forward references */
        -: 1214:
        -: 1215:void dump_associated_rules PROTO((FILE*, int));
        -: 1216:void dump_transitions PROTO((FILE*, int[]));
        -: 1217:void sympartition PROTO((int[], int, int[], int[]));
        -: 1218:int symfollowset PROTO((int[], int, int, int[]));
        -: 1219:
        -: 1220:
        -: 1221:/* check_for_backing_up - check a DFA state for backing up
        -: 1222: *
        -: 1223: * synopsis
        -: 1224: *     void check_for_backing_up( int ds, int state[numecs] );
        -: 1225: *
        -: 1226: * ds is the number of the state to check and state[] is its out-transitions,
        -: 1227: * indexed by equivalence class.
        -: 1228: */
        -: 1229:
        1: 1230:void check_for_backing_up( ds, state )
        -: 1231:int ds;
        -: 1232:int state[];
        -: 1233:	{
        2: 1234:	if ( (reject && ! dfaacc[ds].dfaacc_set) ||
        2: 1235:	     (! reject && ! dfaacc[ds].dfaacc_state) )
        -: 1236:		{ /* state is non-accepting */
    #####: 1237:		++num_backing_up;
        -: 1238:
    #####: 1239:		if ( backing_up_report )
        -: 1240:			{
    #####: 1241:			fprintf( backing_up_file,
        -: 1242:				"State #%d is non-accepting -\n", ds );
        -: 1243:
        -: 1244:			/* identify the state */
    #####: 1245:			dump_associated_rules( backing_up_file, ds );
        -: 1246:
        -: 1247:			/* Now identify it further using the out- and
        -: 1248:			 * jam-transitions.
        -: 1249:			 */
    #####: 1250:			dump_transitions( backing_up_file, state );
        -: 1251:
    #####: 1252:			putc( '\n', backing_up_file );
        -: 1253:			}
        -: 1254:		}
        1: 1255:	}
        -: 1256:
        -: 1257:
        -: 1258:/* check_trailing_context - check to see if NFA state set constitutes
        -: 1259: *                          "dangerous" trailing context
        -: 1260: *
        -: 1261: * synopsis
        -: 1262: *    void check_trailing_context( int nfa_states[num_states+1], int num_states,
        -: 1263: *				int accset[nacc+1], int nacc );
        -: 1264: *
        -: 1265: * NOTES
        -: 1266: *  Trailing context is "dangerous" if both the head and the trailing
        -: 1267: *  part are of variable size \and/ there's a DFA state which contains
        -: 1268: *  both an accepting state for the head part of the rule and NFA states
        -: 1269: *  which occur after the beginning of the trailing context.
        -: 1270: *
        -: 1271: *  When such a rule is matched, it's impossible to tell if having been
        -: 1272: *  in the DFA state indicates the beginning of the trailing context or
        -: 1273: *  further-along scanning of the pattern.  In these cases, a warning
        -: 1274: *  message is issued.
        -: 1275: *
        -: 1276: *    nfa_states[1 .. num_states] is the list of NFA states in the DFA.
        -: 1277: *    accset[1 .. nacc] is the list of accepting numbers for the DFA state.
        -: 1278: */
        -: 1279:
    #####: 1280:void check_trailing_context( nfa_states, num_states, accset, nacc )
        -: 1281:int *nfa_states, num_states;
        -: 1282:int *accset;
        -: 1283:register int nacc;
        -: 1284:	{
        -: 1285:	register int i, j;
        -: 1286:
    #####: 1287:	for ( i = 1; i <= num_states; ++i )
        -: 1288:		{
    #####: 1289:		int ns = nfa_states[i];
    #####: 1290:		register int type = state_type[ns];
    #####: 1291:		register int ar = assoc_rule[ns];
        -: 1292:
    #####: 1293:		if ( type == STATE_NORMAL || rule_type[ar] != RULE_VARIABLE )
        -: 1294:			{ /* do nothing */
        -: 1295:			}
        -: 1296:
    #####: 1297:		else if ( type == STATE_TRAILING_CONTEXT )
        -: 1298:			{
        -: 1299:			/* Potential trouble.  Scan set of accepting numbers
        -: 1300:			 * for the one marking the end of the "head".  We
        -: 1301:			 * assume that this looping will be fairly cheap
        -: 1302:			 * since it's rare that an accepting number set
        -: 1303:			 * is large.
        -: 1304:			 */
    #####: 1305:			for ( j = 1; j <= nacc; ++j )
    #####: 1306:				if ( accset[j] & YY_TRAILING_HEAD_MASK )
        -: 1307:					{
    #####: 1308:					line_warning(
        -: 1309:						"dangerous trailing context",
    #####: 1310:						rule_linenum[ar] );
    #####: 1311:					return;
        -: 1312:					}
        -: 1313:			}
        -: 1314:		}
        -: 1315:	}
        -: 1316:
        -: 1317:
        -: 1318:/* dump_associated_rules - list the rules associated with a DFA state
        -: 1319: *
        -: 1320: * Goes through the set of NFA states associated with the DFA and
        -: 1321: * extracts the first MAX_ASSOC_RULES unique rules, sorts them,
        -: 1322: * and writes a report to the given file.
        -: 1323: */
        -: 1324:
    #####: 1325:void dump_associated_rules( file, ds )
        -: 1326:FILE *file;
        -: 1327:int ds;
        -: 1328:	{
        -: 1329:	register int i, j;
    #####: 1330:	register int num_associated_rules = 0;
        -: 1331:	int rule_set[MAX_ASSOC_RULES + 1];
    #####: 1332:	int *dset = dss[ds];
    #####: 1333:	int size = dfasiz[ds];
        -: 1334:
    #####: 1335:	for ( i = 1; i <= size; ++i )
        -: 1336:		{
    #####: 1337:		register int rule_num = rule_linenum[assoc_rule[dset[i]]];
        -: 1338:
    #####: 1339:		for ( j = 1; j <= num_associated_rules; ++j )
    #####: 1340:			if ( rule_num == rule_set[j] )
    #####: 1341:				break;
        -: 1342:
    #####: 1343:		if ( j > num_associated_rules )
        -: 1344:			{ /* new rule */
    #####: 1345:			if ( num_associated_rules < MAX_ASSOC_RULES )
    #####: 1346:				rule_set[++num_associated_rules] = rule_num;
        -: 1347:			}
        -: 1348:		}
        -: 1349:
    #####: 1350:	bubble( rule_set, num_associated_rules );
        -: 1351:
    #####: 1352:	fprintf( file, " associated rule line numbers:" );
        -: 1353:
    #####: 1354:	for ( i = 1; i <= num_associated_rules; ++i )
        -: 1355:		{
    #####: 1356:		if ( i % 8 == 1 )
    #####: 1357:			putc( '\n', file );
        -: 1358:
    #####: 1359:		fprintf( file, "\t%d", rule_set[i] );
        -: 1360:		}
        -: 1361:
    #####: 1362:	putc( '\n', file );
    #####: 1363:	}
        -: 1364:
        -: 1365:
        -: 1366:/* dump_transitions - list the transitions associated with a DFA state
        -: 1367: *
        -: 1368: * synopsis
        -: 1369: *     dump_transitions( FILE *file, int state[numecs] );
        -: 1370: *
        -: 1371: * Goes through the set of out-transitions and lists them in human-readable
        -: 1372: * form (i.e., not as equivalence classes); also lists jam transitions
        -: 1373: * (i.e., all those which are not out-transitions, plus EOF).  The dump
        -: 1374: * is done to the given file.
        -: 1375: */
        -: 1376:
    #####: 1377:void dump_transitions( file, state )
        -: 1378:FILE *file;
        -: 1379:int state[];
        -: 1380:	{
        -: 1381:	register int i, ec;
        -: 1382:	int out_char_set[CSIZE];
        -: 1383:
    #####: 1384:	for ( i = 0; i < csize; ++i )
        -: 1385:		{
    #####: 1386:		ec = ABS( ecgroup[i] ); 
    #####: 1387:		out_char_set[i] = state[ec];
        -: 1388:		}
        -: 1389:
    #####: 1390:	fprintf( file, " out-transitions: " );
        -: 1391:
    #####: 1392:	list_character_set( file, out_char_set );
        -: 1393:
        -: 1394:	/* now invert the members of the set to get the jam transitions */
    #####: 1395:	for ( i = 0; i < csize; ++i )
    #####: 1396:		out_char_set[i] = ! out_char_set[i];
        -: 1397:
    #####: 1398:	fprintf( file, "\n jam-transitions: EOF " );
        -: 1399:
    #####: 1400:	list_character_set( file, out_char_set );
        -: 1401:
    #####: 1402:	putc( '\n', file );
    #####: 1403:	}
        -: 1404:
        -: 1405:
        -: 1406:/* epsclosure - construct the epsilon closure of a set of ndfa states
        -: 1407: *
        -: 1408: * synopsis
        -: 1409: *    int *epsclosure( int t[num_states], int *numstates_addr,
        -: 1410: *			int accset[num_rules+1], int *nacc_addr,
        -: 1411: *			int *hashval_addr );
        -: 1412: *
        -: 1413: * NOTES
        -: 1414: *  The epsilon closure is the set of all states reachable by an arbitrary
        -: 1415: *  number of epsilon transitions, which themselves do not have epsilon
        -: 1416: *  transitions going out, unioned with the set of states which have non-null
        -: 1417: *  accepting numbers.  t is an array of size numstates of nfa state numbers.
        -: 1418: *  Upon return, t holds the epsilon closure and *numstates_addr is updated.
        -: 1419: *  accset holds a list of the accepting numbers, and the size of accset is
        -: 1420: *  given by *nacc_addr.  t may be subjected to reallocation if it is not
        -: 1421: *  large enough to hold the epsilon closure.
        -: 1422: *
        -: 1423: *  hashval is the hash value for the dfa corresponding to the state set.
        -: 1424: */
        -: 1425:
        8: 1426:int *epsclosure( t, ns_addr, accset, nacc_addr, hv_addr )
        -: 1427:int *t, *ns_addr, accset[], *nacc_addr, *hv_addr;
        -: 1428:	{
        -: 1429:	register int stkpos, ns, tsp;
        8: 1430:	int numstates = *ns_addr, nacc, hashval, transsym, nfaccnum;
        -: 1431:	int stkend, nstate;
        -: 1432:	static int did_stk_init = false, *stk; 
        -: 1433:
        -: 1434:#define MARK_STATE(state) \
        -: 1435:trans1[state] = trans1[state] - MARKER_DIFFERENCE;
        -: 1436:
        -: 1437:#define IS_MARKED(state) (trans1[state] < 0)
        -: 1438:
        -: 1439:#define UNMARK_STATE(state) \
        -: 1440:trans1[state] = trans1[state] + MARKER_DIFFERENCE;
        -: 1441:
        -: 1442:#define CHECK_ACCEPT(state) \
        -: 1443:{ \
        -: 1444:nfaccnum = accptnum[state]; \
        -: 1445:if ( nfaccnum != NIL ) \
        -: 1446:accset[++nacc] = nfaccnum; \
        -: 1447:}
        -: 1448:
        -: 1449:#define DO_REALLOCATION \
        -: 1450:{ \
        -: 1451:current_max_dfa_size += MAX_DFA_SIZE_INCREMENT; \
        -: 1452:++num_reallocs; \
        -: 1453:t = reallocate_integer_array( t, current_max_dfa_size ); \
        -: 1454:stk = reallocate_integer_array( stk, current_max_dfa_size ); \
        -: 1455:} \
        -: 1456:
        -: 1457:#define PUT_ON_STACK(state) \
        -: 1458:{ \
        -: 1459:if ( ++stkend >= current_max_dfa_size ) \
        -: 1460:DO_REALLOCATION \
        -: 1461:stk[stkend] = state; \
        -: 1462:MARK_STATE(state) \
        -: 1463:}
        -: 1464:
        -: 1465:#define ADD_STATE(state) \
        -: 1466:{ \
        -: 1467:if ( ++numstates >= current_max_dfa_size ) \
        -: 1468:DO_REALLOCATION \
        -: 1469:t[numstates] = state; \
        -: 1470:hashval += state; \
        -: 1471:}
        -: 1472:
        -: 1473:#define STACK_STATE(state) \
        -: 1474:{ \
        -: 1475:PUT_ON_STACK(state) \
        -: 1476:CHECK_ACCEPT(state) \
        -: 1477:if ( nfaccnum != NIL || transchar[state] != SYM_EPSILON ) \
        -: 1478:ADD_STATE(state) \
        -: 1479:}
        -: 1480:
        -: 1481:
        8: 1482:	if ( ! did_stk_init )
        -: 1483:		{
        1: 1484:		stk = allocate_integer_array( current_max_dfa_size );
        1: 1485:		did_stk_init = true;
        -: 1486:		}
        -: 1487:
        8: 1488:	nacc = stkend = hashval = 0;
        -: 1489:
       16: 1490:	for ( nstate = 1; nstate <= numstates; ++nstate )
        -: 1491:		{
        8: 1492:		ns = t[nstate];
        -: 1493:
        -: 1494:		/* The state could be marked if we've already pushed it onto
        -: 1495:		 * the stack.
        -: 1496:		 */
        8: 1497:		if ( ! IS_MARKED(ns) )
        -: 1498:			{
        8: 1499:			PUT_ON_STACK(ns)
        8: 1500:			CHECK_ACCEPT(ns)
        8: 1501:			hashval += ns;
        -: 1502:			}
        -: 1503:		}
        -: 1504:
       28: 1505:	for ( stkpos = 1; stkpos <= stkend; ++stkpos )
        -: 1506:		{
       20: 1507:		ns = stk[stkpos];
       20: 1508:		transsym = transchar[ns];
        -: 1509:
       20: 1510:		if ( transsym == SYM_EPSILON )
        -: 1511:			{
       16: 1512:			tsp = trans1[ns] + MARKER_DIFFERENCE;
        -: 1513:
       16: 1514:			if ( tsp != NO_TRANSITION )
        -: 1515:				{
        6: 1516:				if ( ! IS_MARKED(tsp) )
        6: 1517:					STACK_STATE(tsp)
        -: 1518:
        6: 1519:				tsp = trans2[ns];
        -: 1520:
        6: 1521:				if ( tsp != NO_TRANSITION && ! IS_MARKED(tsp) )
        6: 1522:					STACK_STATE(tsp)
        -: 1523:				}
        -: 1524:			}
        -: 1525:		}
        -: 1526:
        -: 1527:	/* Clear out "visit" markers. */
        -: 1528:
       28: 1529:	for ( stkpos = 1; stkpos <= stkend; ++stkpos )
        -: 1530:		{
       20: 1531:		if ( IS_MARKED(stk[stkpos]) )
       20: 1532:			UNMARK_STATE(stk[stkpos])
        -: 1533:		else
    #####: 1534:			flexfatal( "consistency check failed in epsclosure()" );
        -: 1535:		}
        -: 1536:
        8: 1537:	*ns_addr = numstates;
        8: 1538:	*hv_addr = hashval;
        8: 1539:	*nacc_addr = nacc;
        -: 1540:
        8: 1541:	return t;
        -: 1542:	}
        -: 1543:
        -: 1544:
        -: 1545:/* increase_max_dfas - increase the maximum number of DFAs */
        -: 1546:
    #####: 1547:void increase_max_dfas()
        -: 1548:	{
    #####: 1549:	current_max_dfas += MAX_DFAS_INCREMENT;
        -: 1550:
    #####: 1551:	++num_reallocs;
        -: 1552:
    #####: 1553:	base = reallocate_integer_array( base, current_max_dfas );
    #####: 1554:	def = reallocate_integer_array( def, current_max_dfas );
    #####: 1555:	dfasiz = reallocate_integer_array( dfasiz, current_max_dfas );
    #####: 1556:	accsiz = reallocate_integer_array( accsiz, current_max_dfas );
    #####: 1557:	dhash = reallocate_integer_array( dhash, current_max_dfas );
    #####: 1558:	dss = reallocate_int_ptr_array( dss, current_max_dfas );
    #####: 1559:	dfaacc = reallocate_dfaacc_union( dfaacc, current_max_dfas );
        -: 1560:
    #####: 1561:	if ( nultrans )
    #####: 1562:		nultrans =
    #####: 1563:			reallocate_integer_array( nultrans, current_max_dfas );
    #####: 1564:	}
        -: 1565:
        -: 1566:
        -: 1567:/* ntod - convert an ndfa to a dfa
        -: 1568: *
        -: 1569: * Creates the dfa corresponding to the ndfa we've constructed.  The
        -: 1570: * dfa starts out in state #1.
        -: 1571: */
        -: 1572:
        1: 1573:void ntod()
        -: 1574:	{
        -: 1575:	int *accset, ds, nacc, newds;
        -: 1576:	int sym, hashval, numstates, dsize;
        -: 1577:	int num_full_table_rows;	/* used only for -f */
        -: 1578:	int *nset, *dset;
        -: 1579:	int targptr, totaltrans, i, comstate, comfreq, targ;
        -: 1580:	int *epsclosure(), snstods(), symlist[CSIZE + 1];
        -: 1581:	int num_start_states;
        -: 1582:	int todo_head, todo_next;
        -: 1583:
        -: 1584:	/* Note that the following are indexed by *equivalence classes*
        -: 1585:	 * and not by characters.  Since equivalence classes are indexed
        -: 1586:	 * beginning with 1, even if the scanner accepts NUL's, this
        -: 1587:	 * means that (since every character is potentially in its own
        -: 1588:	 * equivalence class) these arrays must have room for indices
        -: 1589:	 * from 1 to CSIZE, so their size must be CSIZE + 1.
        -: 1590:	 */
        -: 1591:	int duplist[CSIZE + 1], state[CSIZE + 1];
        -: 1592:	int targfreq[CSIZE + 1], targstate[CSIZE + 1];
        -: 1593:
        1: 1594:	accset = allocate_integer_array( num_rules + 1 );
        1: 1595:	nset = allocate_integer_array( current_max_dfa_size );
        -: 1596:
        -: 1597:	/* The "todo" queue is represented by the head, which is the DFA
        -: 1598:	 * state currently being processed, and the "next", which is the
        -: 1599:	 * next DFA state number available (not in use).  We depend on the
        -: 1600:	 * fact that snstods() returns DFA's \in increasing order/, and thus
        -: 1601:	 * need only know the bounds of the dfas to be processed.
        -: 1602:	 */
        1: 1603:	todo_head = todo_next = 0;
        -: 1604:
      258: 1605:	for ( i = 0; i <= csize; ++i )
        -: 1606:		{
      257: 1607:		duplist[i] = NIL;
      257: 1608:		symlist[i] = false;
        -: 1609:		}
        -: 1610:
        3: 1611:	for ( i = 0; i <= num_rules; ++i )
        2: 1612:		accset[i] = NIL;
        -: 1613:
        1: 1614:	if ( trace )
        -: 1615:		{
    #####: 1616:		dumpnfa( scset[1] );
    #####: 1617:		fputs( "\n\nDFA Dump:\n\n", err );
        -: 1618:		}
        -: 1619:
        1: 1620:	inittbl();
        -: 1621:
        -: 1622:	/* Check to see whether we should build a separate table for
        -: 1623:	 * transitions on NUL characters.  We don't do this for full-speed
        -: 1624:	 * (-F) scanners, since for them we don't have a simple state
        -: 1625:	 * number lying around with which to index the table.  We also
        -: 1626:	 * don't bother doing it for scanners unless (1) NUL is in its own
        -: 1627:	 * equivalence class (indicated by a positive value of
        -: 1628:	 * ecgroup[NUL]), (2) NUL's equivalence class is the last
        -: 1629:	 * equivalence class, and (3) the number of equivalence classes is
        -: 1630:	 * the same as the number of characters.  This latter case comes
        -: 1631:	 * about when useecs is false or when it's true but every character
        -: 1632:	 * still manages to land in its own class (unlikely, but it's
        -: 1633:	 * cheap to check for).  If all these things are true then the
        -: 1634:	 * character code needed to represent NUL's equivalence class for
        -: 1635:	 * indexing the tables is going to take one more bit than the
        -: 1636:	 * number of characters, and therefore we won't be assured of
        -: 1637:	 * being able to fit it into a YY_CHAR variable.  This rules out
        -: 1638:	 * storing the transitions in a compressed table, since the code
        -: 1639:	 * for interpreting them uses a YY_CHAR variable (perhaps it
        -: 1640:	 * should just use an integer, though; this is worth pondering ...
        -: 1641:	 * ###).
        -: 1642:	 *
        -: 1643:	 * Finally, for full tables, we want the number of entries in the
        -: 1644:	 * table to be a power of two so the array references go fast (it
        -: 1645:	 * will just take a shift to compute the major index).  If
        -: 1646:	 * encoding NUL's transitions in the table will spoil this, we
        -: 1647:	 * give it its own table (note that this will be the case if we're
        -: 1648:	 * not using equivalence classes).
        -: 1649:	 */
        -: 1650:
        -: 1651:	/* Note that the test for ecgroup[0] == numecs below accomplishes
        -: 1652:	 * both (1) and (2) above
        -: 1653:	 */
        1: 1654:	if ( ! fullspd && ecgroup[0] == numecs )
        -: 1655:		{
        -: 1656:		/* NUL is alone in its equivalence class, which is the
        -: 1657:		 * last one.
        -: 1658:		 */
    #####: 1659:		int use_NUL_table = (numecs == csize);
        -: 1660:
    #####: 1661:		if ( fulltbl && ! use_NUL_table )
        -: 1662:			{
        -: 1663:			/* We still may want to use the table if numecs
        -: 1664:			 * is a power of 2.
        -: 1665:			 */
        -: 1666:			int power_of_two;
        -: 1667:
    #####: 1668:			for ( power_of_two = 1; power_of_two <= csize;
    #####: 1669:			      power_of_two *= 2 )
    #####: 1670:				if ( numecs == power_of_two )
        -: 1671:					{
    #####: 1672:					use_NUL_table = true;
    #####: 1673:					break;
        -: 1674:					}
        -: 1675:			}
        -: 1676:
    #####: 1677:		if ( use_NUL_table )
    #####: 1678:			nultrans = allocate_integer_array( current_max_dfas );
        -: 1679:
        -: 1680:		/* From now on, nultrans != nil indicates that we're
        -: 1681:		 * saving null transitions for later, separate encoding.
        -: 1682:		 */
        -: 1683:		}
        -: 1684:
        -: 1685:
        1: 1686:	if ( fullspd )
        -: 1687:		{
    #####: 1688:		for ( i = 0; i <= numecs; ++i )
    #####: 1689:			state[i] = 0;
        -: 1690:
    #####: 1691:		place_state( state, 0, 0 );
    #####: 1692:		dfaacc[i].dfaacc_state = 0;
        -: 1693:		}
        -: 1694:
        1: 1695:	else if ( fulltbl )
        -: 1696:		{
    #####: 1697:		if ( nultrans )
        -: 1698:			/* We won't be including NUL's transitions in the
        -: 1699:			 * table, so build it for entries from 0 .. numecs - 1.
        -: 1700:			 */
    #####: 1701:			num_full_table_rows = numecs;
        -: 1702:
        -: 1703:		else
        -: 1704:			/* Take into account the fact that we'll be including
        -: 1705:			 * the NUL entries in the transition table.  Build it
        -: 1706:			 * from 0 .. numecs.
        -: 1707:			 */
    #####: 1708:			num_full_table_rows = numecs + 1;
        -: 1709:
        -: 1710:		/* Unless -Ca, declare it "short" because it's a real
        -: 1711:		 * long-shot that that won't be large enough.
        -: 1712:		 */
    #####: 1713:		printf( "static const %s yy_nxt[][%d] =\n    {\n",
        -: 1714:			/* '}' so vi doesn't get too confused */
    #####: 1715:			long_align ? "long" : "short", num_full_table_rows );
        -: 1716:
        -: 1717:		/* Generate 0 entries for state #0. */
    #####: 1718:		for ( i = 0; i < num_full_table_rows; ++i )
    #####: 1719:			mk2data( 0 );
        -: 1720:
        -: 1721:		/* Force ',' and dataflush() next call to mk2data().*/
    #####: 1722:		datapos = NUMDATAITEMS;
        -: 1723:
        -: 1724:		/* Force extra blank line next dataflush(). */
    #####: 1725:		dataline = NUMDATALINES;
        -: 1726:		}
        -: 1727:
        -: 1728:	/* Create the first states. */
        -: 1729:
        1: 1730:	num_start_states = lastsc * 2;
        -: 1731:
        5: 1732:	for ( i = 1; i <= num_start_states; ++i )
        -: 1733:		{
        4: 1734:		numstates = 1;
        -: 1735:
        -: 1736:		/* For each start condition, make one state for the case when
        -: 1737:		 * we're at the beginning of the line (the '^' operator) and
        -: 1738:		 * one for the case when we're not.
        -: 1739:		 */
        4: 1740:		if ( i % 2 == 1 )
        2: 1741:			nset[numstates] = scset[(i / 2) + 1];
        -: 1742:		else
        4: 1743:			nset[numstates] =
        2: 1744:				mkbranch( scbol[i / 2], scset[i / 2] );
        -: 1745:
        4: 1746:		nset = epsclosure( nset, &numstates, accset, &nacc, &hashval );
        -: 1747:
        4: 1748:		if ( snstods( nset, numstates, accset, nacc, hashval, &ds ) )
        -: 1749:			{
        4: 1750:			numas += nacc;
        4: 1751:			totnst += numstates;
        4: 1752:			++todo_next;
        -: 1753:
        4: 1754:			if ( variable_trailing_context_rules && nacc > 0 )
    #####: 1755:				check_trailing_context( nset, numstates,
        -: 1756:							accset, nacc );
        -: 1757:			}
        -: 1758:		}
        -: 1759:
        1: 1760:	if ( ! fullspd )
        -: 1761:		{
        1: 1762:		if ( ! snstods( nset, 0, accset, 0, 0, &end_of_buffer_state ) )
    #####: 1763:			flexfatal(
        -: 1764:				"could not create unique end-of-buffer state" );
        -: 1765:
        1: 1766:		++numas;
        1: 1767:		++num_start_states;
        1: 1768:		++todo_next;
        -: 1769:		}
        -: 1770:
        8: 1771:	while ( todo_head < todo_next )
        -: 1772:		{
        6: 1773:		targptr = 0;
        6: 1774:		totaltrans = 0;
        -: 1775:
       12: 1776:		for ( i = 1; i <= numecs; ++i )
        6: 1777:			state[i] = 0;
        -: 1778:
        6: 1779:		ds = ++todo_head;
        -: 1780:
        6: 1781:		dset = dss[ds];
        6: 1782:		dsize = dfasiz[ds];
        -: 1783:
        6: 1784:		if ( trace )
    #####: 1785:			fprintf( err, "state # %d:\n", ds );
        -: 1786:
        6: 1787:		sympartition( dset, dsize, symlist, duplist );
        -: 1788:
       12: 1789:		for ( sym = 1; sym <= numecs; ++sym )
        -: 1790:			{
        6: 1791:			if ( symlist[sym] )
        -: 1792:				{
        4: 1793:				symlist[sym] = 0;
        -: 1794:
        4: 1795:				if ( duplist[sym] == NIL )
        -: 1796:					{
        -: 1797:					/* Symbol has unique out-transitions. */
        4: 1798:					numstates = symfollowset( dset, dsize,
        -: 1799:								sym, nset );
        4: 1800:					nset = epsclosure( nset, &numstates,
        -: 1801:						accset, &nacc, &hashval );
        -: 1802:
        4: 1803:					if ( snstods( nset, numstates, accset,
        -: 1804:						nacc, hashval, &newds ) )
        -: 1805:						{
        1: 1806:						totnst = totnst + numstates;
        1: 1807:						++todo_next;
        1: 1808:						numas += nacc;
        -: 1809:
        1: 1810:						if (
        1: 1811:					variable_trailing_context_rules &&
    #####: 1812:							nacc > 0 )
    #####: 1813:							check_trailing_context(
        -: 1814:								nset, numstates,
        -: 1815:								accset, nacc );
        -: 1816:						}
        -: 1817:
        4: 1818:					state[sym] = newds;
        -: 1819:
        4: 1820:					if ( trace )
    #####: 1821:						fprintf( err, "\t%d\t%d\n",
        -: 1822:							sym, newds );
        -: 1823:
        4: 1824:					targfreq[++targptr] = 1;
        4: 1825:					targstate[targptr] = newds;
        4: 1826:					++numuniq;
        -: 1827:					}
        -: 1828:
        -: 1829:				else
        -: 1830:					{
        -: 1831:					/* sym's equivalence class has the same
        -: 1832:					 * transitions as duplist(sym)'s
        -: 1833:					 * equivalence class.
        -: 1834:					 */
    #####: 1835:					targ = state[duplist[sym]];
    #####: 1836:					state[sym] = targ;
        -: 1837:
    #####: 1838:					if ( trace )
    #####: 1839:						fprintf( err, "\t%d\t%d\n",
        -: 1840:							sym, targ );
        -: 1841:
        -: 1842:					/* Update frequency count for
        -: 1843:					 * destination state.
        -: 1844:					 */
        -: 1845:
    #####: 1846:					i = 0;
    #####: 1847:					while ( targstate[++i] != targ )
        -: 1848:						;
        -: 1849:
    #####: 1850:					++targfreq[i];
    #####: 1851:					++numdup;
        -: 1852:					}
        -: 1853:
        4: 1854:				++totaltrans;
        4: 1855:				duplist[sym] = NIL;
        -: 1856:				}
        -: 1857:			}
        -: 1858:
        6: 1859:		numsnpairs = numsnpairs + totaltrans;
        -: 1860:
        6: 1861:		if ( caseins && ! useecs )
        -: 1862:			{
        -: 1863:			register int j;
        -: 1864:
    #####: 1865:			for ( i = 'A', j = 'a'; i <= 'Z'; ++i, ++j )
    #####: 1866:				state[i] = state[j];
        -: 1867:			}
        -: 1868:
        6: 1869:		if ( ds > num_start_states )
        1: 1870:			check_for_backing_up( ds, state );
        -: 1871:
        6: 1872:		if ( nultrans )
        -: 1873:			{
    #####: 1874:			nultrans[ds] = state[NUL_ec];
    #####: 1875:			state[NUL_ec] = 0;	/* remove transition */
        -: 1876:			}
        -: 1877:
        6: 1878:		if ( fulltbl )
        -: 1879:			{
        -: 1880:			/* Supply array's 0-element. */
    #####: 1881:			if ( ds == end_of_buffer_state )
    #####: 1882:				mk2data( -end_of_buffer_state );
        -: 1883:			else
    #####: 1884:				mk2data( end_of_buffer_state );
        -: 1885:
    #####: 1886:			for ( i = 1; i < num_full_table_rows; ++i )
        -: 1887:				/* Jams are marked by negative of state
        -: 1888:				 * number.
        -: 1889:				 */
    #####: 1890:				mk2data( state[i] ? state[i] : -ds );
        -: 1891:
        -: 1892:			/* Force ',' and dataflush() next call to mk2data().*/
    #####: 1893:			datapos = NUMDATAITEMS;
        -: 1894:
        -: 1895:			/* Force extra blank line next dataflush(). */
    #####: 1896:			dataline = NUMDATALINES;
        -: 1897:			}
        -: 1898:
        6: 1899:		else if ( fullspd )
    #####: 1900:			place_state( state, ds, totaltrans );
        -: 1901:
        6: 1902:		else if ( ds == end_of_buffer_state )
        -: 1903:			/* Special case this state to make sure it does what
        -: 1904:			 * it's supposed to, i.e., jam on end-of-buffer.
        -: 1905:			 */
        1: 1906:			stack1( ds, 0, 0, JAMSTATE );
        -: 1907:
        -: 1908:		else /* normal, compressed state */
        -: 1909:			{
        -: 1910:			/* Determine which destination state is the most
        -: 1911:			 * common, and how many transitions to it there are.
        -: 1912:			 */
        -: 1913:
        5: 1914:			comfreq = 0;
        5: 1915:			comstate = 0;
        -: 1916:
        9: 1917:			for ( i = 1; i <= targptr; ++i )
        4: 1918:				if ( targfreq[i] > comfreq )
        -: 1919:					{
        4: 1920:					comfreq = targfreq[i];
        4: 1921:					comstate = targstate[i];
        -: 1922:					}
        -: 1923:
        5: 1924:			bldtbl( state, ds, totaltrans, comstate, comfreq );
        -: 1925:			}
        -: 1926:		}
        -: 1927:
        1: 1928:	if ( fulltbl )
    #####: 1929:		dataend();
        -: 1930:
        1: 1931:	else if ( ! fullspd )
        -: 1932:		{
        1: 1933:		cmptmps();  /* create compressed template entries */
        -: 1934:
        -: 1935:		/* Create tables for all the states with only one
        -: 1936:		 * out-transition.
        -: 1937:		 */
        4: 1938:		while ( onesp > 0 )
        -: 1939:			{
        2: 1940:			mk1tbl( onestate[onesp], onesym[onesp], onenext[onesp],
        -: 1941:			onedef[onesp] );
        2: 1942:			--onesp;
        -: 1943:			}
        -: 1944:
        1: 1945:		mkdeftbl();
        -: 1946:		}
        -: 1947:
        1: 1948:	flex_free( (void *) accset );
        1: 1949:	flex_free( (void *) nset );
        -: 1950:#ifndef	F_HD_2
        -: 1951:
        -: 1952:#else
        -: 1953:	flex_free( (void *) dset );
        -: 1954:#endif
        1: 1955:	}
        -: 1956:
        -: 1957:
        -: 1958:/* snstods - converts a set of ndfa states into a dfa state
        -: 1959: *
        -: 1960: * synopsis
        -: 1961: *    is_new_state = snstods( int sns[numstates], int numstates,
        -: 1962: *				int accset[num_rules+1], int nacc,
        -: 1963: *				int hashval, int *newds_addr );
        -: 1964: *
        -: 1965: * On return, the dfa state number is in newds.
        -: 1966: */
        -: 1967:
        9: 1968:int snstods( sns, numstates, accset, nacc, hashval, newds_addr )
        -: 1969:int sns[], numstates, accset[], nacc, hashval, *newds_addr;
        -: 1970:	{
        9: 1971:	int didsort = 0;
        -: 1972:	register int i, j;
        -: 1973:	int newds, *oldsns;
        -: 1974:
       39: 1975:	for ( i = 1; i <= lastdfa; ++i )
       33: 1976:		if ( hashval == dhash[i] )
        -: 1977:			{
        3: 1978:			if ( numstates == dfasiz[i] )
        -: 1979:				{
        3: 1980:				oldsns = dss[i];
        -: 1981:
        3: 1982:				if ( ! didsort )
        -: 1983:					{
        -: 1984:					/* We sort the states in sns so we
        -: 1985:					 * can compare it to oldsns quickly.
        -: 1986:					 * We use bubble because there probably
        -: 1987:					 * aren't very many states.
        -: 1988:					 */
        3: 1989:					bubble( sns, numstates );
        3: 1990:					didsort = 1;
        -: 1991:					}
        -: 1992:
        6: 1993:				for ( j = 1; j <= numstates; ++j )
        3: 1994:					if ( sns[j] != oldsns[j] )
    #####: 1995:						break;
        -: 1996:
        3: 1997:				if ( j > numstates )
        -: 1998:					{
        3: 1999:					++dfaeql;
        3: 2000:					*newds_addr = i;
        3: 2001:					return 0;
        -: 2002:					}
        -: 2003:
    #####: 2004:				++hshcol;
        -: 2005:				}
        -: 2006:
        -: 2007:			else
    #####: 2008:				++hshsave;
        -: 2009:			}
        -: 2010:
        -: 2011:	/* Make a new dfa. */
        -: 2012:
        6: 2013:	if ( ++lastdfa >= current_max_dfas )
    #####: 2014:		increase_max_dfas();
        -: 2015:
        6: 2016:	newds = lastdfa;
        -: 2017:
        6: 2018:	dss[newds] = allocate_integer_array( numstates + 1 );
        -: 2019:
        -: 2020:	/* If we haven't already sorted the states in sns, we do so now,
        -: 2021:	 * so that future comparisons with it can be made quickly.
        -: 2022:	 */
        -: 2023:
        6: 2024:	if ( ! didsort )
        6: 2025:		bubble( sns, numstates );
        -: 2026:
       15: 2027:	for ( i = 1; i <= numstates; ++i )
        9: 2028:		dss[newds][i] = sns[i];
        -: 2029:
        6: 2030:	dfasiz[newds] = numstates;
        6: 2031:	dhash[newds] = hashval;
        -: 2032:
        6: 2033:	if ( nacc == 0 )
        -: 2034:		{
        5: 2035:		if ( reject )
    #####: 2036:			dfaacc[newds].dfaacc_set = (int *) 0;
        -: 2037:		else
        5: 2038:			dfaacc[newds].dfaacc_state = 0;
        -: 2039:
        5: 2040:		accsiz[newds] = 0;
        -: 2041:		}
        -: 2042:
        1: 2043:	else if ( reject )
        -: 2044:		{
        -: 2045:		/* We sort the accepting set in increasing order so the
        -: 2046:		 * disambiguating rule that the first rule listed is considered
        -: 2047:		 * match in the event of ties will work.  We use a bubble
        -: 2048:		 * sort since the list is probably quite small.
        -: 2049:		 */
        -: 2050:
    #####: 2051:		bubble( accset, nacc );
        -: 2052:
    #####: 2053:		dfaacc[newds].dfaacc_set = allocate_integer_array( nacc + 1 );
        -: 2054:
        -: 2055:		/* Save the accepting set for later */
    #####: 2056:		for ( i = 1; i <= nacc; ++i )
        -: 2057:			{
    #####: 2058:			dfaacc[newds].dfaacc_set[i] = accset[i];
        -: 2059:
    #####: 2060:			if ( accset[i] <= num_rules )
        -: 2061:				/* Who knows, perhaps a REJECT can yield
        -: 2062:				 * this rule.
        -: 2063:				 */
    #####: 2064:				rule_useful[accset[i]] = true;
        -: 2065:			}
        -: 2066:
    #####: 2067:		accsiz[newds] = nacc;
        -: 2068:		}
        -: 2069:
        -: 2070:	else
        -: 2071:		{
        -: 2072:		/* Find lowest numbered rule so the disambiguating rule
        -: 2073:		 * will work.
        -: 2074:		 */
        1: 2075:		j = num_rules + 1;
        -: 2076:
        2: 2077:		for ( i = 1; i <= nacc; ++i )
        1: 2078:			if ( accset[i] < j )
        1: 2079:				j = accset[i];
        -: 2080:
        1: 2081:		dfaacc[newds].dfaacc_state = j;
        -: 2082:
        1: 2083:		if ( j <= num_rules )
        1: 2084:			rule_useful[j] = true;
        -: 2085:		}
        -: 2086:
        6: 2087:	*newds_addr = newds;
        -: 2088:
        6: 2089:	return 1;
        -: 2090:	}
        -: 2091:
        -: 2092:
        -: 2093:/* symfollowset - follow the symbol transitions one step
        -: 2094: *
        -: 2095: * synopsis
        -: 2096: *    numstates = symfollowset( int ds[current_max_dfa_size], int dsize,
        -: 2097: *				int transsym, int nset[current_max_dfa_size] );
        -: 2098: */
        -: 2099:
        4: 2100:int symfollowset( ds, dsize, transsym, nset )
        -: 2101:int ds[], dsize, transsym, nset[];
        -: 2102:	{
        -: 2103:	int ns, tsp, sym, i, j, lenccl, ch, numstates, ccllist;
        -: 2104:
        4: 2105:	numstates = 0;
        -: 2106:
       12: 2107:	for ( i = 1; i <= dsize; ++i )
        -: 2108:		{ /* for each nfa state ns in the state set of ds */
        8: 2109:		ns = ds[i];
        8: 2110:		sym = transchar[ns];
        8: 2111:		tsp = trans1[ns];
        -: 2112:
        8: 2113:		if ( sym < 0 )
        -: 2114:			{ /* it's a character class */
        4: 2115:			sym = -sym;
        4: 2116:			ccllist = cclmap[sym];
        4: 2117:			lenccl = ccllen[sym];
        -: 2118:
        4: 2119:			if ( cclng[sym] )
        -: 2120:				{
        4: 2121:				for ( j = 0; j < lenccl; ++j )
        -: 2122:					{
        -: 2123:					/* Loop through negated character
        -: 2124:					 * class.
        -: 2125:					 */
    #####: 2126:					ch = ccltbl[ccllist + j];
        -: 2127:
    #####: 2128:					if ( ch == 0 )
    #####: 2129:						ch = NUL_ec;
        -: 2130:
    #####: 2131:					if ( ch > transsym )
        -: 2132:						/* Transsym isn't in negated
        -: 2133:						 * ccl.
        -: 2134:						 */
    #####: 2135:						break;
        -: 2136:
    #####: 2137:					else if ( ch == transsym )
    #####: 2138:						/* next 2 */ goto bottom;
        -: 2139:					}
        -: 2140:
        -: 2141:				/* Didn't find transsym in ccl. */
        4: 2142:				nset[++numstates] = tsp;
        -: 2143:				}
        -: 2144:
        -: 2145:			else
    #####: 2146:				for ( j = 0; j < lenccl; ++j )
        -: 2147:					{
    #####: 2148:					ch = ccltbl[ccllist + j];
        -: 2149:
    #####: 2150:					if ( ch == 0 )
    #####: 2151:						ch = NUL_ec;
        -: 2152:
    #####: 2153:					if ( ch > transsym )
    #####: 2154:						break;
    #####: 2155:					else if ( ch == transsym )
        -: 2156:						{
    #####: 2157:						nset[++numstates] = tsp;
    #####: 2158:						break;
        -: 2159:						}
        -: 2160:					}
        -: 2161:			}
        -: 2162:
        4: 2163:		else if ( sym >= 'A' && sym <= 'Z' && caseins )
    #####: 2164:			flexfatal( "consistency check failed in symfollowset" );
        -: 2165:
        4: 2166:		else if ( sym == SYM_EPSILON )
        -: 2167:			{ /* do nothing */
        -: 2168:			}
        -: 2169:
    #####: 2170:		else if ( ABS( ecgroup[sym] ) == transsym )
    #####: 2171:			nset[++numstates] = tsp;
        -: 2172:
        -: 2173:		bottom: ;
        -: 2174:		}
        -: 2175:
        4: 2176:	return numstates;
        -: 2177:	}
        -: 2178:
        -: 2179:
        -: 2180:/* sympartition - partition characters with same out-transitions
        -: 2181: *
        -: 2182: * synopsis
        -: 2183: *    sympartition( int ds[current_max_dfa_size], int numstates,
        -: 2184: *			int symlist[numecs], int duplist[numecs] );
        -: 2185: */
        -: 2186:
        6: 2187:void sympartition( ds, numstates, symlist, duplist )
        -: 2188:int ds[], numstates;
        -: 2189:int symlist[], duplist[];
        -: 2190:	{
        -: 2191:	int tch, i, j, k, ns, dupfwd[CSIZE + 1], lenccl, cclp, ich;
        -: 2192:
        -: 2193:	/* Partitioning is done by creating equivalence classes for those
        -: 2194:	 * characters which have out-transitions from the given state.  Thus
        -: 2195:	 * we are really creating equivalence classes of equivalence classes.
        -: 2196:	 */
        -: 2197:
       12: 2198:	for ( i = 1; i <= numecs; ++i )
        -: 2199:		{ /* initialize equivalence class list */
        6: 2200:		duplist[i] = i - 1;
        6: 2201:		dupfwd[i] = i + 1;
        -: 2202:		}
        -: 2203:
        6: 2204:	duplist[1] = NIL;
        6: 2205:	dupfwd[numecs] = NIL;
        -: 2206:
       15: 2207:	for ( i = 1; i <= numstates; ++i )
        -: 2208:		{
        9: 2209:		ns = ds[i];
        9: 2210:		tch = transchar[ns];
        -: 2211:
        9: 2212:		if ( tch != SYM_EPSILON )
        -: 2213:			{
        4: 2214:			if ( tch < -lastccl || tch >= csize )
        -: 2215:				{
    #####: 2216:				flexfatal(
        -: 2217:			"bad transition character detected in sympartition()" );
        -: 2218:				}
        -: 2219:
        4: 2220:			if ( tch >= 0 )
        -: 2221:				{ /* character transition */
    #####: 2222:				int ec = ecgroup[tch];
        -: 2223:
    #####: 2224:				mkechar( ec, dupfwd, duplist );
    #####: 2225:				symlist[ec] = 1;
        -: 2226:				}
        -: 2227:
        -: 2228:			else
        -: 2229:				{ /* character class */
        4: 2230:				tch = -tch;
        -: 2231:
        4: 2232:				lenccl = ccllen[tch];
        4: 2233:				cclp = cclmap[tch];
        4: 2234:				mkeccl( ccltbl + cclp, lenccl, dupfwd,
        -: 2235:					duplist, numecs, NUL_ec );
        -: 2236:
        4: 2237:				if ( cclng[tch] )
        -: 2238:					{
        4: 2239:					j = 0;
        -: 2240:
        4: 2241:					for ( k = 0; k < lenccl; ++k )
        -: 2242:						{
    #####: 2243:						ich = ccltbl[cclp + k];
        -: 2244:
    #####: 2245:						if ( ich == 0 )
    #####: 2246:							ich = NUL_ec;
        -: 2247:
    #####: 2248:						for ( ++j; j < ich; ++j )
    #####: 2249:							symlist[j] = 1;
        -: 2250:						}
        -: 2251:
        8: 2252:					for ( ++j; j <= numecs; ++j )
        4: 2253:						symlist[j] = 1;
        -: 2254:					}
        -: 2255:
        -: 2256:				else
    #####: 2257:					for ( k = 0; k < lenccl; ++k )
        -: 2258:						{
    #####: 2259:						ich = ccltbl[cclp + k];
        -: 2260:
    #####: 2261:						if ( ich == 0 )
    #####: 2262:							ich = NUL_ec;
        -: 2263:
    #####: 2264:						symlist[ich] = 1;
        -: 2265:						}
        -: 2266:				}
        -: 2267:			}
        -: 2268:		}
        6: 2269:	}
        -: 2270:/* ecs - equivalence class routines */
        -: 2271:
        -: 2272:/*-
        -: 2273: * Copyright (c) 1990 The Regents of the University of California.
        -: 2274: * All rights reserved.
        -: 2275: *
        -: 2276: * This code is derived from software contributed to Berkeley by
        -: 2277: * Vern Paxson.
        -: 2278: * 
        -: 2279: * The United States Government has rights in this work pursuant
        -: 2280: * to contract no. DE-AC03-76SF00098 between the United States
        -: 2281: * Department of Energy and the University of California.
        -: 2282: *
        -: 2283: * Redistribution and use in source and binary forms are permitted provided
        -: 2284: * that: (1) source distributions retain this entire copyright notice and
        -: 2285: * comment, and (2) distributions including binaries display the following
        -: 2286: * acknowledgement:  ``This product includes software developed by the
        -: 2287: * University of California, Berkeley and its contributors'' in the
        -: 2288: * documentation or other materials provided with the distribution and in
        -: 2289: * all advertising materials mentioning features or use of this software.
        -: 2290: * Neither the name of the University nor the names of its contributors may
        -: 2291: * be used to endorse or promote products derived from this software without
        -: 2292: * specific prior written permission.
        -: 2293: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 2294: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 2295: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 2296: */
        -: 2297:
        -: 2298:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 2299:
        -: 2300:
        -: 2301:/* ccl2ecl - convert character classes to set of equivalence classes */
        -: 2302:
        1: 2303:void ccl2ecl()
        -: 2304:	{
        -: 2305:	int i, ich, newlen, cclp, ccls, cclmec;
        -: 2306:
        2: 2307:	for ( i = 1; i <= lastccl; ++i )
        -: 2308:		{
        -: 2309:		/* We loop through each character class, and for each character
        -: 2310:		 * in the class, add the character's equivalence class to the
        -: 2311:		 * new "character" class we are creating.  Thus when we are all
        -: 2312:		 * done, character classes will really consist of collections
        -: 2313:		 * of equivalence classes
        -: 2314:		 */
        -: 2315:
        1: 2316:		newlen = 0;
        1: 2317:		cclp = cclmap[i];
        -: 2318:
        1: 2319:		for ( ccls = 0; ccls < ccllen[i]; ++ccls )
        -: 2320:			{
    #####: 2321:			ich = ccltbl[cclp + ccls];
    #####: 2322:			cclmec = ecgroup[ich];
        -: 2323:
    #####: 2324:			if ( cclmec > 0 )
        -: 2325:				{
    #####: 2326:				ccltbl[cclp + newlen] = cclmec;
    #####: 2327:				++newlen;
        -: 2328:				}
        -: 2329:			}
        -: 2330:
        1: 2331:		ccllen[i] = newlen;
        -: 2332:		}
        1: 2333:	}
        -: 2334:
        -: 2335:
        -: 2336:/* cre8ecs - associate equivalence class numbers with class members
        -: 2337: *
        -: 2338: * fwd is the forward linked-list of equivalence class members.  bck
        -: 2339: * is the backward linked-list, and num is the number of class members.
        -: 2340: *
        -: 2341: * Returned is the number of classes.
        -: 2342: */
        -: 2343:
        2: 2344:int cre8ecs( fwd, bck, num )
        -: 2345:int fwd[], bck[], num;
        -: 2346:	{
        -: 2347:	int i, j, numcl;
        -: 2348:
        2: 2349:	numcl = 0;
        -: 2350:
        -: 2351:	/* Create equivalence class numbers.  From now on, ABS( bck(x) )
        -: 2352:	 * is the equivalence class number for object x.  If bck(x)
        -: 2353:	 * is positive, then x is the representative of its equivalence
        -: 2354:	 * class.
        -: 2355:	 */
      259: 2356:	for ( i = 1; i <= num; ++i )
      257: 2357:		if ( bck[i] == NIL )
        -: 2358:			{
        2: 2359:			bck[i] = ++numcl;
      257: 2360:			for ( j = fwd[i]; j != NIL; j = fwd[j] )
      255: 2361:				bck[j] = -numcl;
        -: 2362:			}
        -: 2363:
        2: 2364:	return numcl;
        -: 2365:	}
        -: 2366:
        -: 2367:
        -: 2368:/* mkeccl - update equivalence classes based on character class xtions
        -: 2369: *
        -: 2370: * synopsis
        -: 2371: *    Char ccls[];
        -: 2372: *    int lenccl, fwd[llsiz], bck[llsiz], llsiz, NUL_mapping;
        -: 2373: *    void mkeccl( Char ccls[], int lenccl, int fwd[llsiz], int bck[llsiz],
        -: 2374: *			int llsiz, int NUL_mapping );
        -: 2375: *
        -: 2376: * ccls contains the elements of the character class, lenccl is the
        -: 2377: * number of elements in the ccl, fwd is the forward link-list of equivalent
        -: 2378: * characters, bck is the backward link-list, and llsiz size of the link-list.
        -: 2379: *
        -: 2380: * NUL_mapping is the value which NUL (0) should be mapped to.
        -: 2381: */
        -: 2382:
        5: 2383:void mkeccl( ccls, lenccl, fwd, bck, llsiz, NUL_mapping )
        -: 2384:Char ccls[];
        -: 2385:int lenccl, fwd[], bck[], llsiz, NUL_mapping;
        -: 2386:	{
        -: 2387:	int cclp, oldec, newec;
        -: 2388:	int cclm, i, j;
        -: 2389:	static unsigned char cclflags[CSIZE];	/* initialized to all '\0' */
        -: 2390:
        -: 2391:	/* Note that it doesn't matter whether or not the character class is
        -: 2392:	 * negated.  The same results will be obtained in either case.
        -: 2393:	 */
        -: 2394:
        5: 2395:	cclp = 0;
        -: 2396:
       11: 2397:	while ( cclp < lenccl )
        -: 2398:		{
        1: 2399:		cclm = ccls[cclp];
        -: 2400:
        1: 2401:		if ( NUL_mapping && cclm == 0 )
    #####: 2402:			cclm = NUL_mapping;
        -: 2403:
        1: 2404:		oldec = bck[cclm];
        1: 2405:		newec = cclm;
        -: 2406:
        1: 2407:		j = cclp + 1;
        -: 2408:
        1: 2409:		for ( i = fwd[cclm]; i != NIL && i <= llsiz; i = fwd[i] )
        -: 2410:			{ /* look for the symbol in the character class */
    #####: 2411:			for ( ; j < lenccl; ++j )
        -: 2412:				{
        -: 2413:				register int ccl_char;
        -: 2414:
    #####: 2415:				if ( NUL_mapping && ccls[j] == 0 )
    #####: 2416:					ccl_char = NUL_mapping;
        -: 2417:				else
    #####: 2418:					ccl_char = ccls[j];
        -: 2419:
    #####: 2420:				if ( ccl_char > i )
    #####: 2421:					break;
        -: 2422:
    #####: 2423:				if ( ccl_char == i && ! cclflags[j] )
        -: 2424:					{
        -: 2425:					/* We found an old companion of cclm
        -: 2426:					 * in the ccl.  Link it into the new
        -: 2427:					 * equivalence class and flag it as
        -: 2428:					 * having been processed.
        -: 2429:					 */
        -: 2430:
    #####: 2431:					bck[i] = newec;
    #####: 2432:					fwd[newec] = i;
    #####: 2433:					newec = i;
        -: 2434:					/* Set flag so we don't reprocess. */
    #####: 2435:					cclflags[j] = 1;
        -: 2436:
        -: 2437:					/* Get next equivalence class member. */
        -: 2438:					/* continue 2 */
    #####: 2439:					goto next_pt;
        -: 2440:					}
        -: 2441:				}
        -: 2442:
        -: 2443:			/* Symbol isn't in character class.  Put it in the old
        -: 2444:			 * equivalence class.
        -: 2445:			 */
        -: 2446:
    #####: 2447:			bck[i] = oldec;
        -: 2448:
    #####: 2449:			if ( oldec != NIL )
    #####: 2450:				fwd[oldec] = i;
        -: 2451:
    #####: 2452:			oldec = i;
        -: 2453:
        -: 2454:			next_pt: ;
        -: 2455:			}
        -: 2456:
        1: 2457:		if ( bck[cclm] != NIL || oldec != bck[cclm] )
        -: 2458:			{
    #####: 2459:			bck[cclm] = NIL;
    #####: 2460:			fwd[oldec] = NIL;
        -: 2461:			}
        -: 2462:
        1: 2463:		fwd[newec] = NIL;
        -: 2464:
        -: 2465:		/* Find next ccl member to process. */
        -: 2466:
        1: 2467:		for ( ++cclp; cclflags[cclp] && cclp < lenccl; ++cclp )
        -: 2468:			{
        -: 2469:			/* Reset "doesn't need processing" flag. */
    #####: 2470:			cclflags[cclp] = 0;
        -: 2471:			}
        -: 2472:		}
        5: 2473:	}
        -: 2474:
        -: 2475:
        -: 2476:/* mkechar - create equivalence class for single character */
        -: 2477:
    #####: 2478:void mkechar( tch, fwd, bck )
        -: 2479:int tch, fwd[], bck[];
        -: 2480:	{
        -: 2481:	/* If until now the character has been a proper subset of
        -: 2482:	 * an equivalence class, break it away to create a new ec
        -: 2483:	 */
        -: 2484:
    #####: 2485:	if ( fwd[tch] != NIL )
    #####: 2486:		bck[fwd[tch]] = bck[tch];
        -: 2487:
    #####: 2488:	if ( bck[tch] != NIL )
    #####: 2489:		fwd[bck[tch]] = fwd[tch];
        -: 2490:
    #####: 2491:	fwd[tch] = NIL;
    #####: 2492:	bck[tch] = NIL;
    #####: 2493:	}
        -: 2494:/* gen - actual generation (writing) of flex scanners */
        -: 2495:
        -: 2496:/*-
        -: 2497: * Copyright (c) 1990 The Regents of the University of California.
        -: 2498: * All rights reserved.
        -: 2499: *
        -: 2500: * This code is derived from software contributed to Berkeley by
        -: 2501: * Vern Paxson.
        -: 2502: * 
        -: 2503: * The United States Government has rights in this work pursuant
        -: 2504: * to contract no. DE-AC03-76SF00098 between the United States
        -: 2505: * Department of Energy and the University of California.
        -: 2506: *
        -: 2507: * Redistribution and use in source and binary forms are permitted provided
        -: 2508: * that: (1) source distributions retain this entire copyright notice and
        -: 2509: * comment, and (2) distributions including binaries display the following
        -: 2510: * acknowledgement:  ``This product includes software developed by the
        -: 2511: * University of California, Berkeley and its contributors'' in the
        -: 2512: * documentation or other materials provided with the distribution and in
        -: 2513: * all advertising materials mentioning features or use of this software.
        -: 2514: * Neither the name of the University nor the names of its contributors may
        -: 2515: * be used to endorse or promote products derived from this software without
        -: 2516: * specific prior written permission.
        -: 2517: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 2518: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 2519: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 2520: */
        -: 2521:
        -: 2522:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 2523:
        -: 2524:
        -: 2525:
        -: 2526:/* declare functions that have forward references */
        -: 2527:
        -: 2528:void gen_next_state PROTO((int));
        -: 2529:void genecs PROTO((void));
        -: 2530:void indent_put2s PROTO((char [], char []));
        -: 2531:void indent_puts PROTO((char []));
        -: 2532:
        -: 2533:
        -: 2534:static int indent_level = 0; /* each level is 8 spaces */
        -: 2535:
        -: 2536:#define indent_up() (++indent_level)
        -: 2537:#define indent_down() (--indent_level)
        -: 2538:#define set_indent(indent_val) indent_level = indent_val
        -: 2539:
        -: 2540:/* Almost everything is done in terms of arrays starting at 1, so provide
        -: 2541: * a null entry for the zero element of all C arrays.  (The exception
        -: 2542: * to this is that the fast table representation generally uses the
        -: 2543: * 0 elements of its arrays, too.)
        -: 2544: */
        -: 2545:static char C_int_decl[] = "static const int %s[%d] =\n    {   0,\n";
        -: 2546:static char C_short_decl[] = "static const short int %s[%d] =\n    {   0,\n";
        -: 2547:static char C_long_decl[] = "static const long int %s[%d] =\n    {   0,\n";
        -: 2548:static char C_state_decl[] =
        -: 2549:	"static const yy_state_type %s[%d] =\n    {   0,\n";
        -: 2550:
        -: 2551:
        -: 2552:/* Indent to the current level. */
        -: 2553:
       61: 2554:void do_indent()
        -: 2555:	{
       61: 2556:	register int i = indent_level * 8;
        -: 2557:
      276: 2558:	while ( i >= 8 )
        -: 2559:		{
      154: 2560:		putchar( '\t' );
      154: 2561:		i -= 8;
        -: 2562:		}
        -: 2563:
      122: 2564:	while ( i > 0 )
        -: 2565:		{
    #####: 2566:		putchar( ' ' );
    #####: 2567:		--i;
        -: 2568:		}
       61: 2569:	}
        -: 2570:
        -: 2571:
        -: 2572:/* Generate the code to keep backing-up information. */
        -: 2573:
        3: 2574:void gen_backing_up()
        -: 2575:	{
        3: 2576:	if ( reject || num_backing_up == 0 )
    #####: 2577:		return;
        -: 2578:
        3: 2579:	if ( fullspd )
    #####: 2580:		indent_puts( "if ( yy_current_state[-1].yy_nxt )" );
        -: 2581:	else
        3: 2582:		indent_puts( "if ( yy_accept[yy_current_state] )" );
        -: 2583:
        3: 2584:	indent_up();
        3: 2585:	indent_puts( "{" );
        3: 2586:	indent_puts( "yy_last_accepting_state = yy_current_state;" );
        3: 2587:	indent_puts( "yy_last_accepting_cpos = yy_cp;" );
        3: 2588:	indent_puts( "}" );
        3: 2589:	indent_down();
        -: 2590:	}
        -: 2591:
        -: 2592:
        -: 2593:/* Generate the code to perform the backing up. */
        -: 2594:
        1: 2595:void gen_bu_action()
        -: 2596:	{
        1: 2597:	if ( reject || num_backing_up == 0 )
    #####: 2598:		return;
        -: 2599:
        1: 2600:	set_indent( 3 );
        -: 2601:
        1: 2602:	indent_puts( "case 0: /* must back up */" );
        1: 2603:	indent_puts( "/* undo the effects of YY_DO_BEFORE_ACTION */" );
        1: 2604:	indent_puts( "*yy_cp = yy_hold_char;" );
        -: 2605:
        1: 2606:	if ( fullspd || fulltbl )
    #####: 2607:		indent_puts( "yy_cp = yy_last_accepting_cpos + 1;" );
        -: 2608:	else
        -: 2609:		/* Backing-up info for compressed tables is taken \after/
        -: 2610:		 * yy_cp has been incremented for the next state.
        -: 2611:		 */
        1: 2612:		indent_puts( "yy_cp = yy_last_accepting_cpos;" );
        -: 2613:
        1: 2614:	indent_puts( "yy_current_state = yy_last_accepting_state;" );
        1: 2615:	indent_puts( "goto yy_find_action;" );
        1: 2616:	putchar( '\n' );
        -: 2617:
        1: 2618:	set_indent( 0 );
        -: 2619:	}
        -: 2620:
        -: 2621:
        -: 2622:/* genctbl - generates full speed compressed transition table */
        -: 2623:
    #####: 2624:void genctbl()
        -: 2625:	{
        -: 2626:	register int i;
    #####: 2627:	int end_of_buffer_action = num_rules + 1;
        -: 2628:
        -: 2629:	/* Table of verify for transition and offset to next state. */
    #####: 2630:	printf( "static const struct yy_trans_info yy_transition[%d] =\n",
    #####: 2631:		tblend + numecs + 1 );
    #####: 2632:	printf( "    {\n" );
        -: 2633:
        -: 2634:	/* We want the transition to be represented as the offset to the
        -: 2635:	 * next state, not the actual state number, which is what it currently
        -: 2636:	 * is.  The offset is base[nxt[i]] - (base of current state)].  That's
        -: 2637:	 * just the difference between the starting points of the two involved
        -: 2638:	 * states (to - from).
        -: 2639:	 *
        -: 2640:	 * First, though, we need to find some way to put in our end-of-buffer
        -: 2641:	 * flags and states.  We do this by making a state with absolutely no
        -: 2642:	 * transitions.  We put it at the end of the table.
        -: 2643:	 */
        -: 2644:
        -: 2645:	/* We need to have room in nxt/chk for two more slots: One for the
        -: 2646:	 * action and one for the end-of-buffer transition.  We now *assume*
        -: 2647:	 * that we're guaranteed the only character we'll try to index this
        -: 2648:	 * nxt/chk pair with is EOB, i.e., 0, so we don't have to make sure
        -: 2649:	 * there's room for jam entries for other characters.
        -: 2650:	 */
        -: 2651:
    #####: 2652:	while ( tblend + 2 >= current_max_xpairs )
    #####: 2653:		expand_nxt_chk();
        -: 2654:
    #####: 2655:	while ( lastdfa + 1 >= current_max_dfas )
    #####: 2656:		increase_max_dfas();
        -: 2657:
    #####: 2658:	base[lastdfa + 1] = tblend + 2;
    #####: 2659:	nxt[tblend + 1] = end_of_buffer_action;
    #####: 2660:	chk[tblend + 1] = numecs + 1;
    #####: 2661:	chk[tblend + 2] = 1; /* anything but EOB */
        -: 2662:
        -: 2663:	/* So that "make test" won't show arb. differences. */
    #####: 2664:	nxt[tblend + 2] = 0;
        -: 2665:
        -: 2666:	/* Make sure every state has an end-of-buffer transition and an
        -: 2667:	 * action #.
        -: 2668:	 */
    #####: 2669:	for ( i = 0; i <= lastdfa; ++i )
        -: 2670:		{
    #####: 2671:		int anum = dfaacc[i].dfaacc_state;
        -: 2672:#ifndef	F_HD_3
    #####: 2673:		int offset = base[i];
        -: 2674:#else
        -: 2675:		int offset = base[i+1]; 
        -: 2676:#endif
        -: 2677:
        -: 2678:#ifndef F_AA_2
    #####: 2679:		chk[offset] = EOB_POSITION;
        -: 2680:#else
        -: 2681:		chk[offset - 1] = EOB_POSITION;
        -: 2682:#endif
    #####: 2683:		chk[offset - 1] = ACTION_POSITION;
    #####: 2684:		nxt[offset - 1] = anum;	/* action number */
        -: 2685:		}
        -: 2686:
    #####: 2687:	for ( i = 0; i <= tblend; ++i )
        -: 2688:		{
    #####: 2689:		if ( chk[i] == EOB_POSITION )
    #####: 2690:			transition_struct_out( 0, base[lastdfa + 1] - i );
        -: 2691:
    #####: 2692:		else if ( chk[i] == ACTION_POSITION )
    #####: 2693:			transition_struct_out( 0, nxt[i] );
        -: 2694:
    #####: 2695:		else if ( chk[i] > numecs || chk[i] == 0 )
    #####: 2696:			transition_struct_out( 0, 0 );	/* unused slot */
        -: 2697:
        -: 2698:		else	/* verify, transition */
    #####: 2699:			transition_struct_out( chk[i],
    #####: 2700:						base[nxt[i]] - (i - chk[i]) );
        -: 2701:		}
        -: 2702:
        -: 2703:
        -: 2704:	/* Here's the final, end-of-buffer state. */
    #####: 2705:	transition_struct_out( chk[tblend + 1], nxt[tblend + 1] );
    #####: 2706:	transition_struct_out( chk[tblend + 2], nxt[tblend + 2] );
        -: 2707:
    #####: 2708:	printf( "    };\n" );
    #####: 2709:	printf( "\n" );
        -: 2710:
        -: 2711:	/* Table of pointers to start states. */
    #####: 2712:	printf(
        -: 2713:	"static const struct yy_trans_info *yy_start_state_list[%d] =\n",
    #####: 2714:		lastsc * 2 + 1 );
    #####: 2715:	printf( "    {\n" );	/* } so vi doesn't get confused */
        -: 2716:
    #####: 2717:	for ( i = 0; i <= lastsc * 2; ++i )
    #####: 2718:		printf( "    &yy_transition[%d],\n", base[i] );
        -: 2719:
    #####: 2720:	dataend();
        -: 2721:
    #####: 2722:	if ( useecs )
    #####: 2723:		genecs();
    #####: 2724:	}
        -: 2725:
        -: 2726:
        -: 2727:/* Generate equivalence-class tables. */
        -: 2728:
        1: 2729:void genecs()
        -: 2730:	{
        -: 2731:	Char clower();
        -: 2732:	register int i, j;
        -: 2733:	int numrows;
        -: 2734:
        1: 2735:	printf( C_int_decl, "yy_ec", csize );
        -: 2736:
      256: 2737:	for ( i = 1; i < csize; ++i )
        -: 2738:		{
      255: 2739:		if ( caseins && (i >= 'A') && (i <= 'Z') )
    #####: 2740:			ecgroup[i] = ecgroup[clower( i )];
        -: 2741:
      255: 2742:		ecgroup[i] = ABS( ecgroup[i] );
      255: 2743:		mkdata( ecgroup[i] );
        -: 2744:		}
        -: 2745:
        1: 2746:	dataend();
        -: 2747:
        1: 2748:	if ( trace )
        -: 2749:		{
    #####: 2750:		fputs( "\n\nEquivalence Classes:\n\n", err );
        -: 2751:
    #####: 2752:		numrows = csize / 8;
        -: 2753:
    #####: 2754:		for ( j = 0; j < numrows; ++j )
        -: 2755:			{
    #####: 2756:			for ( i = j; i < csize; i = i + numrows )
        -: 2757:				{
    #####: 2758:				fprintf( err, "%4s = %-2d",
        -: 2759:					readable_form( i ), ecgroup[i] );
        -: 2760:
    #####: 2761:				putc( ' ', err );
        -: 2762:				}
        -: 2763:
    #####: 2764:			putc( '\n', err );
        -: 2765:			}
        -: 2766:		}
        1: 2767:	}
        -: 2768:
        -: 2769:
        -: 2770:/* Generate the code to find the action number. */
        -: 2771:
        1: 2772:void gen_find_action()
        -: 2773:	{
        1: 2774:	if ( fullspd )
    #####: 2775:		indent_puts( "yy_act = yy_current_state[-1].yy_nxt;" );
        -: 2776:
        1: 2777:	else if ( fulltbl )
    #####: 2778:		indent_puts( "yy_act = yy_accept[yy_current_state];" );
        -: 2779:
        1: 2780:	else if ( reject )
        -: 2781:		{
    #####: 2782:		indent_puts( "yy_current_state = *--yy_state_ptr;" );
    #####: 2783:		indent_puts( "yy_lp = yy_accept[yy_current_state];" );
        -: 2784:
    #####: 2785:		puts(
        -: 2786:		"find_rule: /* we branch to this label when backing up */" );
        -: 2787:
    #####: 2788:		indent_puts(
        -: 2789:		"for ( ; ; ) /* until we find what rule we matched */" );
        -: 2790:
    #####: 2791:		indent_up();
        -: 2792:
    #####: 2793:		indent_puts( "{" );
        -: 2794:
    #####: 2795:		indent_puts(
        -: 2796:		"if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )" );
    #####: 2797:		indent_up();
    #####: 2798:		indent_puts( "{" );
    #####: 2799:		indent_puts( "yy_act = yy_acclist[yy_lp];" );
        -: 2800:
    #####: 2801:		if ( variable_trailing_context_rules )
        -: 2802:			{
    #####: 2803:			indent_puts( "if ( yy_act & YY_TRAILING_HEAD_MASK ||" );
    #####: 2804:			indent_puts( "     yy_looking_for_trail_begin )" );
    #####: 2805:			indent_up();
    #####: 2806:			indent_puts( "{" );
        -: 2807:
    #####: 2808:			indent_puts(
        -: 2809:				"if ( yy_act == yy_looking_for_trail_begin )" );
    #####: 2810:			indent_up();
    #####: 2811:			indent_puts( "{" );
    #####: 2812:			indent_puts( "yy_looking_for_trail_begin = 0;" );
    #####: 2813:			indent_puts( "yy_act &= ~YY_TRAILING_HEAD_MASK;" );
    #####: 2814:			indent_puts( "break;" );
    #####: 2815:			indent_puts( "}" );
    #####: 2816:			indent_down();
        -: 2817:
    #####: 2818:			indent_puts( "}" );
    #####: 2819:			indent_down();
        -: 2820:
    #####: 2821:			indent_puts( "else if ( yy_act & YY_TRAILING_MASK )" );
    #####: 2822:			indent_up();
    #####: 2823:			indent_puts( "{" );
    #####: 2824:			indent_puts(
        -: 2825:		"yy_looking_for_trail_begin = yy_act & ~YY_TRAILING_MASK;" );
    #####: 2826:			indent_puts(
        -: 2827:		"yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;" );
        -: 2828:
    #####: 2829:			if ( real_reject )
        -: 2830:				{
        -: 2831:				/* Remember matched text in case we back up
        -: 2832:				 * due to REJECT.
        -: 2833:				 */
    #####: 2834:				indent_puts( "yy_full_match = yy_cp;" );
    #####: 2835:				indent_puts( "yy_full_state = yy_state_ptr;" );
    #####: 2836:				indent_puts( "yy_full_lp = yy_lp;" );
        -: 2837:				}
        -: 2838:
    #####: 2839:			indent_puts( "}" );
    #####: 2840:			indent_down();
        -: 2841:
    #####: 2842:			indent_puts( "else" );
    #####: 2843:			indent_up();
    #####: 2844:			indent_puts( "{" );
    #####: 2845:			indent_puts( "yy_full_match = yy_cp;" );
    #####: 2846:			indent_puts( "yy_full_state = yy_state_ptr;" );
    #####: 2847:			indent_puts( "yy_full_lp = yy_lp;" );
    #####: 2848:			indent_puts( "break;" );
    #####: 2849:			indent_puts( "}" );
    #####: 2850:			indent_down();
        -: 2851:
    #####: 2852:			indent_puts( "++yy_lp;" );
    #####: 2853:			indent_puts( "goto find_rule;" );
        -: 2854:			}
        -: 2855:
        -: 2856:		else
        -: 2857:		{
        -: 2858:		/* Remember matched text in case we back up due to trailing
        -: 2859:		 * context plus REJECT.
        -: 2860:		 */
    #####: 2861:		indent_up();
    #####: 2862:		indent_puts( "{" );
    #####: 2863:		indent_puts( "yy_full_match = yy_cp;" );
    #####: 2864:		indent_puts( "break;" );
    #####: 2865:		indent_puts( "}" );
    #####: 2866:		indent_down();
        -: 2867:		}
        -: 2868:
    #####: 2869:		indent_puts( "}" );
    #####: 2870:		indent_down();
        -: 2871:
    #####: 2872:		indent_puts( "--yy_cp;" );
        -: 2873:
        -: 2874:		/* We could consolidate the following two lines with those at
        -: 2875:		 * the beginning, but at the cost of complaints that we're
        -: 2876:		 * branching inside a loop.
        -: 2877:		 */
    #####: 2878:		indent_puts( "yy_current_state = *--yy_state_ptr;" );
    #####: 2879:		indent_puts( "yy_lp = yy_accept[yy_current_state];" );
        -: 2880:
    #####: 2881:		indent_puts( "}" );
        -: 2882:
    #####: 2883:		indent_down();
        -: 2884:		}
        -: 2885:
        -: 2886:	else
        -: 2887:		/* compressed */
        1: 2888:		indent_puts( "yy_act = yy_accept[yy_current_state];" );
        1: 2889:	}
        -: 2890:
        -: 2891:
        -: 2892:/* genftbl - generates full transition table */
        -: 2893:
    #####: 2894:void genftbl()
        -: 2895:	{
        -: 2896:	register int i;
    #####: 2897:	int end_of_buffer_action = num_rules + 1;
        -: 2898:
    #####: 2899:	printf( long_align ? C_long_decl : C_short_decl,
        -: 2900:		"yy_accept", lastdfa + 1 );
        -: 2901:
    #####: 2902:	dfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;
        -: 2903:
    #####: 2904:	for ( i = 1; i <= lastdfa; ++i )
        -: 2905:		{
    #####: 2906:		register int anum = dfaacc[i].dfaacc_state;
        -: 2907:
    #####: 2908:		mkdata( anum );
        -: 2909:
    #####: 2910:		if ( trace && anum )
    #####: 2911:			fprintf( err, "state # %d accepts: [%d]\n",
        -: 2912:				i, anum );
        -: 2913:		}
        -: 2914:
    #####: 2915:	dataend();
        -: 2916:
    #####: 2917:	if ( useecs )
    #####: 2918:		genecs();
        -: 2919:
        -: 2920:	/* Don't have to dump the actual full table entries - they were
        -: 2921:	 * created on-the-fly.
        -: 2922:	 */
    #####: 2923:	}
        -: 2924:
        -: 2925:
        -: 2926:/* Generate the code to find the next compressed-table state. */
        -: 2927:
        3: 2928:void gen_next_compressed_state( char_map )
        -: 2929:char *char_map;
        -: 2930:	{
        3: 2931:	indent_put2s( "register YY_CHAR yy_c = %s;", char_map );
        -: 2932:
        -: 2933:	/* Save the backing-up info \before/ computing the next state
        -: 2934:	 * because we always compute one more state than needed - we
        -: 2935:	 * always proceed until we reach a jam state
        -: 2936:	 */
        3: 2937:	gen_backing_up();
        -: 2938:
        3: 2939:	indent_puts(
        -: 2940:"while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )" );
        3: 2941:	indent_up();
        3: 2942:	indent_puts( "{" );
        3: 2943:	indent_puts( "yy_current_state = (int) yy_def[yy_current_state];" );
        -: 2944:
        3: 2945:	if ( usemecs )
        -: 2946:		{
        -: 2947:		/* We've arrange it so that templates are never chained
        -: 2948:		 * to one another.  This means we can afford to make a
        -: 2949:		 * very simple test to see if we need to convert to
        -: 2950:		 * yy_c's meta-equivalence class without worrying
        -: 2951:		 * about erroneously looking up the meta-equivalence
        -: 2952:		 * class twice
        -: 2953:		 */
        3: 2954:		do_indent();
        -: 2955:
        -: 2956:		/* lastdfa + 2 is the beginning of the templates */
        3: 2957:		printf( "if ( yy_current_state >= %d )\n", lastdfa + 2 );
        -: 2958:
        3: 2959:		indent_up();
        3: 2960:		indent_puts( "yy_c = yy_meta[(unsigned int) yy_c];" );
        3: 2961:		indent_down();
        -: 2962:		}
        -: 2963:
        3: 2964:	indent_puts( "}" );
        3: 2965:	indent_down();
        -: 2966:
        3: 2967:	indent_puts(
        -: 2968:"yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];" );
        3: 2969:	}
        -: 2970:
        -: 2971:
        -: 2972:/* Generate the code to find the next match. */
        -: 2973:
        1: 2974:void gen_next_match()
        -: 2975:	{
        -: 2976:	/* NOTE - changes in here should be reflected in gen_next_state() and
        -: 2977:	 * gen_NUL_trans().
        -: 2978:	 */
        -: 2979:
        2: 2980:	char *char_map = useecs ?
        1: 2981:				"yy_ec[YY_SC_TO_UI(*yy_cp)]" :
        -: 2982:#ifndef	F_HD_4
        -: 2983:				"YY_SC_TO_UI(*yy_cp)";
        -: 2984:#else
        -: 2985:				"";
        -: 2986:#endif
        -: 2987:
        2: 2988:	char *char_map_2 = useecs ?
        1: 2989:				"yy_ec[YY_SC_TO_UI(*++yy_cp)]" :
        -: 2990:				"YY_SC_TO_UI(*++yy_cp)";
        1: 2991:	if ( fulltbl )
        -: 2992:		{
    #####: 2993:		indent_put2s(
        -: 2994:	"while ( (yy_current_state = yy_nxt[yy_current_state][%s]) > 0 )",
        -: 2995:				char_map );
        -: 2996:
    #####: 2997:		indent_up();
        -: 2998:
    #####: 2999:		if ( num_backing_up > 0 )
        -: 3000:			{
    #####: 3001:			indent_puts( "{" );	/* } for vi */
    #####: 3002:			gen_backing_up();
    #####: 3003:			putchar( '\n' );
        -: 3004:			}
        -: 3005:
    #####: 3006:		indent_puts( "++yy_cp;" );
        -: 3007:
    #####: 3008:		if ( num_backing_up > 0 )
        -: 3009:			/* { for vi */
    #####: 3010:			indent_puts( "}" );
        -: 3011:
    #####: 3012:		indent_down();
        -: 3013:
    #####: 3014:		putchar( '\n' );
    #####: 3015:		indent_puts( "yy_current_state = -yy_current_state;" );
        -: 3016:		}
        -: 3017:
        1: 3018:	else if ( fullspd )
        -: 3019:		{
    #####: 3020:		indent_puts( "{" );	/* } for vi */
    #####: 3021:		indent_puts(
        -: 3022:		"register const struct yy_trans_info *yy_trans_info;\n" );
    #####: 3023:		indent_puts( "register YY_CHAR yy_c;\n" );
    #####: 3024:		indent_put2s( "for ( yy_c = %s;", char_map );
    #####: 3025:		indent_puts(
        -: 3026:	"      (yy_trans_info = &yy_current_state[(unsigned int) yy_c])->" );
    #####: 3027:		indent_puts( "yy_verify == yy_c;" );
    #####: 3028:		indent_put2s( "      yy_c = %s )", char_map_2 );
        -: 3029:
    #####: 3030:		indent_up();
        -: 3031:
    #####: 3032:		if ( num_backing_up > 0 )
    #####: 3033:			indent_puts( "{" );	/* } for vi */
        -: 3034:
    #####: 3035:		indent_puts( "yy_current_state += yy_trans_info->yy_nxt;" );
        -: 3036:
    #####: 3037:		if ( num_backing_up > 0 )
        -: 3038:			{
    #####: 3039:			putchar( '\n' );
    #####: 3040:			gen_backing_up();	/* { for vi */
    #####: 3041:			indent_puts( "}" );
        -: 3042:			}
        -: 3043:
    #####: 3044:		indent_down();	/* { for vi */
    #####: 3045:		indent_puts( "}" );
        -: 3046:		}
        -: 3047:
        -: 3048:	else
        -: 3049:		{ /* compressed */
        1: 3050:		indent_puts( "do" );
        -: 3051:
        1: 3052:		indent_up();
        1: 3053:		indent_puts( "{" );	/* } for vi */
        -: 3054:
        1: 3055:		gen_next_state( false );
        -: 3056:
        1: 3057:		indent_puts( "++yy_cp;" );
        -: 3058:
        -: 3059:		/* { for vi */
        1: 3060:		indent_puts( "}" );
        1: 3061:		indent_down();
        -: 3062:
        1: 3063:		do_indent();
        -: 3064:
        1: 3065:		if ( interactive )
        1: 3066:			printf( "while ( yy_base[yy_current_state] != %d );\n",
        -: 3067:				jambase );
        -: 3068:		else
    #####: 3069:			printf( "while ( yy_current_state != %d );\n",
        -: 3070:				jamstate );
        -: 3071:
        1: 3072:		if ( ! reject && ! interactive )
        -: 3073:			{
        -: 3074:			/* Do the guaranteed-needed backing up to figure out
        -: 3075:			 * the match.
        -: 3076:			 */
    #####: 3077:			indent_puts( "yy_cp = yy_last_accepting_cpos;" );
    #####: 3078:			indent_puts(
        -: 3079:				"yy_current_state = yy_last_accepting_state;" );
        -: 3080:			}
        -: 3081:		}
        1: 3082:	}
        -: 3083:
        -: 3084:
        -: 3085:/* Generate the code to find the next state. */
        -: 3086:
        2: 3087:void gen_next_state( worry_about_NULs )
        -: 3088:int worry_about_NULs;
        -: 3089:	{ /* NOTE - changes in here should be reflected in get_next_match() */
        -: 3090:	char char_map[256];
        -: 3091:
        2: 3092:	if ( worry_about_NULs && ! nultrans )
        -: 3093:#ifndef F_JR_6
        -: 3094:		{
        2: 3095:		if ( useecs )
        1: 3096:			(void) sprintf( char_map,
        -: 3097:				"(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : %d)",
        -: 3098:					NUL_ec );
        -: 3099:		else
    #####: 3100:			(void) sprintf( char_map,
        -: 3101:				"(*yy_cp ? YY_SC_TO_UI(*yy_cp) : %d)", NUL_ec );
        -: 3102:		}
        -: 3103:#else
        -: 3104:        {
        -: 3105:        if ( useecs )
        -: 3106:            (void) sprintf( char_map,
        -: 3107:                "(yy_cp ? yy_ec[YY_SC_TO_UI(yy_cp)] : %d)",
        -: 3108:                    NUL_ec );
        -: 3109:        else
        -: 3110:            (void) sprintf( char_map,
        -: 3111:                "(yy_cp ? YY_SC_TO_UI(yy_cp) : %d)", NUL_ec );
        -: 3112:        }
        -: 3113:
        -: 3114:#endif
        -: 3115:
        -: 3116:	else
        1: 3117:		strcpy( char_map, useecs ? "yy_ec[YY_SC_TO_UI(*yy_cp)]" :
        -: 3118:					   "YY_SC_TO_UI(*yy_cp)" );
        -: 3119:
        2: 3120:	if ( worry_about_NULs && nultrans )
        -: 3121:		{
    #####: 3122:		if ( ! fulltbl && ! fullspd )
        -: 3123:			/* Compressed tables back up *before* they match. */
    #####: 3124:			gen_backing_up();
        -: 3125:
    #####: 3126:		indent_puts( "if ( *yy_cp )" );
    #####: 3127:		indent_up();
    #####: 3128:		indent_puts( "{" );	/* } for vi */
        -: 3129:		}
        -: 3130:
        2: 3131:	if ( fulltbl )
    #####: 3132:		indent_put2s(
        -: 3133:			"yy_current_state = yy_nxt[yy_current_state][%s];", 
        -: 3134:				char_map );
        -: 3135:
        2: 3136:	else if ( fullspd )
    #####: 3137:		indent_put2s(
        -: 3138:			"yy_current_state += yy_current_state[%s].yy_nxt;",
        -: 3139:				char_map );
        -: 3140:
        -: 3141:	else
        2: 3142:		gen_next_compressed_state( char_map );
        -: 3143:
        2: 3144:	if ( worry_about_NULs && nultrans )
        -: 3145:		{
        -: 3146:		/* { for vi */
    #####: 3147:		indent_puts( "}" );
    #####: 3148:		indent_down();
    #####: 3149:		indent_puts( "else" );
    #####: 3150:		indent_up();
    #####: 3151:		indent_puts(
        -: 3152:			"yy_current_state = yy_NUL_trans[yy_current_state];" );
    #####: 3153:		indent_down();
        -: 3154:		}
        -: 3155:
        2: 3156:	if ( fullspd || fulltbl )
    #####: 3157:		gen_backing_up();
        -: 3158:
        2: 3159:	if ( reject )
    #####: 3160:		indent_puts( "*yy_state_ptr++ = yy_current_state;" );
        2: 3161:	}
        -: 3162:
        -: 3163:
        -: 3164:/* Generate the code to make a NUL transition. */
        -: 3165:
        1: 3166:void gen_NUL_trans()
        -: 3167:	{ /* NOTE - changes in here should be reflected in get_next_match() */
        1: 3168:	int need_backing_up = (num_backing_up > 0 && ! reject);
        -: 3169:
        1: 3170:	if ( need_backing_up )
        -: 3171:		/* We'll need yy_cp lying around for the gen_backing_up(). */
        1: 3172:		indent_puts( "register char *yy_cp = yy_c_buf_p;" );
        -: 3173:
        1: 3174:	putchar( '\n' );
        -: 3175:
        1: 3176:	if ( nultrans )
        -: 3177:		{
    #####: 3178:		indent_puts(
        -: 3179:			"yy_current_state = yy_NUL_trans[yy_current_state];" );
    #####: 3180:		indent_puts( "yy_is_jam = (yy_current_state == 0);" );
        -: 3181:		}
        -: 3182:
        1: 3183:	else if ( fulltbl )
        -: 3184:		{
    #####: 3185:		do_indent();
    #####: 3186:		printf( "yy_current_state = yy_nxt[yy_current_state][%d];\n",
        -: 3187:			NUL_ec );
    #####: 3188:		indent_puts( "yy_is_jam = (yy_current_state <= 0);" );
        -: 3189:		}
        -: 3190:
        1: 3191:	else if ( fullspd )
        -: 3192:		{
    #####: 3193:		do_indent();
    #####: 3194:		printf( "register int yy_c = %d;\n", NUL_ec );
        -: 3195:
    #####: 3196:		indent_puts(
        -: 3197:		"register const struct yy_trans_info *yy_trans_info;\n" );
    #####: 3198:		indent_puts(
        -: 3199:		"yy_trans_info = &yy_current_state[(unsigned int) yy_c];" );
    #####: 3200:		indent_puts( "yy_current_state += yy_trans_info->yy_nxt;" );
        -: 3201:
    #####: 3202:		indent_puts(
        -: 3203:			"yy_is_jam = (yy_trans_info->yy_verify != yy_c);" );
        -: 3204:		}
        -: 3205:
        -: 3206:	else
        -: 3207:		{
        -: 3208:		char NUL_ec_str[20];
        -: 3209:
        1: 3210:		(void) sprintf( NUL_ec_str, "%d", NUL_ec );
        1: 3211:		gen_next_compressed_state( NUL_ec_str );
        -: 3212:
        1: 3213:		if ( reject )
    #####: 3214:			indent_puts( "*yy_state_ptr++ = yy_current_state;" );
        -: 3215:
        1: 3216:		do_indent();
        -: 3217:
        1: 3218:		printf( "yy_is_jam = (yy_current_state == %d);\n", jamstate );
        -: 3219:		}
        -: 3220:
        -: 3221:	/* If we've entered an accepting state, back up; note that
        -: 3222:	 * compressed tables have *already* done such backing up, so
        -: 3223:	 * we needn't bother with it again.
        -: 3224:	 */
        1: 3225:	if ( need_backing_up && (fullspd || fulltbl) )
        -: 3226:		{
    #####: 3227:		putchar( '\n' );
    #####: 3228:		indent_puts( "if ( ! yy_is_jam )" );
    #####: 3229:		indent_up();
    #####: 3230:		indent_puts( "{" );
    #####: 3231:		gen_backing_up();
    #####: 3232:		indent_puts( "}" );
    #####: 3233:		indent_down();
        -: 3234:		}
        1: 3235:	}
        -: 3236:
        -: 3237:
        -: 3238:/* Generate the code to find the start state. */
        -: 3239:
        2: 3240:void gen_start_state()
        -: 3241:	{
        2: 3242:	if ( fullspd )
    #####: 3243:		indent_put2s(
        -: 3244:			"yy_current_state = yy_start_state_list[yy_start%s];",
    #####: 3245:			bol_needed ? " + (yy_bp[-1] == '\\n' ? 1 : 0)" : "" );
        -: 3246:
        -: 3247:	else
        -: 3248:		{
        2: 3249:		indent_puts( "yy_current_state = yy_start;" );
        -: 3250:
        2: 3251:		if ( bol_needed )
        -: 3252:			{
    #####: 3253:			indent_puts( "if ( yy_bp[-1] == '\\n' )" );
    #####: 3254:			indent_up();
    #####: 3255:			indent_puts( "++yy_current_state;" );
    #####: 3256:			indent_down();
        -: 3257:			}
        -: 3258:
        2: 3259:		if ( reject )
        -: 3260:			{
        -: 3261:			/* Set up for storing up states. */
    #####: 3262:			indent_puts( "yy_state_ptr = yy_state_buf;" );
    #####: 3263:			indent_puts( "*yy_state_ptr++ = yy_current_state;" );
        -: 3264:			}
        -: 3265:		}
        2: 3266:	}
        -: 3267:
        -: 3268:
        -: 3269:/* gentabs - generate data statements for the transition tables */
        -: 3270:
        1: 3271:void gentabs()
        -: 3272:	{
        -: 3273:	int i, j, k, *accset, nacc, *acc_array, total_states;
        1: 3274:	int end_of_buffer_action = num_rules + 1;
        -: 3275:
        -: 3276:	/* *Everything* is done in terms of arrays starting at 1, so provide
        -: 3277:	 * a null entry for the zero element of all C arrays.
        -: 3278:	 */
        -: 3279:	static char C_char_decl[] =
        -: 3280:		"static const YY_CHAR %s[%d] =\n    {   0,\n";	/* } for vi */
        -: 3281:
        1: 3282:	acc_array = allocate_integer_array( current_max_dfas );
        1: 3283:	nummt = 0;
        -: 3284:
        -: 3285:	/* The compressed table format jams by entering the "jam state",
        -: 3286:	 * losing information about the previous state in the process.
        -: 3287:	 * In order to recover the previous state, we effectively need
        -: 3288:	 * to keep backing-up information.
        -: 3289:	 */
        1: 3290:	++num_backing_up;
        -: 3291:
        1: 3292:	if ( reject )
        -: 3293:		{
        -: 3294:		/* Write out accepting list and pointer list.
        -: 3295:		 *
        -: 3296:		 * First we generate the "yy_acclist" array.  In the process,
        -: 3297:		 * we compute the indices that will go into the "yy_accept"
        -: 3298:		 * array, and save the indices in the dfaacc array.
        -: 3299:		 */
        -: 3300:		int EOB_accepting_list[2];
        -: 3301:
        -: 3302:		/* Set up accepting structures for the End Of Buffer state. */
    #####: 3303:		EOB_accepting_list[0] = 0;
    #####: 3304:		EOB_accepting_list[1] = end_of_buffer_action;
    #####: 3305:		accsiz[end_of_buffer_state] = 1;
    #####: 3306:		dfaacc[end_of_buffer_state].dfaacc_set = EOB_accepting_list;
        -: 3307:
    #####: 3308:		printf( long_align ? C_long_decl : C_short_decl,
    #####: 3309:			"yy_acclist", MAX( numas, 1 ) + 1 );
        -: 3310:
    #####: 3311:		j = 1;	/* index into "yy_acclist" array */
        -: 3312:
    #####: 3313:		for ( i = 1; i <= lastdfa; ++i )
        -: 3314:			{
    #####: 3315:			acc_array[i] = j;
        -: 3316:
    #####: 3317:			if ( accsiz[i] != 0 )
        -: 3318:				{
    #####: 3319:				accset = dfaacc[i].dfaacc_set;
    #####: 3320:				nacc = accsiz[i];
        -: 3321:
    #####: 3322:				if ( trace )
    #####: 3323:					fprintf( err,
        -: 3324:						"state # %d accepts: ", i );
        -: 3325:
    #####: 3326:				for ( k = 1; k <= nacc; ++k )
        -: 3327:					{
    #####: 3328:					int accnum = accset[k];
        -: 3329:
    #####: 3330:					++j;
        -: 3331:
    #####: 3332:					if ( variable_trailing_context_rules &&
    #####: 3333:					  ! (accnum & YY_TRAILING_HEAD_MASK) &&
    #####: 3334:					   accnum > 0 && accnum <= num_rules &&
    #####: 3335:					  rule_type[accnum] == RULE_VARIABLE )
        -: 3336:						{
        -: 3337:						/* Special hack to flag
        -: 3338:						 * accepting number as part
        -: 3339:						 * of trailing context rule.
        -: 3340:						 */
    #####: 3341:						accnum |= YY_TRAILING_MASK;
        -: 3342:						}
        -: 3343:
    #####: 3344:					mkdata( accnum );
        -: 3345:
    #####: 3346:					if ( trace )
        -: 3347:						{
    #####: 3348:						fprintf( err, "[%d]",
    #####: 3349:							accset[k] );
        -: 3350:
    #####: 3351:						if ( k < nacc )
    #####: 3352:							fputs( ", ", err );
        -: 3353:						else
    #####: 3354:							putc( '\n', err );
        -: 3355:						}
        -: 3356:					}
        -: 3357:				}
        -: 3358:			}
        -: 3359:
        -: 3360:		/* add accepting number for the "jam" state */
    #####: 3361:		acc_array[i] = j;
        -: 3362:
    #####: 3363:		dataend();
        -: 3364:		}
        -: 3365:
        -: 3366:	else
        -: 3367:		{
        1: 3368:		dfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;
        -: 3369:
        7: 3370:		for ( i = 1; i <= lastdfa; ++i )
        6: 3371:			acc_array[i] = dfaacc[i].dfaacc_state;
        -: 3372:
        -: 3373:		/* add accepting number for jam state */
        1: 3374:		acc_array[i] = 0;
        -: 3375:		}
        -: 3376:
        -: 3377:	/* Spit out "yy_accept" array.  If we're doing "reject", it'll be
        -: 3378:	 * pointers into the "yy_acclist" array.  Otherwise it's actual
        -: 3379:	 * accepting numbers.  In either case, we just dump the numbers.
        -: 3380:	 */
        -: 3381:
        -: 3382:	/* "lastdfa + 2" is the size of "yy_accept"; includes room for C arrays
        -: 3383:	 * beginning at 0 and for "jam" state.
        -: 3384:	 */
        1: 3385:	k = lastdfa + 2;
        -: 3386:
        1: 3387:	if ( reject )
        -: 3388:		/* We put a "cap" on the table associating lists of accepting
        -: 3389:		 * numbers with state numbers.  This is needed because we tell
        -: 3390:		 * where the end of an accepting list is by looking at where
        -: 3391:		 * the list for the next state starts.
        -: 3392:		 */
    #####: 3393:		++k;
        -: 3394:
        1: 3395:	printf( long_align ? C_long_decl : C_short_decl, "yy_accept", k );
        -: 3396:
        7: 3397:	for ( i = 1; i <= lastdfa; ++i )
        -: 3398:		{
        6: 3399:		mkdata( acc_array[i] );
        -: 3400:
        6: 3401:		if ( ! reject && trace && acc_array[i] )
    #####: 3402:			fprintf( err, "state # %d accepts: [%d]\n",
    #####: 3403:				i, acc_array[i] );
        -: 3404:		}
        -: 3405:
        -: 3406:	/* Add entry for "jam" state. */
        1: 3407:	mkdata( acc_array[i] );
        -: 3408:
        1: 3409:	if ( reject )
        -: 3410:		/* Add "cap" for the list. */
    #####: 3411:		mkdata( acc_array[i] );
        -: 3412:
        1: 3413:	dataend();
        -: 3414:
        1: 3415:	if ( useecs )
        1: 3416:		genecs();
        -: 3417:
        1: 3418:	if ( usemecs )
        -: 3419:		{
        -: 3420:		/* Write out meta-equivalence classes (used to index
        -: 3421:		 * templates with).
        -: 3422:		 */
        -: 3423:
        1: 3424:		if ( trace )
    #####: 3425:			fputs( "\n\nMeta-Equivalence Classes:\n", err );
        -: 3426:
        -: 3427:#ifndef	F_HD_5
        -: 3428:		printf( C_int_decl, "yy_meta", numecs + 1 ); 
        -: 3429:#else
        1: 3430:		printf( C_char_decl, "yy_meta", numecs + 1 ); 
        -: 3431:#endif
        -: 3432:
        2: 3433:		for ( i = 1; i <= numecs; ++i )
        -: 3434:			{
        1: 3435:			if ( trace )
    #####: 3436:				fprintf( err, "%d = %d\n",
    #####: 3437:					i, ABS( tecbck[i] ) );
        -: 3438:
        1: 3439:			mkdata( ABS( tecbck[i] ) );
        -: 3440:			}
        -: 3441:
        1: 3442:		dataend();
        -: 3443:		}
        -: 3444:
        1: 3445:	total_states = lastdfa + numtemps;
        -: 3446:
        1: 3447:	printf( (tblend >= MAX_SHORT || long_align) ?
        -: 3448:			C_long_decl : C_short_decl,
        -: 3449:		"yy_base", total_states + 1 );
        -: 3450:
        7: 3451:	for ( i = 1; i <= lastdfa; ++i )
        -: 3452:		{
        6: 3453:		register int d = def[i];
        -: 3454:
        6: 3455:		if ( base[i] == JAMSTATE )
        1: 3456:			base[i] = jambase;
        -: 3457:
        6: 3458:		if ( d == JAMSTATE )
        2: 3459:			def[i] = jamstate;
        -: 3460:
        4: 3461:		else if ( d < 0 )
        -: 3462:			{
        -: 3463:			/* Template reference. */
        4: 3464:			++tmpuses;
        4: 3465:			def[i] = lastdfa - d + 1;
        -: 3466:			}
        -: 3467:
        6: 3468:		mkdata( base[i] );
        -: 3469:		}
        -: 3470:
        -: 3471:	/* Generate jam state's base index. */
        1: 3472:	mkdata( base[i] );
        -: 3473:
        2: 3474:	for ( ++i /* skip jam state */; i <= total_states; ++i )
        -: 3475:		{
        1: 3476:		mkdata( base[i] );
        1: 3477:		def[i] = jamstate;
        -: 3478:		}
        -: 3479:
        1: 3480:	dataend();
        -: 3481:
        1: 3482:	printf( (total_states >= MAX_SHORT || long_align) ?
        -: 3483:			C_long_decl : C_short_decl,
        -: 3484:		"yy_def", total_states + 1 );
        -: 3485:
        9: 3486:	for ( i = 1; i <= total_states; ++i )
        8: 3487:		mkdata( def[i] );
        -: 3488:
        1: 3489:	dataend();
        -: 3490:
        1: 3491:	printf( (total_states >= MAX_SHORT || long_align) ?
        -: 3492:			C_long_decl : C_short_decl,
        -: 3493:		"yy_nxt", tblend + 1 );
        -: 3494:
        5: 3495:	for ( i = 1; i <= tblend; ++i )
        -: 3496:		{
        4: 3497:		if ( nxt[i] == 0 || chk[i] == 0 )
        2: 3498:			nxt[i] = jamstate;	/* new state is the JAM state */
        -: 3499:
        4: 3500:		mkdata( nxt[i] );
        -: 3501:		}
        -: 3502:
        1: 3503:	dataend();
        -: 3504:
        1: 3505:	printf( (total_states >= MAX_SHORT || long_align) ?
        -: 3506:			C_long_decl : C_short_decl,
        -: 3507:		"yy_chk", tblend + 1 );
        -: 3508:
        5: 3509:	for ( i = 1; i <= tblend; ++i )
        -: 3510:		{
        4: 3511:		if ( chk[i] == 0 )
    #####: 3512:			++nummt;
        -: 3513:
        4: 3514:		mkdata( chk[i] );
        -: 3515:		}
        -: 3516:
        1: 3517:	dataend();
        1: 3518:	}
        -: 3519:
        -: 3520:
        -: 3521:/* Write out a formatted string (with a secondary string argument) at the
        -: 3522: * current indentation level, adding a final newline.
        -: 3523: */
        -: 3524:
        3: 3525:void indent_put2s( fmt, arg )
        -: 3526:char fmt[], arg[];
        -: 3527:	{
        3: 3528:	do_indent();
        3: 3529:	printf( fmt, arg );
        3: 3530:	putchar( '\n' );
        3: 3531:	}
        -: 3532:
        -: 3533:
        -: 3534:/* Write out a string at the current indentation level, adding a final
        -: 3535: * newline.
        -: 3536: */
        -: 3537:
       53: 3538:void indent_puts( str )
        -: 3539:char str[];
        -: 3540:	{
       53: 3541:	do_indent();
       53: 3542:	puts( str );
       53: 3543:	}
        -: 3544:
        -: 3545:
        -: 3546:/* make_tables - generate transition tables and finishes generating output file
        -: 3547: */
        -: 3548:
        1: 3549:void make_tables()
        -: 3550:	{
        -: 3551:	register int i;
        1: 3552:	int did_eof_rule = false;
        -: 3553:
        1: 3554:	skelout();
        -: 3555:
        -: 3556:	/* First, take care of YY_DO_BEFORE_ACTION depending on yymore
        -: 3557:	 * being used.
        -: 3558:	 */
        1: 3559:	set_indent( 1 );
        -: 3560:
        1: 3561:	if ( yymore_used )
        -: 3562:		{
    #####: 3563:		indent_puts( "yytext_ptr -= yy_more_len; \\" );
    #####: 3564:		indent_puts( "yyleng = yy_cp - yytext_ptr; \\" );
        -: 3565:		}
        -: 3566:
        -: 3567:	else
        1: 3568:		indent_puts( "yyleng = yy_cp - yy_bp; \\" );
        -: 3569:
        -: 3570:	/* Now also deal with copying yytext_ptr to yytext if needed. */
        1: 3571:	skelout();
        1: 3572:	if ( yytext_is_array )
        -: 3573:		{
    #####: 3574:		indent_puts( "if ( yyleng >= YYLMAX ) \\" );
    #####: 3575:		indent_up();
    #####: 3576:		indent_puts(
        -: 3577:		"YY_FATAL_ERROR( \"token too large, exceeds YYLMAX\" ); \\" );
    #####: 3578:		indent_down();
        -: 3579:#ifndef F_JR_5
    #####: 3580:		indent_puts(
        -: 3581:		"yy_flex_strncpy( yytext, yytext_ptr, yyleng + 1 ); \\" );
        -: 3582:#else
        -: 3583:        indent_puts(
        -: 3584:        "yy_flex_strncpy( yytext, yytext_ptr, yyleng); \\" );
        -: 3585:#endif
        -: 3586:		}
        -: 3587:
        1: 3588:	set_indent( 0 );
        -: 3589:
        1: 3590:	skelout();
        -: 3591:
        -: 3592:
        1: 3593:	printf( "#define YY_END_OF_BUFFER %d\n", num_rules + 1 );
        -: 3594:
        1: 3595:	if ( fullspd )
        -: 3596:		{
        -: 3597:		/* Need to define the transet type as a size large
        -: 3598:		 * enough to hold the biggest offset.
        -: 3599:		 */
    #####: 3600:		int total_table_size = tblend + numecs + 1;
    #####: 3601:		char *trans_offset_type =
    #####: 3602:			(total_table_size >= MAX_SHORT || long_align) ?
    #####: 3603:				"long" : "short";
        -: 3604:
    #####: 3605:		set_indent( 0 );
    #####: 3606:		indent_puts( "struct yy_trans_info" );
    #####: 3607:		indent_up();
    #####: 3608:		indent_puts( "{" ); 	/* } for vi */
        -: 3609:
    #####: 3610:		if ( long_align )
    #####: 3611:			indent_puts( "long yy_verify;" );
        -: 3612:		else
    #####: 3613:			indent_puts( "short yy_verify;" );
        -: 3614:
        -: 3615:		/* In cases where its sister yy_verify *is* a "yes, there is
        -: 3616:		 * a transition", yy_nxt is the offset (in records) to the
        -: 3617:		 * next state.  In most cases where there is no transition,
        -: 3618:		 * the value of yy_nxt is irrelevant.  If yy_nxt is the -1th
        -: 3619:		 * record of a state, though, then yy_nxt is the action number
        -: 3620:		 * for that state.
        -: 3621:		 */
        -: 3622:
    #####: 3623:		indent_put2s( "%s yy_nxt;", trans_offset_type );
    #####: 3624:		indent_puts( "};" );
    #####: 3625:		indent_down();
        -: 3626:		}
        -: 3627:
        1: 3628:	if ( fullspd )
    #####: 3629:		genctbl();
        1: 3630:	else if ( fulltbl )
    #####: 3631:		genftbl();
        -: 3632:	else
        1: 3633:		gentabs();
        -: 3634:
        -: 3635:	/* Definitions for backing up.  We don't need them if REJECT
        -: 3636:	 * is being used because then we use an alternative backin-up
        -: 3637:	 * technique instead.
        -: 3638:	 */
        1: 3639:	if ( num_backing_up > 0 && ! reject )
        -: 3640:		{
        1: 3641:		if ( ! C_plus_plus )
        -: 3642:			{
        1: 3643:			indent_puts(
        -: 3644:			"static yy_state_type yy_last_accepting_state;" );
        1: 3645:			indent_puts(
        -: 3646:				"static char *yy_last_accepting_cpos;\n" );
        -: 3647:			}
        -: 3648:		}
        -: 3649:
        1: 3650:	if ( nultrans )
        -: 3651:		{
    #####: 3652:		printf( C_state_decl, "yy_NUL_trans", lastdfa + 1 );
        -: 3653:
    #####: 3654:		for ( i = 1; i <= lastdfa; ++i )
        -: 3655:			{
    #####: 3656:			if ( fullspd )
    #####: 3657:				printf( "    &yy_transition[%d],\n", base[i] );
        -: 3658:			else
    #####: 3659:				mkdata( nultrans[i] );
        -: 3660:			}
        -: 3661:
    #####: 3662:		dataend();
        -: 3663:		}
        -: 3664:
        1: 3665:	if ( ddebug )
        -: 3666:		{ /* Spit out table mapping rules to line numbers. */
    #####: 3667:		indent_puts( "extern int yy_flex_debug;" );
    #####: 3668:		indent_puts( "int yy_flex_debug = 1;\n" );
        -: 3669:
    #####: 3670:		printf( long_align ? C_long_decl : C_short_decl,
        -: 3671:			"yy_rule_linenum", num_rules );
    #####: 3672:		for ( i = 1; i < num_rules; ++i )
    #####: 3673:			mkdata( rule_linenum[i] );
    #####: 3674:		dataend();
        -: 3675:		}
        -: 3676:
        1: 3677:	if ( reject )
        -: 3678:		{
        -: 3679:		/* Declare state buffer variables. */
    #####: 3680:		if ( ! C_plus_plus )
        -: 3681:			{
    #####: 3682:			puts(
        -: 3683:	"static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;" );
    #####: 3684:			puts( "static char *yy_full_match;" );
    #####: 3685:			puts( "static int yy_lp;" );
        -: 3686:			}
        -: 3687:
    #####: 3688:		if ( variable_trailing_context_rules )
        -: 3689:			{
    #####: 3690:			if ( ! C_plus_plus )
        -: 3691:				{
    #####: 3692:				puts(
        -: 3693:				"static int yy_looking_for_trail_begin = 0;" );
    #####: 3694:				puts( "static int yy_full_lp;" );
    #####: 3695:				puts( "static int *yy_full_state;" );
        -: 3696:				}
        -: 3697:
    #####: 3698:			printf( "#define YY_TRAILING_MASK 0x%x\n",
        -: 3699:				(unsigned int) YY_TRAILING_MASK );
    #####: 3700:			printf( "#define YY_TRAILING_HEAD_MASK 0x%x\n",
        -: 3701:				(unsigned int) YY_TRAILING_HEAD_MASK );
        -: 3702:			}
        -: 3703:
    #####: 3704:		puts( "#define REJECT \\" );
    #####: 3705:		puts( "{ \\" );		/* } for vi */
    #####: 3706:		puts(
        -: 3707:	"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \\" );
    #####: 3708:		puts(
        -: 3709:	"yy_cp = yy_full_match; /* restore poss. backed-over text */ \\" );
        -: 3710:
    #####: 3711:		if ( variable_trailing_context_rules )
        -: 3712:			{
    #####: 3713:			puts(
        -: 3714:		"yy_lp = yy_full_lp; /* restore orig. accepting pos. */ \\" );
    #####: 3715:			puts(
        -: 3716:		"yy_state_ptr = yy_full_state; /* restore orig. state */ \\" );
    #####: 3717:			puts(
        -: 3718:	"yy_current_state = *yy_state_ptr; /* restore curr. state */ \\" );
        -: 3719:			}
        -: 3720:
    #####: 3721:		puts( "++yy_lp; \\" );
    #####: 3722:		puts( "goto find_rule; \\" );
        -: 3723:		/* { for vi */
    #####: 3724:		puts( "}" );
        -: 3725:		}
        -: 3726:
        -: 3727:	else
        -: 3728:		{
        1: 3729:		puts(
        -: 3730:		"/* The intent behind this definition is that it'll catch" );
        1: 3731:		puts( " * any uses of REJECT which flex missed." );
        1: 3732:		puts( " */" );
        1: 3733:		puts( "#define REJECT reject_used_but_not_detected" );
        -: 3734:		}
        -: 3735:
        1: 3736:	if ( yymore_used )
        -: 3737:		{
    #####: 3738:		if ( ! C_plus_plus )
        -: 3739:			{
    #####: 3740:			indent_puts( "static int yy_more_flag = 0;" );
    #####: 3741:			indent_puts( "static int yy_more_len = 0;" );
        -: 3742:			}
        -: 3743:
    #####: 3744:		indent_puts( "#define yymore() (yy_more_flag = 1)" );
    #####: 3745:		indent_puts( "#define YY_MORE_ADJ yy_more_len" );
        -: 3746:		}
        -: 3747:
        -: 3748:	else
        -: 3749:		{
        1: 3750:		indent_puts( "#define yymore() yymore_used_but_not_detected" );
        1: 3751:		indent_puts( "#define YY_MORE_ADJ 0" );
        -: 3752:		}
        -: 3753:
        1: 3754:	if ( ! C_plus_plus )
        -: 3755:		{
        1: 3756:		if ( yytext_is_array )
        -: 3757:			{
    #####: 3758:			puts( "#ifndef YYLMAX" );
    #####: 3759:			puts( "#define YYLMAX 8192" );
    #####: 3760:			puts( "#endif\n" );
    #####: 3761:			puts( "char yytext[YYLMAX];" );
    #####: 3762:			puts( "char *yytext_ptr;" );
        -: 3763:			}
        -: 3764:
        -: 3765:		else
        1: 3766:			puts( "char *yytext;" );
        -: 3767:		}
        -: 3768:
        1: 3769:	fputs( &action_array[defs1_offset], stdout );
        -: 3770:
        1: 3771:	skelout();
        -: 3772:
        1: 3773:	if ( ! C_plus_plus )
        -: 3774:		{
        1: 3775:		if ( use_read )
        -: 3776:			{
    #####: 3777:			printf(
        -: 3778:"\tif ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \\\n" );
    #####: 3779:			printf(
        -: 3780:		"\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );\n" );
        -: 3781:			}
        -: 3782:
        -: 3783:		else
        -: 3784:			{
        1: 3785:			printf(
        -: 3786:			"\tif ( yy_current_buffer->yy_is_interactive ) \\\n" );
        1: 3787:			printf( "\t\t{ \\\n" );
        1: 3788:			printf( "\t\tint c = getc( yyin ); \\\n" );
        1: 3789:			printf( "\t\tresult = c == EOF ? 0 : 1; \\\n" );
        -: 3790:#ifndef F_JR_4
        1: 3791:			printf( "\t\tbuf[0] = (char) c; \\\n" );
        -: 3792:#else
        -: 3793:            printf( "\t\buf[0] = (char) c; \\\n" );
        -: 3794:#endif
        1: 3795:			printf( "\t\t} \\\n" );
        -: 3796:			
        1: 3797:            printf(
        -: 3798:	"\telse if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \\\n" );
        1: 3799:			printf( "\t\t  && ferror( yyin ) ) \\\n" );
        1: 3800:			printf(
        -: 3801:		"\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );\n" );
        -: 3802:			}
        -: 3803:		}
        -: 3804:
        1: 3805:	skelout();
        -: 3806:
        -: 3807:	/* Copy prolog to output file. */
        1: 3808:	fputs( &action_array[prolog_offset], stdout );
        -: 3809:
        1: 3810:	skelout();
        -: 3811:
        1: 3812:	set_indent( 2 );
        -: 3813:
        1: 3814:	if ( yymore_used )
        -: 3815:		{
    #####: 3816:		indent_puts( "yy_more_len = 0;" );
    #####: 3817:		indent_puts( "if ( yy_more_flag )" );
    #####: 3818:		indent_up();
    #####: 3819:		indent_puts( "{" );
    #####: 3820:		indent_puts( "yy_more_len = yyleng;" );
    #####: 3821:		indent_puts( "yy_more_flag = 0;" );
    #####: 3822:		indent_puts( "}" );
    #####: 3823:		indent_down();
        -: 3824:		}
        -: 3825:
        1: 3826:	skelout();
        -: 3827:
        1: 3828:	gen_start_state();
        -: 3829:
        -: 3830:	/* Note, don't use any indentation. */
        1: 3831:	puts( "yy_match:" );
        1: 3832:	gen_next_match();
        -: 3833:
        1: 3834:	skelout();
        1: 3835:	set_indent( 2 );
        1: 3836:	gen_find_action();
        -: 3837:
        1: 3838:	skelout();
        1: 3839:	if ( lex_compat )
        -: 3840:		{
    #####: 3841:		indent_puts( "if ( yy_act != YY_END_OF_BUFFER )" );
    #####: 3842:		indent_up();
    #####: 3843:		indent_puts( "{" );
    #####: 3844:		indent_puts( "int yyl;" );
    #####: 3845:		indent_puts( "for ( yyl = 0; yyl < yyleng; ++yyl )" );
    #####: 3846:		indent_up();
    #####: 3847:		indent_puts( "if ( yytext[yyl] == '\\n' )" );
    #####: 3848:		indent_up();
    #####: 3849:		indent_puts( "++yylineno;" );
    #####: 3850:		indent_down();
    #####: 3851:		indent_down();
    #####: 3852:		indent_puts( "}" );
    #####: 3853:		indent_down();
        -: 3854:		}
        -: 3855:
        1: 3856:	skelout();
        1: 3857:	if ( ddebug )
        -: 3858:		{
    #####: 3859:		indent_puts( "if ( yy_flex_debug )" );
    #####: 3860:		indent_up();
        -: 3861:
    #####: 3862:		indent_puts( "{" );
    #####: 3863:		indent_puts( "if ( yy_act == 0 )" );
    #####: 3864:		indent_up();
    #####: 3865:		indent_puts(
        -: 3866:			"fprintf( stderr, \"--scanner backing up\\n\" );" );
    #####: 3867:		indent_down();
        -: 3868:
    #####: 3869:		do_indent();
    #####: 3870:		printf( "else if ( yy_act < %d )\n", num_rules );
    #####: 3871:		indent_up();
    #####: 3872:		indent_puts(
        -: 3873:	"fprintf( stderr, \"--accepting rule at line %d (\\\"%s\\\")\\n\"," );
    #####: 3874:		indent_puts( "         yy_rule_linenum[yy_act], yytext );" );
    #####: 3875:		indent_down();
        -: 3876:
    #####: 3877:		do_indent();
    #####: 3878:		printf( "else if ( yy_act == %d )\n", num_rules );
    #####: 3879:		indent_up();
    #####: 3880:		indent_puts(
        -: 3881:	"fprintf( stderr, \"--accepting default rule (\\\"%s\\\")\\n\"," );
    #####: 3882:		indent_puts( "         yytext );" );
    #####: 3883:		indent_down();
        -: 3884:
    #####: 3885:		do_indent();
    #####: 3886:		printf( "else if ( yy_act == %d )\n", num_rules + 1 );
    #####: 3887:		indent_up();
    #####: 3888:		indent_puts(
        -: 3889:	"fprintf( stderr, \"--(end of buffer or a NUL)\\n\" );" );
    #####: 3890:		indent_down();
        -: 3891:
    #####: 3892:		do_indent();
    #####: 3893:		printf( "else\n" );
    #####: 3894:		indent_up();
    #####: 3895:		indent_puts(
        -: 3896:	"fprintf( stderr, \"--EOF (start condition %d)\\n\", YY_START );" );
    #####: 3897:		indent_down();
        -: 3898:
    #####: 3899:		indent_puts( "}" );
    #####: 3900:		indent_down();
        -: 3901:		}
        -: 3902:
        -: 3903:	/* Copy actions to output file. */
        1: 3904:	skelout();
        1: 3905:	indent_up();
        1: 3906:	gen_bu_action();
        1: 3907:	fputs( &action_array[action_offset], stdout );
        -: 3908:
        -: 3909:	/* generate cases for any missing EOF rules */
        3: 3910:	for ( i = 1; i <= lastsc; ++i )
        2: 3911:		if ( ! sceof[i] )
        -: 3912:			{
    #####: 3913:			do_indent();
    #####: 3914:			printf( "case YY_STATE_EOF(%s):\n", scname[i] );
    #####: 3915:			did_eof_rule = true;
        -: 3916:			}
        -: 3917:
        1: 3918:	if ( did_eof_rule )
        -: 3919:		{
    #####: 3920:		indent_up();
    #####: 3921:		indent_puts( "yyterminate();" );
    #####: 3922:		indent_down();
        -: 3923:		}
        -: 3924:
        -: 3925:
        -: 3926:	/* Generate code for handling NUL's, if needed. */
        -: 3927:
        -: 3928:	/* First, deal with backing up and setting up yy_cp if the scanner
        -: 3929:	 * finds that it should JAM on the NUL.
        -: 3930:	 */
        1: 3931:	skelout();
        1: 3932:	set_indent( 7 );
        -: 3933:
        1: 3934:	if ( fullspd || fulltbl )
    #####: 3935:		indent_puts( "yy_cp = yy_c_buf_p;" );
        -: 3936:
        -: 3937:	else
        -: 3938:		{ /* compressed table */
        1: 3939:		if ( ! reject && ! interactive )
        -: 3940:			{
        -: 3941:			/* Do the guaranteed-needed backing up to figure
        -: 3942:			 * out the match.
        -: 3943:			 */
    #####: 3944:			indent_puts( "yy_cp = yy_last_accepting_cpos;" );
    #####: 3945:			indent_puts(
        -: 3946:				"yy_current_state = yy_last_accepting_state;" );
        -: 3947:			}
        -: 3948:#ifndef F_JR_3
        -: 3949:		else
        -: 3950:			/* Still need to initialize yy_cp, though
        -: 3951:			 * yy_current_state was set up by
        -: 3952:			 * yy_get_previous_state().
        -: 3953:			 */
        1: 3954:			indent_puts( "yy_cp = yy_c_buf_p;" );
        -: 3955:#else
        -: 3956:;  /* do nothing */
        -: 3957:#endif
        -: 3958:		}
        -: 3959:
        -: 3960:
        -: 3961:	/* Generate code for yy_get_previous_state(). */
        1: 3962:	set_indent( 1 );
        1: 3963:	skelout();
        -: 3964:
        1: 3965:	if ( bol_needed )
    #####: 3966:		indent_puts( "register char *yy_bp = yytext_ptr;\n" );
        -: 3967:
        1: 3968:	gen_start_state();
        -: 3969:
        1: 3970:	set_indent( 2 );
        1: 3971:	skelout();
        1: 3972:	gen_next_state( true );
        -: 3973:
        1: 3974:	set_indent( 1 );
        1: 3975:	skelout();
        1: 3976:	gen_NUL_trans();
        -: 3977:
        1: 3978:	skelout();
        1: 3979:	if ( lex_compat )
        -: 3980:		{ /* update yylineno inside of unput() */
    #####: 3981:		indent_puts( "if ( c == '\\n' )" );
    #####: 3982:		indent_up();
    #####: 3983:		indent_puts( "--yylineno;" );
    #####: 3984:		indent_down();
        -: 3985:		}
        -: 3986:
        1: 3987:	skelout();
        -: 3988:
        -: 3989:	/* Copy remainder of input to output. */
        -: 3990:
        1: 3991:	line_directive_out( stdout );
        -: 3992:
        1: 3993:	if ( sectnum == 3 )
    #####: 3994:		(void) flexscan(); /* copy remainder of input to output */
        1: 3995:	}
        -: 3996:/* misc - miscellaneous flex routines */
        -: 3997:
        -: 3998:/*-
        -: 3999: * Copyright (c) 1990 The Regents of the University of California.
        -: 4000: * All rights reserved.
        -: 4001: *
        -: 4002: * This code is derived from software contributed to Berkeley by
        -: 4003: * Vern Paxson.
        -: 4004: * 
        -: 4005: * The United States Government has rights in this work pursuant
        -: 4006: * to contract no. DE-AC03-76SF00098 between the United States
        -: 4007: * Department of Energy and the University of California.
        -: 4008: *
        -: 4009: * Redistribution and use in source and binary forms are permitted provided
        -: 4010: * that: (1) source distributions retain this entire copyright notice and
        -: 4011: * comment, and (2) distributions including binaries display the following
        -: 4012: * acknowledgement:  ``This product includes software developed by the
        -: 4013: * University of California, Berkeley and its contributors'' in the
        -: 4014: * documentation or other materials provided with the distribution and in
        -: 4015: * all advertising materials mentioning features or use of this software.
        -: 4016: * Neither the name of the University nor the names of its contributors may
        -: 4017: * be used to endorse or promote products derived from this software without
        -: 4018: * specific prior written permission.
        -: 4019: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 4020: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 4021: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 4022: */
        -: 4023:
        -: 4024:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 4025:
        -: 4026:
        -: 4027:
        -: 4028:
        -: 4029:/* declare functions that have forward references */
        -: 4030:
        -: 4031:void dataflush PROTO((void));
        -: 4032:int otoi PROTO((Char []));
        -: 4033:
        -: 4034:
       82: 4035:void add_action( new_text )
        -: 4036:char *new_text;
        -: 4037:	{
       82: 4038:	int len = strlen( new_text );
        -: 4039:
      164: 4040:	while ( len + action_index >= action_size - 10 /* slop */ )
        -: 4041:		{
    #####: 4042:		action_size *= 2;
    #####: 4043:		action_array =
    #####: 4044:			reallocate_character_array( action_array, action_size );
        -: 4045:		}
        -: 4046:
       82: 4047:	strcpy( &action_array[action_index], new_text );
        -: 4048:
       82: 4049:	action_index += len;
       82: 4050:	}
        -: 4051:
        -: 4052:
        -: 4053:/* allocate_array - allocate memory for an integer array of the given size */
        -: 4054:
       44: 4055:void *allocate_array( size, element_size )
        -: 4056:int size, element_size;
        -: 4057:	{
        -: 4058:	register void *mem;
        -: 4059:
        -: 4060:	/* On 16-bit int machines (e.g., 80286) we might be trying to
        -: 4061:	 * allocate more than a signed int can hold, and that won't
        -: 4062:	 * work.  Cheap test:
        -: 4063:	 */
       44: 4064:	if ( element_size * size <= 0 )
    #####: 4065:		flexfatal( "request for < 1 byte in allocate_array()" );
        -: 4066:
        -: 4067:#ifndef	F_HD_6
       44: 4068:	mem = flex_alloc( element_size * size); 
        -: 4069:#else
        -: 4070:	mem = flex_alloc( element_size);
        -: 4071:#endif
        -: 4072:				"";
        -: 4073:
       44: 4074:	if ( mem == NULL )
    #####: 4075:		flexfatal( "memory allocation failed in allocate_array()" );
        -: 4076:
       44: 4077:	return mem;
        -: 4078:	}
        -: 4079:
        -: 4080:
        -: 4081:/* all_lower - true if a string is all lower-case */
        -: 4082:
    #####: 4083:int all_lower( str )
        -: 4084:register char *str;
        -: 4085:	{
    #####: 4086:	while ( *str )
        -: 4087:		{
    #####: 4088:		if ( ! isascii( (Char) *str ) || ! islower( *str ) )
    #####: 4089:			return 0;
    #####: 4090:		++str;
        -: 4091:		}
        -: 4092:
    #####: 4093:	return 1;
        -: 4094:	}
        -: 4095:
        -: 4096:
        -: 4097:/* all_upper - true if a string is all upper-case */
        -: 4098:
    #####: 4099:int all_upper( str )
        -: 4100:register char *str;
        -: 4101:	{
    #####: 4102:	while ( *str )
        -: 4103:		{
    #####: 4104:		if ( ! isascii( (Char) *str ) || ! isupper( *str ) )
    #####: 4105:			return 0;
    #####: 4106:		++str;
        -: 4107:		}
        -: 4108:
    #####: 4109:	return 1;
        -: 4110:	}
        -: 4111:
        -: 4112:
        -: 4113:/* bubble - bubble sort an integer array in increasing order
        -: 4114: *
        -: 4115: * synopsis
        -: 4116: *   int v[n], n;
        -: 4117: *   void bubble( v, n );
        -: 4118: *
        -: 4119: * description
        -: 4120: *   sorts the first n elements of array v and replaces them in
        -: 4121: *   increasing order.
        -: 4122: *
        -: 4123: * passed
        -: 4124: *   v - the array to be sorted
        -: 4125: *   n - the number of elements of 'v' to be sorted
        -: 4126: */
        -: 4127:
        9: 4128:void bubble( v, n )
        -: 4129:int v[], n;
        -: 4130:	{
        -: 4131:	register int i, j, k;
        -: 4132:
       13: 4133:	for ( i = n; i > 1; --i )
        8: 4134:		for ( j = 1; j < i; ++j )
        4: 4135:			if ( v[j] > v[j + 1] )	/* compare */
        -: 4136:				{
        4: 4137:				k = v[j];	/* exchange */
        4: 4138:				v[j] = v[j + 1];
        4: 4139:				v[j + 1] = k;
        -: 4140:				}
        9: 4141:	}
        -: 4142:
        -: 4143:
        -: 4144:/* check_char - checks a character to make sure it's within the range
        -: 4145: *		we're expecting.  If not, generates fatal error message
        -: 4146: *		and exits.
        -: 4147: */
        -: 4148:
    #####: 4149:void check_char( c )
        -: 4150:int c;
        -: 4151:	{
    #####: 4152:	if ( c >= CSIZE )
    #####: 4153:		lerrsf( "bad character '%s' detected in check_char()",
        -: 4154:			readable_form( c ) );
        -: 4155:
    #####: 4156:	if ( c >= csize )
    #####: 4157:		lerrsf( "scanner requires -8 flag to use the character '%s'",
        -: 4158:			readable_form( c ) );
    #####: 4159:	}
        -: 4160:
        -: 4161:
        -: 4162:
        -: 4163:/* clower - replace upper-case letter to lower-case */
        -: 4164:
    #####: 4165:Char clower( c )
        -: 4166:register int c;
        -: 4167:	{
    #####: 4168:	return (Char) ((isascii( c ) && isupper( c )) ? tolower( c ) : c);
        -: 4169:	}
        -: 4170:
        -: 4171:
        -: 4172:/* copy_string - returns a dynamically allocated copy of a string */
        -: 4173:
        2: 4174:char *copy_string( str )
        -: 4175:register char *str;
        -: 4176:	{
        -: 4177:	register char *c;
        -: 4178:	char *copy;
        -: 4179:
        -: 4180:	/* find length */
        2: 4181:	for ( c = str; *c; ++c )
        -: 4182:		;
        -: 4183:
        2: 4184:	copy = (char *) flex_alloc( (c - str + 1) * sizeof( char ) );
        -: 4185:
        2: 4186:	if ( copy == NULL )
    #####: 4187:		flexfatal( "dynamic memory failure in copy_string()" );
        -: 4188:
        2: 4189:	for ( c = copy; (*c++ = *str++); )
        -: 4190:		;
        -: 4191:
        2: 4192:	return copy;
        -: 4193:	}
        -: 4194:
        -: 4195:
        -: 4196:/* copy_unsigned_string -
        -: 4197: *    returns a dynamically allocated copy of a (potentially) unsigned string
        -: 4198: */
        -: 4199:
    #####: 4200:Char *copy_unsigned_string( str )
        -: 4201:register Char *str;
        -: 4202:	{
        -: 4203:	register Char *c;
        -: 4204:	Char *copy;
        -: 4205:
        -: 4206:	/* find length */
    #####: 4207:	for ( c = str; *c; ++c )
        -: 4208:		;
        -: 4209:
    #####: 4210:	copy = allocate_Character_array( c - str + 1 );
        -: 4211:
    #####: 4212:	for ( c = copy; (*c++ = *str++); )
        -: 4213:		;
        -: 4214:
    #####: 4215:	return copy;
        -: 4216:	}
        -: 4217:
        -: 4218:
        -: 4219:/* cshell - shell sort a character array in increasing order
        -: 4220: *
        -: 4221: * synopsis
        -: 4222: *
        -: 4223: *   Char v[n];
        -: 4224: *   int n, special_case_0;
        -: 4225: *   cshell( v, n, special_case_0 );
        -: 4226: *
        -: 4227: * description
        -: 4228: *   Does a shell sort of the first n elements of array v.
        -: 4229: *   If special_case_0 is true, then any element equal to 0
        -: 4230: *   is instead assumed to have infinite weight.
        -: 4231: *
        -: 4232: * passed
        -: 4233: *   v - array to be sorted
        -: 4234: *   n - number of elements of v to be sorted
        -: 4235: */
        -: 4236:
    #####: 4237:void cshell( v, n, special_case_0 )
        -: 4238:Char v[];
        -: 4239:int n, special_case_0;
        -: 4240:	{
        -: 4241:	int gap, i, j, jg;
        -: 4242:	Char k;
        -: 4243:
    #####: 4244:	for ( gap = n / 2; gap > 0; gap = gap / 2 )
    #####: 4245:		for ( i = gap; i < n; ++i )
    #####: 4246:			for ( j = i - gap; j >= 0; j = j - gap )
        -: 4247:				{
    #####: 4248:				jg = j + gap;
        -: 4249:
    #####: 4250:				if ( special_case_0 )
        -: 4251:					{
    #####: 4252:					if ( v[jg] == 0 )
    #####: 4253:						break;
        -: 4254:
    #####: 4255:					else if ( v[j] != 0 && v[j] <= v[jg] )
    #####: 4256:						break;
        -: 4257:					}
        -: 4258:
    #####: 4259:				else if ( v[j] <= v[jg] )
    #####: 4260:					break;
        -: 4261:
    #####: 4262:				k = v[j];
    #####: 4263:				v[j] = v[jg];
    #####: 4264:				v[jg] = k;
        -: 4265:				}
    #####: 4266:	}
        -: 4267:
        -: 4268:
        -: 4269:/* dataend - finish up a block of data declarations */
        -: 4270:
        7: 4271:void dataend()
        -: 4272:	{
        7: 4273:	if ( datapos > 0 )
        7: 4274:		dataflush();
        -: 4275:
        -: 4276:	/* add terminator for initialization; { for vi */
        7: 4277:	puts( "    } ;\n" );
        -: 4278:
        7: 4279:	dataline = 0;
        7: 4280:	datapos = 0;
        7: 4281:	}
        -: 4282:
        -: 4283:
        -: 4284:/* dataflush - flush generated data statements */
        -: 4285:
       32: 4286:void dataflush()
        -: 4287:	{
       32: 4288:	putchar( '\n' );
        -: 4289:
       32: 4290:	if ( ++dataline >= NUMDATALINES )
        -: 4291:		{
        -: 4292:		/* Put out a blank line so that the table is grouped into
        -: 4293:		 * large blocks that enable the user to find elements easily.
        -: 4294:		 */
        2: 4295:		putchar( '\n' );
        2: 4296:		dataline = 0;
        -: 4297:		}
        -: 4298:
        -: 4299:	/* Reset the number of characters written on the current line. */
       32: 4300:	datapos = 0;
       32: 4301:	}
        -: 4302:
        -: 4303:
        -: 4304:/* flexerror - report an error message and terminate */
        -: 4305:
    #####: 4306:void flexerror( msg )
        -: 4307:char msg[];
        -: 4308:	{
    #####: 4309:	fprintf( err, "%s: %s\n", program_name, msg );
    #####: 4310:	flexend( 1 );
    #####: 4311:	}
        -: 4312:
        -: 4313:
        -: 4314:/* flexfatal - report a fatal error message and terminate */
        -: 4315:
    #####: 4316:void flexfatal( msg )
        -: 4317:char msg[];
        -: 4318:	{
    #####: 4319:	fprintf( err, "%s: fatal internal error, %s\n", program_name, msg );
    #####: 4320:	exit( 1 );
        -: 4321:	}
        -: 4322:
        -: 4323:
        -: 4324:/* lerrif - report an error message formatted with one integer argument */
        -: 4325:
    #####: 4326:void lerrif( msg, arg )
        -: 4327:char msg[];
        -: 4328:int arg;
        -: 4329:	{
        -: 4330:	char errmsg[MAXLINE];
    #####: 4331:	(void) sprintf( errmsg, msg, arg );
    #####: 4332:	flexerror( errmsg );
    #####: 4333:	}
        -: 4334:
        -: 4335:
        -: 4336:/* lerrsf - report an error message formatted with one string argument */
        -: 4337:
    #####: 4338:void lerrsf( msg, arg )
        -: 4339:char msg[], arg[];
        -: 4340:	{
        -: 4341:	char errmsg[MAXLINE];
        -: 4342:
    #####: 4343:	(void) sprintf( errmsg, msg, arg );
    #####: 4344:	flexerror( errmsg );
    #####: 4345:	}
        -: 4346:
        -: 4347:
        -: 4348:/* htoi - convert a hexadecimal digit string to an integer value */
        -: 4349:
    #####: 4350:int htoi( str )
        -: 4351:Char str[];
        -: 4352:	{
        -: 4353:	unsigned int result;
        -: 4354:
    #####: 4355:	(void) sscanf( (char *) str, "%x", &result );
        -: 4356:
    #####: 4357:	return result;
        -: 4358:	}
        -: 4359:
        -: 4360:
        -: 4361:/* is_hex_digit - returns true if a character is a valid hex digit, false
        -: 4362: *		  otherwise
        -: 4363: */
        -: 4364:
    #####: 4365:int is_hex_digit( ch )
        -: 4366:int ch;
        -: 4367:	{
    #####: 4368:	if ( isdigit( ch ) )
    #####: 4369:		return 1;
        -: 4370:
    #####: 4371:	switch ( clower( ch ) )
        -: 4372:		{
        -: 4373:		case 'a':
        -: 4374:		case 'b':
        -: 4375:		case 'c':
        -: 4376:		case 'd':
        -: 4377:		case 'e':
        -: 4378:		case 'f':
    #####: 4379:			return 1;
        -: 4380:
        -: 4381:		default:
    #####: 4382:			return 0;
        -: 4383:		}
        -: 4384:	}
        -: 4385:
        -: 4386:
        -: 4387:/* line_directive_out - spit out a "# line" statement */
        -: 4388:
        7: 4389:void line_directive_out( output_file )
        -: 4390:FILE *output_file;
        -: 4391:	{
        7: 4392:	if ( infilename && gen_line_dirs )
        -: 4393:		{
        -: 4394:		char directive[MAXLINE];
        7: 4395:		sprintf( directive, "# line %d \"%s\"\n", linenum, infilename );
        -: 4396:
        -: 4397:		/* If output_file is nil then we should put the directive in
        -: 4398:		 * the accumulated actions.
        -: 4399:		 */
        7: 4400:		if ( output_file )
        1: 4401:			fputs( directive, output_file );
        -: 4402:		else
        6: 4403:			add_action( directive );
        -: 4404:		}
        7: 4405:	}
        -: 4406:
        -: 4407:
        -: 4408:/* mark_defs1 - mark the current position in the action array as
        -: 4409: *               representing where the user's section 1 definitions end
        -: 4410: *		 and the prolog begins
        -: 4411: */
        1: 4412:void mark_defs1()
        -: 4413:	{
        1: 4414:	defs1_offset = 0;
        1: 4415:	action_array[action_index++] = '\0';
        1: 4416:	action_offset = prolog_offset = action_index;
        1: 4417:	action_array[action_index] = '\0';
        1: 4418:	}
        -: 4419:
        -: 4420:
        -: 4421:/* mark_prolog - mark the current position in the action array as
        -: 4422: *               representing the end of the action prolog
        -: 4423: */
        1: 4424:void mark_prolog()
        -: 4425:	{
        1: 4426:	action_array[action_index++] = '\0';
        1: 4427:	action_offset = action_index;
        1: 4428:	action_array[action_index] = '\0';
        1: 4429:	}
        -: 4430:
        -: 4431:
        -: 4432:/* mk2data - generate a data statement for a two-dimensional array
        -: 4433: *
        -: 4434: * Generates a data statement initializing the current 2-D array to "value".
        -: 4435: */
    #####: 4436:void mk2data( value )
        -: 4437:int value;
        -: 4438:	{
    #####: 4439:	if ( datapos >= NUMDATAITEMS )
        -: 4440:		{
    #####: 4441:		putchar( ',' );
    #####: 4442:		dataflush();
        -: 4443:		}
        -: 4444:
    #####: 4445:	if ( datapos == 0 )
        -: 4446:		/* Indent. */
    #####: 4447:		fputs( "    ", stdout );
        -: 4448:
        -: 4449:	else
    #####: 4450:		putchar( ',' );
        -: 4451:
    #####: 4452:	++datapos;
        -: 4453:
    #####: 4454:	printf( "%5d", value );
    #####: 4455:	}
        -: 4456:
        -: 4457:
        -: 4458:/* mkdata - generate a data statement
        -: 4459: *
        -: 4460: * Generates a data statement initializing the current array element to
        -: 4461: * "value".
        -: 4462: */
      287: 4463:void mkdata( value )
        -: 4464:int value;
        -: 4465:	{
      287: 4466:	if ( datapos >= NUMDATAITEMS )
        -: 4467:		{
       25: 4468:		putchar( ',' );
       25: 4469:		dataflush();
        -: 4470:		}
        -: 4471:
      287: 4472:	if ( datapos == 0 )
        -: 4473:		/* Indent. */
       32: 4474:		fputs( "    ", stdout );
        -: 4475:	else
      255: 4476:		putchar( ',' );
        -: 4477:
      287: 4478:	++datapos;
        -: 4479:
      287: 4480:	printf( "%5d", value );
      287: 4481:	}
        -: 4482:
        -: 4483:
        -: 4484:/* myctoi - return the integer represented by a string of digits */
        -: 4485:
    #####: 4486:int myctoi( array )
        -: 4487:char array[];
        -: 4488:	{
    #####: 4489:	int val = 0;
        -: 4490:
    #####: 4491:	(void) sscanf( array, "%d", &val );
        -: 4492:
    #####: 4493:	return val;
        -: 4494:	}
        -: 4495:
        -: 4496:
        -: 4497:/* myesc - return character corresponding to escape sequence */
        -: 4498:
    #####: 4499:Char myesc( array )
        -: 4500:Char array[];
        -: 4501:	{
        -: 4502:	Char c, esc_char;
        -: 4503:
    #####: 4504:	switch ( array[1] )
        -: 4505:		{
    #####: 4506:		case 'b': return '\b';
    #####: 4507:		case 'f': return '\f';
    #####: 4508:		case 'n': return '\n';
    #####: 4509:		case 'r': return '\r';
    #####: 4510:		case 't': return '\t';
        -: 4511:
        -: 4512:#ifdef __STDC__
    #####: 4513:		case 'a': return '\a';
    #####: 4514:		case 'v': return '\v';
        -: 4515:#else
        -: 4516:		case 'a': return '\007';
        -: 4517:		case 'v': return '\013';
        -: 4518:#endif
        -: 4519:
        -: 4520:		case '0':
        -: 4521:		case '1':
        -: 4522:		case '2':
        -: 4523:		case '3':
        -: 4524:		case '4':
        -: 4525:		case '5':
        -: 4526:		case '6':
        -: 4527:		case '7':
        -: 4528:		case '8':
        -: 4529:		case '9':
        -: 4530:			{ /* \<octal> */
    #####: 4531:			int sptr = 1;
        -: 4532:
    #####: 4533:			while ( isascii( array[sptr] ) &&
    #####: 4534:				isdigit( array[sptr] ) )
        -: 4535:				/* Don't increment inside loop control
        -: 4536:				 * because if isdigit() is a macro it might
        -: 4537:				 * expand into multiple increments ...
        -: 4538:				 */
    #####: 4539:				++sptr;
        -: 4540:
    #####: 4541:			c = array[sptr];
    #####: 4542:			array[sptr] = '\0';
        -: 4543:
    #####: 4544:			esc_char = otoi( array + 1 );
        -: 4545:
    #####: 4546:			array[sptr] = c;
        -: 4547:
    #####: 4548:			return esc_char;
        -: 4549:			}
        -: 4550:
        -: 4551:		case 'x':
        -: 4552:			{ /* \x<hex> */
    #####: 4553:			int sptr = 2;
        -: 4554:
    #####: 4555:			while ( isascii( array[sptr] ) &&
    #####: 4556:				is_hex_digit( (char) array[sptr] ) )
        -: 4557:				/* Don't increment inside loop control
        -: 4558:				 * because if isdigit() is a macro it might
        -: 4559:				 * expand into multiple increments ...
        -: 4560:				 */
    #####: 4561:				++sptr;
        -: 4562:
    #####: 4563:			c = array[sptr];
    #####: 4564:			array[sptr] = '\0';
        -: 4565:
    #####: 4566:			esc_char = htoi( array + 2 );
        -: 4567:
    #####: 4568:			array[sptr] = c;
        -: 4569:
    #####: 4570:			return esc_char;
        -: 4571:			}
        -: 4572:
        -: 4573:		default:
    #####: 4574:			return array[1];
        -: 4575:		}
        -: 4576:	}
        -: 4577:
        -: 4578:
        -: 4579:/* otoi - convert an octal digit string to an integer value */
        -: 4580:
    #####: 4581:int otoi( str )
        -: 4582:Char str[];
        -: 4583:	{
        -: 4584:	unsigned int result;
        -: 4585:
    #####: 4586:	(void) sscanf( (char *) str, "%o", &result );
    #####: 4587:	return result;
        -: 4588:	}
        -: 4589:
        -: 4590:
        -: 4591:/* readable_form - return the the human-readable form of a character
        -: 4592: *
        -: 4593: * The returned string is in static storage.
        -: 4594: */
        -: 4595:
    #####: 4596:char *readable_form( c )
        -: 4597:register int c;
        -: 4598:	{
        -: 4599:	static char rform[10];
        -: 4600:
    #####: 4601:	if ( (c >= 0 && c < 32) || c >= 127 )
        -: 4602:		{
    #####: 4603:		switch ( c )
        -: 4604:			{
    #####: 4605:			case '\b': return "\\b";
    #####: 4606:			case '\f': return "\\f";
    #####: 4607:			case '\n': return "\\n";
    #####: 4608:			case '\r': return "\\r";
    #####: 4609:			case '\t': return "\\t";
        -: 4610:
        -: 4611:#ifdef __STDC__
    #####: 4612:			case '\a': return "\\a";
    #####: 4613:			case '\v': return "\\v";
        -: 4614:#endif
        -: 4615:
        -: 4616:			default:
    #####: 4617:				(void) sprintf( rform, "\\%.3o",
        -: 4618:						(unsigned int) c );
    #####: 4619:				return rform;
        -: 4620:			}
        -: 4621:		}
        -: 4622:
    #####: 4623:	else if ( c == ' ' )
    #####: 4624:		return "' '";
        -: 4625:
        -: 4626:	else
        -: 4627:		{
    #####: 4628:		rform[0] = c;
    #####: 4629:		rform[1] = '\0';
        -: 4630:
    #####: 4631:		return rform;
        -: 4632:		}
        -: 4633:	}
        -: 4634:
        -: 4635:
        -: 4636:/* reallocate_array - increase the size of a dynamic array */
        -: 4637:
    #####: 4638:void *reallocate_array( array, size, element_size )
        -: 4639:void *array;
        -: 4640:int size, element_size;
        -: 4641:	{
        -: 4642:	register void *new_array;
        -: 4643:
        -: 4644:	/* Same worry as in allocate_array(): */
    #####: 4645:	if ( size * element_size <= 0 )
    #####: 4646:		flexfatal(
        -: 4647:			"attempt to increase array size by less than 1 byte" );
        -: 4648:
    #####: 4649:	new_array = flex_realloc( array, size * element_size );
        -: 4650:
    #####: 4651:	if ( new_array == NULL )
    #####: 4652:		flexfatal( "attempt to increase array size failed" );
        -: 4653:
    #####: 4654:	return new_array;
        -: 4655:	}
        -: 4656:
        -: 4657:
        -: 4658:/* skelout - write out one section of the skeleton file
        -: 4659: *
        -: 4660: * Description
        -: 4661: *    Copies skelfile or skel array to stdout until a line beginning with
        -: 4662: *    "%%" or EOF is found.
        -: 4663: */
       18: 4664:void skelout()
        -: 4665:	{
        -: 4666:	char buf_storage[MAXLINE];
       18: 4667:	char *buf = buf_storage;
       18: 4668:	int do_copy = 1;
        -: 4669:
        -: 4670:	/* Loop pulling lines either from the skelfile, if we're using
        -: 4671:	 * one, or from the skel[] array.
        -: 4672:	 */
     2472: 4673:	while ( skelfile ?
    #####: 4674:		(fgets( buf, MAXLINE, skelfile ) != NULL) :
     1227: 4675:		((buf = skel[skel_ind++]) != 0) )
        -: 4676:		{ /* copy from skel array */
     1226: 4677:		if ( buf[0] == '%' )
        -: 4678:			{ /* control line */
      101: 4679:			switch ( buf[1] )
        -: 4680:				{
        -: 4681:				case '%':
       17: 4682:					return;
        -: 4683:
        -: 4684:				case '+':
       25: 4685:					do_copy = C_plus_plus;
       25: 4686:					break;
        -: 4687:
        -: 4688:				case '-':
       28: 4689:					do_copy = ! C_plus_plus;
       28: 4690:					break;
        -: 4691:
        -: 4692:				case '*':
       31: 4693:					do_copy = 1;
       31: 4694:					break;
        -: 4695:
        -: 4696:				default:
    #####: 4697:					flexfatal(
        -: 4698:						"bad line in skeleton file" );
        -: 4699:				}
        -: 4700:			}
        -: 4701:
     1125: 4702:		else if ( do_copy )
        -: 4703:			{
     1061: 4704:			if ( skelfile )
        -: 4705:				/* Skeleton file reads include final
        -: 4706:				 * newline, skel[] array does not.
        -: 4707:				 */
    #####: 4708:				fputs( buf, stdout );
        -: 4709:			else
     1061: 4710:				printf( "%s\n", buf );
        -: 4711:			}
        -: 4712:		}
        -: 4713:	}
        -: 4714:
        -: 4715:
        -: 4716:/* transition_struct_out - output a yy_trans_info structure
        -: 4717: *
        -: 4718: * outputs the yy_trans_info structure with the two elements, element_v and
        -: 4719: * element_n.  Formats the output with spaces and carriage returns.
        -: 4720: */
        -: 4721:
    #####: 4722:void transition_struct_out( element_v, element_n )
        -: 4723:int element_v, element_n;
        -: 4724:	{
    #####: 4725:	printf( "%7d, %5d,", element_v, element_n );
        -: 4726:
    #####: 4727:	datapos += TRANS_STRUCT_PRINT_LENGTH;
        -: 4728:
    #####: 4729:	if ( datapos >= 75 )
        -: 4730:		{
    #####: 4731:		putchar( '\n' );
        -: 4732:
    #####: 4733:		if ( ++dataline % 10 == 0 )
    #####: 4734:			putchar( '\n' );
        -: 4735:
    #####: 4736:		datapos = 0;
        -: 4737:		}
    #####: 4738:	}
        -: 4739:
        -: 4740:
        -: 4741:/* The following is only needed when building flex's parser using certain
        -: 4742: * broken versions of bison.
        -: 4743: */
    #####: 4744:void *yy_flex_xmalloc( size )
        -: 4745:int size;
        -: 4746:	{
        -: 4747:
        -: 4748:#ifndef F_AA_5
    #####: 4749:	void *result = flex_alloc( size );
        -: 4750:#else
        -: 4751:	void *result = yy_flex_alloc( size );
        -: 4752:#endif
    #####: 4753:	if ( ! result  )
    #####: 4754:		flexfatal( "memory allocation failed in yy_flex_xmalloc()" );
        -: 4755:
    #####: 4756:	return result;
        -: 4757:	}
        -: 4758:
        -: 4759:
        -: 4760:/* zero_out - set a region of memory to 0
        -: 4761: *
        -: 4762: * Sets region_ptr[0] through region_ptr[size_in_bytes - 1] to zero.
        -: 4763: */
        -: 4764:
        1: 4765:void zero_out( region_ptr, size_in_bytes )
        -: 4766:char *region_ptr;
        -: 4767:int size_in_bytes;
        -: 4768:	{
        -: 4769:	register char *rp, *rp_end;
        -: 4770:
        1: 4771:	rp = region_ptr;
        1: 4772:	rp_end = region_ptr + size_in_bytes;
        -: 4773:
     8002: 4774:	while ( rp < rp_end )
     8000: 4775:		*rp++ = 0;
        1: 4776:	}
        -: 4777:/* nfa - NFA construction routines */
        -: 4778:
        -: 4779:/*-
        -: 4780: * Copyright (c) 1990 The Regents of the University of California.
        -: 4781: * All rights reserved.
        -: 4782: *
        -: 4783: * This code is derived from software contributed to Berkeley by
        -: 4784: * Vern Paxson.
        -: 4785: * 
        -: 4786: * The United States Government has rights in this work pursuant
        -: 4787: * to contract no. DE-AC03-76SF00098 between the United States
        -: 4788: * Department of Energy and the University of California.
        -: 4789: *
        -: 4790: * Redistribution and use in source and binary forms are permitted provided
        -: 4791: * that: (1) source distributions retain this entire copyright notice and
        -: 4792: * comment, and (2) distributions including binaries display the following
        -: 4793: * acknowledgement:  ``This product includes software developed by the
        -: 4794: * University of California, Berkeley and its contributors'' in the
        -: 4795: * documentation or other materials provided with the distribution and in
        -: 4796: * all advertising materials mentioning features or use of this software.
        -: 4797: * Neither the name of the University nor the names of its contributors may
        -: 4798: * be used to endorse or promote products derived from this software without
        -: 4799: * specific prior written permission.
        -: 4800: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 4801: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 4802: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 4803: */
        -: 4804:
        -: 4805:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 4806:
        -: 4807:
        -: 4808:
        -: 4809:/* declare functions that have forward references */
        -: 4810:
        -: 4811:int dupmachine PROTO((int));
        -: 4812:void mkxtion PROTO((int, int));
        -: 4813:
        -: 4814:
        -: 4815:/* add_accept - add an accepting state to a machine
        -: 4816: *
        -: 4817: * accepting_number becomes mach's accepting number.
        -: 4818: */
        -: 4819:
        1: 4820:void add_accept( mach, accepting_number )
        -: 4821:int mach, accepting_number;
        -: 4822:	{
        -: 4823:	/* Hang the accepting number off an epsilon state.  if it is associated
        -: 4824:	 * with a state that has a non-epsilon out-transition, then the state
        -: 4825:	 * will accept BEFORE it makes that transition, i.e., one character
        -: 4826:	 * too soon.
        -: 4827:	 */
        -: 4828:
        1: 4829:	if ( transchar[finalst[mach]] == SYM_EPSILON )
    #####: 4830:		accptnum[finalst[mach]] = accepting_number;
        -: 4831:
        -: 4832:	else
        -: 4833:		{
        1: 4834:		int astate = mkstate( SYM_EPSILON );
        1: 4835:		accptnum[astate] = accepting_number;
        1: 4836:		(void) link_machines( mach, astate );
        -: 4837:		}
        1: 4838:	}
        -: 4839:
        -: 4840:
        -: 4841:/* copysingl - make a given number of copies of a singleton machine
        -: 4842: *
        -: 4843: * synopsis
        -: 4844: *
        -: 4845: *   newsng = copysingl( singl, num );
        -: 4846: *
        -: 4847: *     newsng - a new singleton composed of num copies of singl
        -: 4848: *     singl  - a singleton machine
        -: 4849: *     num    - the number of copies of singl to be present in newsng
        -: 4850: */
        -: 4851:
    #####: 4852:int copysingl( singl, num )
        -: 4853:int singl, num;
        -: 4854:	{
        -: 4855:	int copy, i;
        -: 4856:
    #####: 4857:	copy = mkstate( SYM_EPSILON );
        -: 4858:
    #####: 4859:	for ( i = 1; i <= num; ++i )
    #####: 4860:		copy = link_machines( copy, dupmachine( singl ) );
        -: 4861:
    #####: 4862:	return copy;
        -: 4863:	}
        -: 4864:
        -: 4865:
        -: 4866:/* dumpnfa - debugging routine to write out an nfa */
        -: 4867:
    #####: 4868:void dumpnfa( state1 )
        -: 4869:int state1;
        -: 4870:
        -: 4871:	{
        -: 4872:	int sym, tsp1, tsp2, anum, ns;
        -: 4873:
    #####: 4874:	fprintf( err,
        -: 4875:		"\n\n********** beginning dump of nfa with start state %d\n",
        -: 4876:		state1 );
        -: 4877:
        -: 4878:	/* We probably should loop starting at firstst[state1] and going to
        -: 4879:	 * lastst[state1], but they're not maintained properly when we "or"
        -: 4880:	 * all of the rules together.  So we use our knowledge that the machine
        -: 4881:	 * starts at state 1 and ends at lastnfa.
        -: 4882:	 */
        -: 4883:
        -: 4884:	/* for ( ns = firstst[state1]; ns <= lastst[state1]; ++ns ) */
    #####: 4885:	for ( ns = 1; ns <= lastnfa; ++ns )
        -: 4886:		{
    #####: 4887:		fprintf( err, "state # %4d\t", ns );
        -: 4888:
    #####: 4889:		sym = transchar[ns];
    #####: 4890:		tsp1 = trans1[ns];
    #####: 4891:		tsp2 = trans2[ns];
    #####: 4892:		anum = accptnum[ns];
        -: 4893:
    #####: 4894:		fprintf( err, "%3d:  %4d, %4d", sym, tsp1, tsp2 );
        -: 4895:
    #####: 4896:		if ( anum != NIL )
    #####: 4897:			fprintf( err, "  [%d]", anum );
        -: 4898:
    #####: 4899:		fprintf( err, "\n" );
        -: 4900:		}
        -: 4901:
    #####: 4902:	fprintf( err, "********** end of dump\n" );
    #####: 4903:	}
        -: 4904:
        -: 4905:
        -: 4906:/* dupmachine - make a duplicate of a given machine
        -: 4907: *
        -: 4908: * synopsis
        -: 4909: *
        -: 4910: *   copy = dupmachine( mach );
        -: 4911: *
        -: 4912: *     copy - holds duplicate of mach
        -: 4913: *     mach - machine to be duplicated
        -: 4914: *
        -: 4915: * note that the copy of mach is NOT an exact duplicate; rather, all the
        -: 4916: * transition states values are adjusted so that the copy is self-contained,
        -: 4917: * as the original should have been.
        -: 4918: *
        -: 4919: * also note that the original MUST be contiguous, with its low and high
        -: 4920: * states accessible by the arrays firstst and lastst
        -: 4921: */
        -: 4922:
    #####: 4923:int dupmachine( mach )
        -: 4924:int mach;
        -: 4925:	{
        -: 4926:	int i, init, state_offset;
    #####: 4927:	int state = 0;
    #####: 4928:	int last = lastst[mach];
        -: 4929:
    #####: 4930:	for ( i = firstst[mach]; i <= last; ++i )
        -: 4931:		{
    #####: 4932:		state = mkstate( transchar[i] );
        -: 4933:
    #####: 4934:		if ( trans1[i] != NO_TRANSITION )
        -: 4935:			{
    #####: 4936:			mkxtion( finalst[state], trans1[i] + state - i );
        -: 4937:
    #####: 4938:			if ( transchar[i] == SYM_EPSILON &&
    #####: 4939:			     trans2[i] != NO_TRANSITION )
    #####: 4940:				mkxtion( finalst[state],
    #####: 4941:					trans2[i] + state - i );
        -: 4942:			}
        -: 4943:
    #####: 4944:		accptnum[state] = accptnum[i];
        -: 4945:		}
        -: 4946:
    #####: 4947:	if ( state == 0 )
    #####: 4948:		flexfatal( "empty machine in dupmachine()" );
        -: 4949:
    #####: 4950:	state_offset = state - i + 1;
        -: 4951:
    #####: 4952:	init = mach + state_offset;
    #####: 4953:	firstst[init] = firstst[mach] + state_offset;
    #####: 4954:	finalst[init] = finalst[mach] + state_offset;
    #####: 4955:	lastst[init] = lastst[mach] + state_offset;
        -: 4956:
    #####: 4957:	return init;
        -: 4958:	}
        -: 4959:
        -: 4960:
        -: 4961:/* finish_rule - finish up the processing for a rule
        -: 4962: *
        -: 4963: * An accepting number is added to the given machine.  If variable_trail_rule
        -: 4964: * is true then the rule has trailing context and both the head and trail
        -: 4965: * are variable size.  Otherwise if headcnt or trailcnt is non-zero then
        -: 4966: * the machine recognizes a pattern with trailing context and headcnt is
        -: 4967: * the number of characters in the matched part of the pattern, or zero
        -: 4968: * if the matched part has variable length.  trailcnt is the number of
        -: 4969: * trailing context characters in the pattern, or zero if the trailing
        -: 4970: * context has variable length.
        -: 4971: */
        -: 4972:
        1: 4973:void finish_rule( mach, variable_trail_rule, headcnt, trailcnt )
        -: 4974:int mach, variable_trail_rule, headcnt, trailcnt;
        -: 4975:	{
        -: 4976:	char action_text[MAXLINE];
        -: 4977:
        1: 4978:	add_accept( mach, num_rules );
        -: 4979:
        -: 4980:	/* We did this in new_rule(), but it often gets the wrong
        -: 4981:	 * number because we do it before we start parsing the current rule.
        -: 4982:	 */
        1: 4983:	rule_linenum[num_rules] = linenum;
        -: 4984:
        -: 4985:	/* If this is a continued action, then the line-number has already
        -: 4986:	 * been updated, giving us the wrong number.
        -: 4987:	 */
        1: 4988:	if ( continued_action )
    #####: 4989:		--rule_linenum[num_rules];
        -: 4990:
        1: 4991:	sprintf( action_text, "case %d:\n", num_rules );
        1: 4992:	add_action( action_text );
        -: 4993:
        1: 4994:	if ( variable_trail_rule )
        -: 4995:		{
    #####: 4996:		rule_type[num_rules] = RULE_VARIABLE;
        -: 4997:
    #####: 4998:		if ( performance_report > 0 )
    #####: 4999:			fprintf( err,
        -: 5000:				"Variable trailing context rule at line %d\n",
    #####: 5001:				rule_linenum[num_rules] );
        -: 5002:
    #####: 5003:		variable_trailing_context_rules = true;
        -: 5004:		}
        -: 5005:
        -: 5006:	else
        -: 5007:		{
        1: 5008:		rule_type[num_rules] = RULE_NORMAL;
        -: 5009:
        1: 5010:		if ( headcnt > 0 || trailcnt > 0 )
        -: 5011:			{
        -: 5012:			/* Do trailing context magic to not match the trailing
        -: 5013:			 * characters.
        -: 5014:			 */
    #####: 5015:			char *scanner_cp = "yy_c_buf_p = yy_cp";
    #####: 5016:			char *scanner_bp = "yy_bp";
        -: 5017:
    #####: 5018:			add_action(
        -: 5019:	"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\n" );
        -: 5020:
    #####: 5021:			if ( headcnt > 0 )
        -: 5022:				{
    #####: 5023:				sprintf( action_text, "%s = %s + %d;\n",
        -: 5024:				scanner_cp, scanner_bp, headcnt );
    #####: 5025:				add_action( action_text );
        -: 5026:				}
        -: 5027:
        -: 5028:			else
        -: 5029:				{
    #####: 5030:				sprintf( action_text, "%s -= %d;\n",
        -: 5031:					scanner_cp, trailcnt );
    #####: 5032:				add_action( action_text );
        -: 5033:				}
        -: 5034:
    #####: 5035:			add_action(
        -: 5036:			"YY_DO_BEFORE_ACTION; /* set up yytext again */\n" );
        -: 5037:			}
        -: 5038:		}
        -: 5039:
        -: 5040:	/* Okay, in the action code at this point yytext and yyleng have
        -: 5041:	 * their proper final values for this rule, so here's the point
        -: 5042:	 * to do any user action.  But don't do it for continued actions,
        -: 5043:	 * as that'll result in multiple YY_USER_ACTION's.
        -: 5044:	 */
        -: 5045:#ifndef F_AA_1	
        1: 5046:	if ( ! continued_action )
        -: 5047:#else 
        -: 5048:	if ( continued_action )
        -: 5049:#endif
        -: 5050:#ifndef F_JR_2
        1: 5051:        add_action( "YY_USER_ACTION\n" );
        -: 5052:#else
        -: 5053:        add_action( "YY_USER_ACTION" );
        -: 5054:#endif
        -: 5055:
        1: 5056:	line_directive_out( (FILE *) 0 );
        1: 5057:	}
        -: 5058:
        -: 5059:
        -: 5060:/* link_machines - connect two machines together
        -: 5061: *
        -: 5062: * synopsis
        -: 5063: *
        -: 5064: *   new = link_machines( first, last );
        -: 5065: *
        -: 5066: *     new    - a machine constructed by connecting first to last
        -: 5067: *     first  - the machine whose successor is to be last
        -: 5068: *     last   - the machine whose predecessor is to be first
        -: 5069: *
        -: 5070: * note: this routine concatenates the machine first with the machine
        -: 5071: *  last to produce a machine new which will pattern-match first first
        -: 5072: *  and then last, and will fail if either of the sub-patterns fails.
        -: 5073: *  FIRST is set to new by the operation.  last is unmolested.
        -: 5074: */
        -: 5075:
        1: 5076:int link_machines( first, last )
        -: 5077:int first, last;
        -: 5078:	{
        1: 5079:	if ( first == NIL )
    #####: 5080:		return last;
        -: 5081:
        1: 5082:	else if ( last == NIL )
    #####: 5083:		return first;
        -: 5084:
        -: 5085:	else
        -: 5086:		{
        1: 5087:		mkxtion( finalst[first], last );
        1: 5088:		finalst[first] = finalst[last];
        1: 5089:		lastst[first] = MAX( lastst[first], lastst[last] );
        1: 5090:		firstst[first] = MIN( firstst[first], firstst[last] );
        -: 5091:
        1: 5092:		return first;
        -: 5093:		}
        -: 5094:	}
        -: 5095:
        -: 5096:
        -: 5097:/* mark_beginning_as_normal - mark each "beginning" state in a machine
        -: 5098: *                            as being a "normal" (i.e., not trailing context-
        -: 5099: *                            associated) states
        -: 5100: *
        -: 5101: * The "beginning" states are the epsilon closure of the first state
        -: 5102: */
        -: 5103:
    #####: 5104:void mark_beginning_as_normal( mach )
        -: 5105:register int mach;
        -: 5106:	{
    #####: 5107:	switch ( state_type[mach] )
        -: 5108:		{
        -: 5109:		case STATE_NORMAL:
        -: 5110:			/* Oh, we've already visited here. */
    #####: 5111:			return;
        -: 5112:
        -: 5113:		case STATE_TRAILING_CONTEXT:
    #####: 5114:			state_type[mach] = STATE_NORMAL;
        -: 5115:
    #####: 5116:			if ( transchar[mach] == SYM_EPSILON )
        -: 5117:				{
    #####: 5118:				if ( trans1[mach] != NO_TRANSITION )
    #####: 5119:					mark_beginning_as_normal(
    #####: 5120:						trans1[mach] );
        -: 5121:
    #####: 5122:				if ( trans2[mach] != NO_TRANSITION )
    #####: 5123:					mark_beginning_as_normal(
    #####: 5124:						trans2[mach] );
        -: 5125:				}
    #####: 5126:			break;
        -: 5127:
        -: 5128:		default:
    #####: 5129:			flexerror(
        -: 5130:				"bad state type in mark_beginning_as_normal()" );
    #####: 5131:			break;
        -: 5132:		}
        -: 5133:	}
        -: 5134:
        -: 5135:
        -: 5136:/* mkbranch - make a machine that branches to two machines
        -: 5137: *
        -: 5138: * synopsis
        -: 5139: *
        -: 5140: *   branch = mkbranch( first, second );
        -: 5141: *
        -: 5142: *     branch - a machine which matches either first's pattern or second's
        -: 5143: *     first, second - machines whose patterns are to be or'ed (the | operator)
        -: 5144: *
        -: 5145: * Note that first and second are NEITHER destroyed by the operation.  Also,
        -: 5146: * the resulting machine CANNOT be used with any other "mk" operation except
        -: 5147: * more mkbranch's.  Compare with mkor()
        -: 5148: */
        -: 5149:
        4: 5150:int mkbranch( first, second )
        -: 5151:int first, second;
        -: 5152:	{
        -: 5153:	int eps;
        -: 5154:
        4: 5155:	if ( first == NO_TRANSITION )
    #####: 5156:		return second;
        -: 5157:
        4: 5158:	else if ( second == NO_TRANSITION )
    #####: 5159:		return first;
        -: 5160:
        4: 5161:	eps = mkstate( SYM_EPSILON );
        -: 5162:
        4: 5163:	mkxtion( eps, first );
        4: 5164:	mkxtion( eps, second );
        -: 5165:
        4: 5166:	return eps;
        -: 5167:	}
        -: 5168:
        -: 5169:
        -: 5170:/* mkclos - convert a machine into a closure
        -: 5171: *
        -: 5172: * synopsis
        -: 5173: *   new = mkclos( state );
        -: 5174: *
        -: 5175: * new - a new state which matches the closure of "state"
        -: 5176: */
        -: 5177:
    #####: 5178:int mkclos( state )
        -: 5179:int state;
        -: 5180:	{
    #####: 5181:	return mkopt( mkposcl( state ) );
        -: 5182:	}
        -: 5183:
        -: 5184:
        -: 5185:/* mkopt - make a machine optional
        -: 5186: *
        -: 5187: * synopsis
        -: 5188: *
        -: 5189: *   new = mkopt( mach );
        -: 5190: *
        -: 5191: *     new  - a machine which optionally matches whatever mach matched
        -: 5192: *     mach - the machine to make optional
        -: 5193: *
        -: 5194: * notes:
        -: 5195: *     1. mach must be the last machine created
        -: 5196: *     2. mach is destroyed by the call
        -: 5197: */
        -: 5198:
    #####: 5199:int mkopt( mach )
        -: 5200:int mach;
        -: 5201:	{
        -: 5202:	int eps;
        -: 5203:
    #####: 5204:	if ( ! SUPER_FREE_EPSILON(finalst[mach]) )
        -: 5205:		{
    #####: 5206:		eps = mkstate( SYM_EPSILON );
    #####: 5207:		mach = link_machines( mach, eps );
        -: 5208:		}
        -: 5209:
        -: 5210:	/* Can't skimp on the following if FREE_EPSILON(mach) is true because
        -: 5211:	 * some state interior to "mach" might point back to the beginning
        -: 5212:	 * for a closure.
        -: 5213:	 */
    #####: 5214:	eps = mkstate( SYM_EPSILON );
    #####: 5215:	mach = link_machines( eps, mach );
        -: 5216:
    #####: 5217:	mkxtion( mach, finalst[mach] );
        -: 5218:
    #####: 5219:	return mach;
        -: 5220:	}
        -: 5221:
        -: 5222:
        -: 5223:/* mkor - make a machine that matches either one of two machines
        -: 5224: *
        -: 5225: * synopsis
        -: 5226: *
        -: 5227: *   new = mkor( first, second );
        -: 5228: *
        -: 5229: *     new - a machine which matches either first's pattern or second's
        -: 5230: *     first, second - machines whose patterns are to be or'ed (the | operator)
        -: 5231: *
        -: 5232: * note that first and second are both destroyed by the operation
        -: 5233: * the code is rather convoluted because an attempt is made to minimize
        -: 5234: * the number of epsilon states needed
        -: 5235: */
        -: 5236:
    #####: 5237:int mkor( first, second )
        -: 5238:int first, second;
        -: 5239:	{
        -: 5240:	int eps, orend;
        -: 5241:
    #####: 5242:	if ( first == NIL )
    #####: 5243:		return second;
        -: 5244:
    #####: 5245:	else if ( second == NIL )
    #####: 5246:		return first;
        -: 5247:
        -: 5248:	else
        -: 5249:		{
        -: 5250:		/* See comment in mkopt() about why we can't use the first
        -: 5251:		 * state of "first" or "second" if they satisfy "FREE_EPSILON".
        -: 5252:		 */
    #####: 5253:		eps = mkstate( SYM_EPSILON );
        -: 5254:
    #####: 5255:		first = link_machines( eps, first );
        -: 5256:
    #####: 5257:		mkxtion( first, second );
        -: 5258:
    #####: 5259:		if ( SUPER_FREE_EPSILON(finalst[first]) &&
    #####: 5260:		     accptnum[finalst[first]] == NIL )
        -: 5261:			{
    #####: 5262:			orend = finalst[first];
    #####: 5263:			mkxtion( finalst[second], orend );
        -: 5264:			}
        -: 5265:
    #####: 5266:		else if ( SUPER_FREE_EPSILON(finalst[second]) &&
    #####: 5267:			  accptnum[finalst[second]] == NIL )
        -: 5268:			{
    #####: 5269:			orend = finalst[second];
    #####: 5270:			mkxtion( finalst[first], orend );
        -: 5271:			}
        -: 5272:
        -: 5273:		else
        -: 5274:			{
    #####: 5275:			eps = mkstate( SYM_EPSILON );
        -: 5276:
    #####: 5277:			first = link_machines( first, eps );
    #####: 5278:			orend = finalst[first];
        -: 5279:
    #####: 5280:			mkxtion( finalst[second], orend );
        -: 5281:			}
        -: 5282:		}
        -: 5283:
    #####: 5284:	finalst[first] = orend;
    #####: 5285:	return first;
        -: 5286:	}
        -: 5287:
        -: 5288:
        -: 5289:/* mkposcl - convert a machine into a positive closure
        -: 5290: *
        -: 5291: * synopsis
        -: 5292: *   new = mkposcl( state );
        -: 5293: *
        -: 5294: *    new - a machine matching the positive closure of "state"
        -: 5295: */
        -: 5296:
    #####: 5297:int mkposcl( state )
        -: 5298:int state;
        -: 5299:	{
        -: 5300:	int eps;
        -: 5301:
    #####: 5302:	if ( SUPER_FREE_EPSILON(finalst[state]) )
        -: 5303:		{
    #####: 5304:		mkxtion( finalst[state], state );
    #####: 5305:		return state;
        -: 5306:		}
        -: 5307:
        -: 5308:	else
        -: 5309:		{
    #####: 5310:		eps = mkstate( SYM_EPSILON );
    #####: 5311:		mkxtion( eps, state );
    #####: 5312:		return link_machines( state, eps );
        -: 5313:		}
        -: 5314:	}
        -: 5315:
        -: 5316:
        -: 5317:/* mkrep - make a replicated machine
        -: 5318: *
        -: 5319: * synopsis
        -: 5320: *   new = mkrep( mach, lb, ub );
        -: 5321: *
        -: 5322: *    new - a machine that matches whatever "mach" matched from "lb"
        -: 5323: *          number of times to "ub" number of times
        -: 5324: *
        -: 5325: * note
        -: 5326: *   if "ub" is INFINITY then "new" matches "lb" or more occurrences of "mach"
        -: 5327: */
        -: 5328:
    #####: 5329:int mkrep( mach, lb, ub )
        -: 5330:int mach, lb, ub;
        -: 5331:	{
        -: 5332:	int base_mach, tail, copy, i;
        -: 5333:
    #####: 5334:	base_mach = copysingl( mach, lb - 1 );
        -: 5335:
    #####: 5336:	if ( ub == INFINITY )
        -: 5337:		{
    #####: 5338:		copy = dupmachine( mach );
    #####: 5339:		mach = link_machines( mach,
        -: 5340:		link_machines( base_mach, mkclos( copy ) ) );
        -: 5341:		}
        -: 5342:
        -: 5343:	else
        -: 5344:		{
    #####: 5345:		tail = mkstate( SYM_EPSILON );
        -: 5346:
    #####: 5347:		for ( i = lb; i < ub; ++i )
        -: 5348:			{
    #####: 5349:			copy = dupmachine( mach );
    #####: 5350:			tail = mkopt( link_machines( copy, tail ) );
        -: 5351:			}
        -: 5352:
    #####: 5353:		mach = link_machines( mach, link_machines( base_mach, tail ) );
        -: 5354:		}
        -: 5355:
    #####: 5356:	return mach;
        -: 5357:	}
        -: 5358:
        -: 5359:
        -: 5360:/* mkstate - create a state with a transition on a given symbol
        -: 5361: *
        -: 5362: * synopsis
        -: 5363: *
        -: 5364: *   state = mkstate( sym );
        -: 5365: *
        -: 5366: *     state - a new state matching sym
        -: 5367: *     sym   - the symbol the new state is to have an out-transition on
        -: 5368: *
        -: 5369: * note that this routine makes new states in ascending order through the
        -: 5370: * state array (and increments LASTNFA accordingly).  The routine DUPMACHINE
        -: 5371: * relies on machines being made in ascending order and that they are
        -: 5372: * CONTIGUOUS.  Change it and you will have to rewrite DUPMACHINE (kludge
        -: 5373: * that it admittedly is)
        -: 5374: */
        -: 5375:
       10: 5376:int mkstate( sym )
        -: 5377:int sym;
        -: 5378:	{
       10: 5379:	if ( ++lastnfa >= current_mns )
        -: 5380:		{
    #####: 5381:		if ( (current_mns += MNS_INCREMENT) >= MAXIMUM_MNS )
    #####: 5382:			lerrif(
        -: 5383:			"input rules are too complicated (>= %d NFA states)",
        -: 5384:				current_mns );
        -: 5385:
    #####: 5386:		++num_reallocs;
        -: 5387:
    #####: 5388:		firstst = reallocate_integer_array( firstst, current_mns );
    #####: 5389:		lastst = reallocate_integer_array( lastst, current_mns );
    #####: 5390:		finalst = reallocate_integer_array( finalst, current_mns );
    #####: 5391:		transchar = reallocate_integer_array( transchar, current_mns );
    #####: 5392:		trans1 = reallocate_integer_array( trans1, current_mns );
    #####: 5393:		trans2 = reallocate_integer_array( trans2, current_mns );
    #####: 5394:		accptnum = reallocate_integer_array( accptnum, current_mns );
    #####: 5395:		assoc_rule =
    #####: 5396:			reallocate_integer_array( assoc_rule, current_mns );
    #####: 5397:		state_type =
    #####: 5398:			reallocate_integer_array( state_type, current_mns );
        -: 5399:		}
        -: 5400:
       10: 5401:	firstst[lastnfa] = lastnfa;
       10: 5402:	finalst[lastnfa] = lastnfa;
       10: 5403:	lastst[lastnfa] = lastnfa;
       10: 5404:	transchar[lastnfa] = sym;
       10: 5405:	trans1[lastnfa] = NO_TRANSITION;
       10: 5406:	trans2[lastnfa] = NO_TRANSITION;
       10: 5407:	accptnum[lastnfa] = NIL;
       10: 5408:	assoc_rule[lastnfa] = num_rules;
       10: 5409:	state_type[lastnfa] = current_state_type;
        -: 5410:
        -: 5411:	/* Fix up equivalence classes base on this transition.  Note that any
        -: 5412:	 * character which has its own transition gets its own equivalence
        -: 5413:	 * class.  Thus only characters which are only in character classes
        -: 5414:	 * have a chance at being in the same equivalence class.  E.g. "a|b"
        -: 5415:	 * puts 'a' and 'b' into two different equivalence classes.  "[ab]"
        -: 5416:	 * puts them in the same equivalence class (barring other differences
        -: 5417:	 * elsewhere in the input).
        -: 5418:	 */
        -: 5419:
       10: 5420:	if ( sym < 0 )
        -: 5421:		{
        -: 5422:		/* We don't have to update the equivalence classes since
        -: 5423:		 * that was already done when the ccl was created for the
        -: 5424:		 * first time.
        -: 5425:		 */
        -: 5426:		}
        -: 5427:
        9: 5428:	else if ( sym == SYM_EPSILON )
        9: 5429:		++numeps;
        -: 5430:
        -: 5431:	else
        -: 5432:		{
    #####: 5433:		check_char( sym );
        -: 5434:
    #####: 5435:		if ( useecs )
        -: 5436:			/* Map NUL's to csize. */
    #####: 5437:			mkechar( sym ? sym : csize, nextecm, ecgroup );
        -: 5438:		}
        -: 5439:
       10: 5440:	return lastnfa;
        -: 5441:	}
        -: 5442:
        -: 5443:
        -: 5444:/* mkxtion - make a transition from one state to another
        -: 5445: *
        -: 5446: * synopsis
        -: 5447: *
        -: 5448: *   mkxtion( statefrom, stateto );
        -: 5449: *
        -: 5450: *     statefrom - the state from which the transition is to be made
        -: 5451: *     stateto   - the state to which the transition is to be made
        -: 5452: */
        -: 5453:
        9: 5454:void mkxtion( statefrom, stateto )
        -: 5455:int statefrom, stateto;
        -: 5456:	{
        9: 5457:	if ( trans1[statefrom] == NO_TRANSITION )
        5: 5458:		trans1[statefrom] = stateto;
        -: 5459:
        8: 5460:	else if ( (transchar[statefrom] != SYM_EPSILON) ||
        4: 5461:		  (trans2[statefrom] != NO_TRANSITION) )
    #####: 5462:		flexfatal( "found too many transitions in mkxtion()" );
        -: 5463:
        -: 5464:	else
        -: 5465:		{ /* second out-transition for an epsilon state */
        4: 5466:		++eps2;
        4: 5467:		trans2[statefrom] = stateto;
        -: 5468:		}
        9: 5469:	}
        -: 5470:
        -: 5471:/* new_rule - initialize for a new rule */
        -: 5472:
        4: 5473:void new_rule()
        -: 5474:	{
        4: 5475:	if ( ++num_rules >= current_max_rules )
        -: 5476:		{
    #####: 5477:		++num_reallocs;
    #####: 5478:		current_max_rules += MAX_RULES_INCREMENT;
    #####: 5479:		rule_type = reallocate_integer_array( rule_type,
        -: 5480:							current_max_rules );
    #####: 5481:		rule_linenum = reallocate_integer_array( rule_linenum,
        -: 5482:							current_max_rules );
    #####: 5483:		rule_useful = reallocate_integer_array( rule_useful,
        -: 5484:							current_max_rules );
        -: 5485:		}
        -: 5486:
        4: 5487:	if ( num_rules > MAX_RULE )
    #####: 5488:		lerrif( "too many rules (> %d)!", MAX_RULE );
        -: 5489:
        4: 5490:	rule_linenum[num_rules] = linenum;
        4: 5491:	rule_useful[num_rules] = false;
        4: 5492:	}
        -: 5493:/* File created from flex.skel via mkskel.sh */
        -: 5494:
        -: 5495:
        -: 5496:char *skel[] = {
        -: 5497:  "/* A lexical scanner generated by flex */",
        -: 5498:  "",
        -: 5499:  "/* Scanner skeleton version:",
        -: 5500:  " * $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $",
        -: 5501:  " */",
        -: 5502:  "",
        -: 5503:  "#define FLEX_SCANNER",
        -: 5504:  "",
        -: 5505:  "%-",
        -: 5506:  "#include <stdio.h>",
        -: 5507:  "%*",
        -: 5508:  "",
        -: 5509:  "",
        -: 5510:  "/* cfront 1.2 defines \"c_plusplus\" instead of \"__cplusplus\" */",
        -: 5511:  "#ifdef c_plusplus",
        -: 5512:  "#ifndef __cplusplus",
        -: 5513:  "#define __cplusplus",
        -: 5514:  "#endif",
        -: 5515:  "#endif",
        -: 5516:  "",
        -: 5517:  "",
        -: 5518:  "#ifdef __cplusplus",
        -: 5519:  "",
        -: 5520:  "#include <stdlib.h>",
        -: 5521:  "%+",
        -: 5522:  "class istream;",
        -: 5523:  "%*",
        -: 5524:  "#include <unistd.h>",
        -: 5525:  "",
        -: 5526:  "/* Use prototypes in function declarations. */",
        -: 5527:  "#define YY_USE_PROTOS",
        -: 5528:  "",
        -: 5529:  "/* The \"const\" storage-class-modifier is valid. */",
        -: 5530:  "#define YY_USE_CONST",
        -: 5531:  "",
        -: 5532:  "#else	/* ! __cplusplus */",
        -: 5533:  "",
        -: 5534:  "#ifdef __STDC__",
        -: 5535:  "",
        -: 5536:  "#define YY_USE_PROTOS",
        -: 5537:  "#define YY_USE_CONST",
        -: 5538:  "",
        -: 5539:  "#endif	/* __STDC__ */",
        -: 5540:  "#endif	/* ! __cplusplus */",
        -: 5541:  "",
        -: 5542:  "",
        -: 5543:  "#ifdef __TURBOC__",
        -: 5544:  "#define YY_USE_CONST",
        -: 5545:  "#endif",
        -: 5546:  "",
        -: 5547:  "",
        -: 5548:  "#ifndef YY_USE_CONST",
        -: 5549:  "#ifndef const",
        -: 5550:  "#define const",
        -: 5551:  "#endif",
        -: 5552:  "#endif",
        -: 5553:  "",
        -: 5554:  "",
        -: 5555:  "#ifdef YY_USE_PROTOS",
        -: 5556:  "#define YY_PROTO(proto) proto",
        -: 5557:  "#else",
        -: 5558:  "#define YY_PROTO(proto) ()",
        -: 5559:  "#endif",
        -: 5560:  "",
        -: 5561:  "/* Returned upon end-of-file. */",
        -: 5562:  "#define YY_NULL 0",
        -: 5563:  "",
        -: 5564:  "/* Promotes a possibly negative, possibly signed char to an unsigned",
        -: 5565:  " * integer for use as an array index.  If the signed char is negative,",
        -: 5566:  " * we want to instead treat it as an 8-bit unsigned char, hence the",
        -: 5567:  " * double cast.",
        -: 5568:  " */",
        -: 5569:  "#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)",
        -: 5570:  "",
        -: 5571:  "/* Enter a start condition.  This macro really ought to take a parameter,",
        -: 5572:  " * but we do it the disgusting crufty way forced on us by the ()-less",
        -: 5573:  " * definition of BEGIN.",
        -: 5574:  " */",
        -: 5575:  "#define BEGIN yy_start = 1 + 2 *",
        -: 5576:  "",
        -: 5577:  "/* Translate the current start state into a value that can be later handed",
        -: 5578:  " * to BEGIN to return to the state.",
        -: 5579:  " */",
        -: 5580:  "#define YY_START ((yy_start - 1) / 2)",
        -: 5581:  "",
        -: 5582:  "/* Action number for EOF rule of a given start state. */",
        -: 5583:  "#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)",
        -: 5584:  "",
        -: 5585:  "/* Special action meaning \"start processing a new file\".  Now included",
        -: 5586:  " * only for backward compatibility with previous versions of flex.",
        -: 5587:  " */",
        -: 5588:  "#define YY_NEW_FILE yyrestart( yyin )",
        -: 5589:  "",
        -: 5590:  "#define YY_END_OF_BUFFER_CHAR 0",
        -: 5591:  "",
        -: 5592:  "/* Size of default input buffer. */",
        -: 5593:  "#define YY_BUF_SIZE 16384",
        -: 5594:  "",
        -: 5595:  "typedef struct yy_buffer_state *YY_BUFFER_STATE;",
        -: 5596:  "",
        -: 5597:  "extern int yyleng;",
        -: 5598:  "%-",
        -: 5599:  "extern FILE *yyin, *yyout;",
        -: 5600:  "%*",
        -: 5601:  "",
        -: 5602:  "#ifdef __cplusplus",
        -: 5603:  "extern \"C\" {",
        -: 5604:  "#endif",
        -: 5605:  "	extern int yywrap YY_PROTO(( void ));",
        -: 5606:  "#ifdef __cplusplus",
        -: 5607:  "	}",
        -: 5608:  "#endif",
        -: 5609:  "",
        -: 5610:  "#define EOB_ACT_CONTINUE_SCAN 0",
        -: 5611:  "#define EOB_ACT_END_OF_FILE 1",
        -: 5612:  "#define EOB_ACT_LAST_MATCH 2",
        -: 5613:  "",
        -: 5614:  "/* The funky do-while in the following #define is used to turn the definition",
        -: 5615:  " * int a single C statement (which needs a semi-colon terminator).  This",
        -: 5616:  " * avoids problems with code like:",
        -: 5617:  " *",
        -: 5618:  " * 	if ( condition_holds )",
        -: 5619:  " *		yyless( 5 );",
        -: 5620:  " *	else",
        -: 5621:  " *		do_something_else();",
        -: 5622:  " *",
        -: 5623:  " * Prior to using the do-while the compiler would get upset at the",
        -: 5624:  " * \"else\" because it interpreted the \"if\" statement as being all",
        -: 5625:  " * done when it reached the ';' after the yyless() call.",
        -: 5626:  " */",
        -: 5627:  "",
        -: 5628:  "/* Return all but the first 'n' matched characters back to the input stream. */",
        -: 5629:  "",
        -: 5630:  "#define yyless(n) \\",
        -: 5631:  "	do \\",
        -: 5632:  "		{ \\",
        -: 5633:  "		/* Undo effects of setting up yytext. */ \\",
        -: 5634:  "		*yy_cp = yy_hold_char; \\",
        -: 5635:  "		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \\",
        -: 5636:  "		YY_DO_BEFORE_ACTION; /* set up yytext again */ \\",
        -: 5637:  "		} \\",
        -: 5638:  "	while ( 0 )",
        -: 5639:  "",
        -: 5640:  "#define unput(c) yyunput( c, yytext_ptr )",
        -: 5641:  "",
        -: 5642:  "",
        -: 5643:  "struct yy_buffer_state",
        -: 5644:  "	{",
        -: 5645:  "%-",
        -: 5646:  "	FILE *yy_input_file;",
        -: 5647:  "%+",
        -: 5648:  "	istream* yy_input_file;",
        -: 5649:  "%*",
        -: 5650:  "",
        -: 5651:  "	char *yy_ch_buf;		/* input buffer */",
        -: 5652:  "	char *yy_buf_pos;		/* current position in input buffer */",
        -: 5653:  "",
        -: 5654:  "	/* Size of input buffer in bytes, not including room for EOB",
        -: 5655:  "	 * characters.",
        -: 5656:  "	 */",
        -: 5657:  "	int yy_buf_size;",
        -: 5658:  "",
        -: 5659:  "	/* Number of characters read into yy_ch_buf, not including EOB",
        -: 5660:  "	 * characters.",
        -: 5661:  "	 */",
        -: 5662:  "	int yy_n_chars;",
        -: 5663:  "",
        -: 5664:  "	/* Whether this is an \"interactive\" input source; if so, and",
        -: 5665:  "	 * if we're using stdio for input, then we want to use getc()",
        -: 5666:  "	 * instead of fread(), to make sure we stop fetching input after",
        -: 5667:  "	 * each newline.",
        -: 5668:  "	 */",
        -: 5669:  "	int yy_is_interactive;",
        -: 5670:  "",
        -: 5671:  "	/* Whether to try to fill the input buffer when we reach the",
        -: 5672:  "	 * end of it.",
        -: 5673:  "	 */",
        -: 5674:  "	int yy_fill_buffer;",
        -: 5675:  "",
        -: 5676:  "	int yy_buffer_status;",
        -: 5677:  "#define YY_BUFFER_NEW 0",
        -: 5678:  "#define YY_BUFFER_NORMAL 1",
        -: 5679:  "	/* When an EOF's been seen but there's still some text to process",
        -: 5680:  "	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we",
        -: 5681:  "	 * shouldn't try reading from the input source any more.  We might",
        -: 5682:  "	 * still have a bunch of tokens to match, though, because of",
        -: 5683:  "	 * possible backing-up.",
        -: 5684:  "	 *",
        -: 5685:  "	 * When we actually see the EOF, we change the status to \"new\"",
        -: 5686:  "	 * (via yyrestart()), so that the user can continue scanning by",
        -: 5687:  "	 * just pointing yyin at a new input file.",
        -: 5688:  "	 */",
        -: 5689:  "#define YY_BUFFER_EOF_PENDING 2",
        -: 5690:  "	};",
        -: 5691:  "",
        -: 5692:  "%- Standard (non-C++) definition",
        -: 5693:  "static YY_BUFFER_STATE yy_current_buffer = 0;",
        -: 5694:  "%*",
        -: 5695:  "",
        -: 5696:  "/* We provide macros for accessing buffer states in case in the",
        -: 5697:  " * future we want to put the buffer states in a more general",
        -: 5698:  " * \"scanner state\".",
        -: 5699:  " */",
        -: 5700:  "#define YY_CURRENT_BUFFER yy_current_buffer",
        -: 5701:  "",
        -: 5702:  "",
        -: 5703:  "%- Standard (non-C++) definition",
        -: 5704:  "/* yy_hold_char holds the character lost when yytext is formed. */",
        -: 5705:  "static char yy_hold_char;",
        -: 5706:  "",
        -: 5707:  "static int yy_n_chars;		/* number of characters read into yy_ch_buf */",
        -: 5708:  "",
        -: 5709:  "",
        -: 5710:  "int yyleng;",
        -: 5711:  "",
        -: 5712:  "/* Points to current character in buffer. */",
        -: 5713:  "static char *yy_c_buf_p = (char *) 0;",
        -: 5714:  "static int yy_init = 1;		/* whether we need to initialize */",
        -: 5715:  "static int yy_start = 0;	/* start state number */",
        -: 5716:  "",
        -: 5717:  "/* Flag which is used to allow yywrap()'s to do buffer switches",
        -: 5718:  " * instead of setting up a fresh yyin.  A bit of a hack ...",
        -: 5719:  " */",
        -: 5720:  "static int yy_did_buffer_switch_on_eof;",
        -: 5721:  "",
        -: 5722:  "static void yyunput YY_PROTO(( int c, char *buf_ptr ));",
        -: 5723:  "void yyrestart YY_PROTO(( FILE *input_file ));",
        -: 5724:  "void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));",
        -: 5725:  "void yy_load_buffer_state YY_PROTO(( void ));",
        -: 5726:  "YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));",
        -: 5727:  "void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));",
        -: 5728:  "void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));",
        -: 5729:  "",
        -: 5730:  "static int yy_start_stack_ptr = 0;",
        -: 5731:  "static int yy_start_stack_depth = 0;",
        -: 5732:  "static int *yy_start_stack = 0;",
        -: 5733:  "static void yy_push_state YY_PROTO(( int new_state ));",
        -: 5734:  "static void yy_pop_state YY_PROTO(( void ));",
        -: 5735:  "static int yy_top_state YY_PROTO(( void ));",
        -: 5736:  "%*",
        -: 5737:  "",
        -: 5738:  "static void *yy_flex_alloc YY_PROTO(( unsigned int ));",
        -: 5739:  "static void *yy_flex_realloc YY_PROTO(( void *, unsigned int ));",
        -: 5740:  "static void yy_flex_free YY_PROTO(( void * ));",
        -: 5741:  "",
        -: 5742:  "#define yy_new_buffer yy_create_buffer",
        -: 5743:  "",
        -: 5744:  "%% yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here",
        -: 5745:  "",
        -: 5746:  "#ifndef yytext_ptr",
        -: 5747:  "static void yy_flex_strncpy YY_PROTO(( char *, const char *, int ));",
        -: 5748:  "#endif",
        -: 5749:  "",
        -: 5750:  "%- Standard (non-C++) definition",
        -: 5751:  "#ifdef __cplusplus",
        -: 5752:  "static int yyinput YY_PROTO(( void ));",
        -: 5753:  "#else",
        -: 5754:  "static int input YY_PROTO(( void ));",
        -: 5755:  "#endif",
        -: 5756:  "%*",
        -: 5757:  "",
        -: 5758:  "%- Standard (non-C++) definition",
        -: 5759:  "static yy_state_type yy_get_previous_state YY_PROTO(( void ));",
        -: 5760:  "static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));",
        -: 5761:  "static int yy_get_next_buffer YY_PROTO(( void ));",
        -: 5762:  "static void yy_fatal_error YY_PROTO(( const char msg[] ));",
        -: 5763:  "%*",
        -: 5764:  "",
        -: 5765:  "/* Done after the current pattern has been matched and before the",
        -: 5766:  " * corresponding action - sets up yytext.",
        -: 5767:  " */",
        -: 5768:  "#define YY_DO_BEFORE_ACTION \\",
        -: 5769:  "	yytext_ptr = yy_bp; \\",
        -: 5770:  "%% code to fiddle yytext and yyleng for yymore() goes here",
        -: 5771:  "	yy_hold_char = *yy_cp; \\",
        -: 5772:  "	*yy_cp = '\\0'; \\",
        -: 5773:  "%% code to copy yytext_ptr to yytext[] goes here, if %array",
        -: 5774:  "	yy_c_buf_p = yy_cp;",
        -: 5775:  "",
        -: 5776:  "%% data tables for the DFA and the user's section 1 definitions go here",
        -: 5777:  "",
        -: 5778:  "/* Macros after this point can all be overridden by user definitions in",
        -: 5779:  " * section 1.",
        -: 5780:  " */",
        -: 5781:  "",
        -: 5782:  "#ifdef YY_MALLOC_DECL",
        -: 5783:  "YY_MALLOC_DECL",
        -: 5784:  "#else",
        -: 5785:  "#if __STDC__",
        -: 5786:  "#ifndef __cplusplus",
        -: 5787:  "#include <stdlib.h>",
        -: 5788:  "#endif",
        -: 5789:  "#else",
        -: 5790:  "/* Just try to get by without declaring the routines.  This will fail",
        -: 5791:  " * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)",
        -: 5792:  " * or sizeof(void*) != sizeof(int).",
        -: 5793:  " */",
        -: 5794:  "#endif",
        -: 5795:  "#endif",
        -: 5796:  "",
        -: 5797:  "/* Amount of stuff to slurp up with each read. */",
        -: 5798:  "#ifndef YY_READ_BUF_SIZE",
        -: 5799:  "#define YY_READ_BUF_SIZE 8192",
        -: 5800:  "#endif",
        -: 5801:  "",
        -: 5802:  "/* Copy whatever the last rule matched to the standard output. */",
        -: 5803:  "",
        -: 5804:  "#ifndef ECHO",
        -: 5805:  "%- Standard (non-C++) definition",
        -: 5806:  "/* This used to be an fputs(), but since the string might contain NUL's,",
        -: 5807:  " * we now use fwrite().",
        -: 5808:  " */",
        -: 5809:  "#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )",
        -: 5810:  "%+ C++ definition",
        -: 5811:  "#define ECHO LexerOutput( yytext, yyleng )",
        -: 5812:  "%*",
        -: 5813:  "#endif",
        -: 5814:  "",
        -: 5815:  "/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,",
        -: 5816:  " * is returned in \"result\".",
        -: 5817:  " */",
        -: 5818:  "#ifndef YY_INPUT",
        -: 5819:  "#define YY_INPUT(buf,result,max_size) \\",
        -: 5820:  "%% fread()/read() definition of YY_INPUT goes here unless we're doing C++",
        -: 5821:  "%+ C++ definition",
        -: 5822:  "	if ( (result = LexerInput( (char *) buf, max_size )) < 0 ) \\",
        -: 5823:  "		YY_FATAL_ERROR( \"input in flex scanner failed\" );",
        -: 5824:  "%*",
        -: 5825:  "#endif",
        -: 5826:  "",
        -: 5827:  "/* No semi-colon after return; correct usage is to write \"yyterminate();\" -",
        -: 5828:  " * we don't want an extra ';' after the \"return\" because that will cause",
        -: 5829:  " * some compilers to complain about unreachable statements.",
        -: 5830:  " */",
        -: 5831:  "#ifndef yyterminate",
        -: 5832:  "#define yyterminate() return YY_NULL",
        -: 5833:  "#endif",
        -: 5834:  "",
        -: 5835:  "/* Number of entries by which start-condition stack grows. */",
        -: 5836:  "#ifndef YY_START_STACK_INCR",
        -: 5837:  "#define YY_START_STACK_INCR 25",
        -: 5838:  "#endif",
        -: 5839:  "",
        -: 5840:  "/* Report a fatal error. */",
        -: 5841:  "#ifndef YY_FATAL_ERROR",
        -: 5842:  "%-",
        -: 5843:  "#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )",
        -: 5844:  "%+",
        -: 5845:  "#define YY_FATAL_ERROR(msg) LexerError( msg )",
        -: 5846:  "%*",
        -: 5847:  "#endif",
        -: 5848:  "",
        -: 5849:  "/* Default declaration of generated scanner - a define so the user can",
        -: 5850:  " * easily add parameters.",
        -: 5851:  " */",
        -: 5852:  "#ifndef YY_DECL",
        -: 5853:  "%- Standard (non-C++) definition",
        -: 5854:  "#define YY_DECL int yylex YY_PROTO(( void ))",
        -: 5855:  "%+ C++ definition",
        -: 5856:  "#define YY_DECL int yyFlexLexer::yylex()",
        -: 5857:  "%*",
        -: 5858:  "#endif",
        -: 5859:  "",
        -: 5860:  "/* Code executed at the beginning of each rule, after yytext and yyleng",
        -: 5861:  " * have been set up.",
        -: 5862:  " */",
        -: 5863:  "#ifndef YY_USER_ACTION",
        -: 5864:  "#define YY_USER_ACTION",
        -: 5865:  "#endif",
        -: 5866:  "",
        -: 5867:  "/* Code executed at the end of each rule. */",
        -: 5868:  "#ifndef YY_BREAK",
        -: 5869:  "#define YY_BREAK break;",
        -: 5870:  "#endif",
        -: 5871:  "",
        -: 5872:  "YY_DECL",
        -: 5873:  "	{",
        -: 5874:  "	register yy_state_type yy_current_state;",
        -: 5875:  "	register char *yy_cp, *yy_bp;",
        -: 5876:  "	register int yy_act;",
        -: 5877:  "",
        -: 5878:  "%% user's declarations go here",
        -: 5879:  "",
        -: 5880:  "	if ( yy_init )",
        -: 5881:  "		{",
        -: 5882:  "#ifdef YY_USER_INIT",
        -: 5883:  "		YY_USER_INIT;",
        -: 5884:  "#endif",
        -: 5885:  "",
        -: 5886:  "		if ( ! yy_start )",
        -: 5887:  "			yy_start = 1;	/* first start state */",
        -: 5888:  "",
        -: 5889:  "		if ( ! yyin )",
        -: 5890:  "%-",
        -: 5891:  "			yyin = stdin;",
        -: 5892:  "%+",
        -: 5893:  "			yyin = &cin;",
        -: 5894:  "%*",
        -: 5895:  "",
        -: 5896:  "		if ( ! yyout )",
        -: 5897:  "%-",
        -: 5898:  "			yyout = stdout;",
        -: 5899:  "%+",
        -: 5900:  "			yyout = &cout;",
        -: 5901:  "%*",
        -: 5902:  "",
        -: 5903:  "		if ( yy_current_buffer )",
        -: 5904:  "			yy_init_buffer( yy_current_buffer, yyin );",
        -: 5905:  "		else",
        -: 5906:  "			yy_current_buffer =",
        -: 5907:  "				yy_create_buffer( yyin, YY_BUF_SIZE );",
        -: 5908:  "",
        -: 5909:  "		yy_load_buffer_state();",
        -: 5910:  "",
        -: 5911:  "		yy_init = 0;",
        -: 5912:  "		}",
        -: 5913:  "",
        -: 5914:  "	while ( 1 )		/* loops until end-of-file is reached */",
        -: 5915:  "		{",
        -: 5916:  "%% yymore()-related code goes here",
        -: 5917:  "		yy_cp = yy_c_buf_p;",
        -: 5918:  "",
        -: 5919:  "		/* Support of yytext. */",
        -: 5920:  "		*yy_cp = yy_hold_char;",
        -: 5921:  "",
        -: 5922:  "		/* yy_bp points to the position in yy_ch_buf of the start of",
        -: 5923:  "		 * the current run.",
        -: 5924:  "		 */",
        -: 5925:  "		yy_bp = yy_cp;",
        -: 5926:  "",
        -: 5927:  "%% code to set up and find next match goes here",
        -: 5928:  "",
        -: 5929:  "yy_find_action:",
        -: 5930:  "%% code to find the action number goes here",
        -: 5931:  "",
        -: 5932:  "		YY_DO_BEFORE_ACTION;",
        -: 5933:  "",
        -: 5934:  "%% code for yylineno update goes here, if -l option",
        -: 5935:  "",
        -: 5936:  "do_action:	/* This label is used only to access EOF actions. */",
        -: 5937:  "",
        -: 5938:  "%% debug code goes here",
        -: 5939:  "",
        -: 5940:  "		switch ( yy_act )",
        -: 5941:  "	{ /* beginning of action switch */",
        -: 5942:  "%% actions go here",
        -: 5943:  "",
        -: 5944:  "	case YY_END_OF_BUFFER:",
        -: 5945:  "		{",
        -: 5946:  "		/* Amount of text matched not including the EOB char. */",
        -: 5947:  "		int yy_amount_of_matched_text = yy_cp - yytext_ptr - 1;",
        -: 5948:  "",
        -: 5949:  "		/* Undo the effects of YY_DO_BEFORE_ACTION. */",
        -: 5950:  "		*yy_cp = yy_hold_char;",
        -: 5951:  "",
        -: 5952:  "		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )",
        -: 5953:  "			{",
        -: 5954:  "			/* We're scanning a new file or input source.  It's",
        -: 5955:  "			 * possible that this happened because the user",
        -: 5956:  "			 * just pointed yyin at a new source and called",
        -: 5957:  "			 * yylex().  If so, then we have to assure",
        -: 5958:  "			 * consistency between yy_current_buffer and our",
        -: 5959:  "			 * globals.  Here is the right place to do so, because",
        -: 5960:  "			 * this is the first action (other than possibly a",
        -: 5961:  "			 * back-up) that will match for the new input source.",
        -: 5962:  "			 */",
        -: 5963:  "			yy_n_chars = yy_current_buffer->yy_n_chars;",
        -: 5964:  "			yy_current_buffer->yy_input_file = yyin;",
        -: 5965:  "			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;",
        -: 5966:  "			}",
        -: 5967:  "",
        -: 5968:  "		/* Note that here we test for yy_c_buf_p \"<=\" to the position",
        -: 5969:  "		 * of the first EOB in the buffer, since yy_c_buf_p will",
        -: 5970:  "		 * already have been incremented past the NUL character",
        -: 5971:  "		 * (since all states make transitions on EOB to the",
        -: 5972:  "		 * end-of-buffer state).  Contrast this with the test",
        -: 5973:  "		 * in input().",
        -: 5974:  "		 */",
        -: 5975:  "		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )",
        -: 5976:  "			{ /* This was really a NUL. */",
        -: 5977:  "			yy_state_type yy_next_state;",
        -: 5978:  "",
        -: 5979:  "			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;",
        -: 5980:  "",
        -: 5981:  "			yy_current_state = yy_get_previous_state();",
        -: 5982:  "",
        -: 5983:  "			/* Okay, we're now positioned to make the NUL",
        -: 5984:  "			 * transition.  We couldn't have",
        -: 5985:  "			 * yy_get_previous_state() go ahead and do it",
        -: 5986:  "			 * for us because it doesn't know how to deal",
        -: 5987:  "			 * with the possibility of jamming (and we don't",
        -: 5988:  "			 * want to build jamming into it because then it",
        -: 5989:  "			 * will run more slowly).",
        -: 5990:  "			 */",
        -: 5991:  "",
        -: 5992:  "			yy_next_state = yy_try_NUL_trans( yy_current_state );",
        -: 5993:  "",
        -: 5994:  "			yy_bp = yytext_ptr + YY_MORE_ADJ;",
        -: 5995:  "",
        -: 5996:  "			if ( yy_next_state )",
        -: 5997:  "				{",
        -: 5998:  "				/* Consume the NUL. */",
        -: 5999:  "				yy_cp = ++yy_c_buf_p;",
        -: 6000:  "				yy_current_state = yy_next_state;",
        -: 6001:  "				goto yy_match;",
        -: 6002:  "				}",
        -: 6003:  "",
        -: 6004:  "			else",
        -: 6005:  "				{",
        -: 6006:  "%% code to do back-up for compressed tables and set up yy_cp goes here",
        -: 6007:  "				goto yy_find_action;",
        -: 6008:  "				}",
        -: 6009:  "			}",
        -: 6010:  "",
        -: 6011:  "		else switch ( yy_get_next_buffer() )",
        -: 6012:  "			{",
        -: 6013:  "			case EOB_ACT_END_OF_FILE:",
        -: 6014:  "				{",
        -: 6015:  "				yy_did_buffer_switch_on_eof = 0;",
        -: 6016:  "",
        -: 6017:  "				if ( yywrap() )",
        -: 6018:  "					{",
        -: 6019:  "					/* Note: because we've taken care in",
        -: 6020:  "					 * yy_get_next_buffer() to have set up",
        -: 6021:  "					 * yytext, we can now set up",
        -: 6022:  "					 * yy_c_buf_p so that if some total",
        -: 6023:  "					 * hoser (like flex itself) wants to",
        -: 6024:  "					 * call the scanner after we return the",
        -: 6025:  "					 * YY_NULL, it'll still work - another",
        -: 6026:  "					 * YY_NULL will get returned.",
        -: 6027:  "					 */",
        -: 6028:  "					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;",
        -: 6029:  "",
        -: 6030:  "					yy_act = YY_STATE_EOF(YY_START);",
        -: 6031:  "					goto do_action;",
        -: 6032:  "					}",
        -: 6033:  "",
        -: 6034:  "				else",
        -: 6035:  "					{",
        -: 6036:  "					if ( ! yy_did_buffer_switch_on_eof )",
        -: 6037:  "						YY_NEW_FILE;",
        -: 6038:  "					}",
        -: 6039:  "				break;",
        -: 6040:  "				}",
        -: 6041:  "",
        -: 6042:  "			case EOB_ACT_CONTINUE_SCAN:",
        -: 6043:  "				yy_c_buf_p =",
        -: 6044:  "					yytext_ptr + yy_amount_of_matched_text;",
        -: 6045:  "",
        -: 6046:  "				yy_current_state = yy_get_previous_state();",
        -: 6047:  "",
        -: 6048:  "				yy_cp = yy_c_buf_p;",
        -: 6049:  "				yy_bp = yytext_ptr + YY_MORE_ADJ;",
        -: 6050:  "				goto yy_match;",
        -: 6051:  "",
        -: 6052:  "			case EOB_ACT_LAST_MATCH:",
        -: 6053:  "				yy_c_buf_p =",
        -: 6054:  "				&yy_current_buffer->yy_ch_buf[yy_n_chars];",
        -: 6055:  "",
        -: 6056:  "				yy_current_state = yy_get_previous_state();",
        -: 6057:  "",
        -: 6058:  "				yy_cp = yy_c_buf_p;",
        -: 6059:  "				yy_bp = yytext_ptr + YY_MORE_ADJ;",
        -: 6060:  "				goto yy_find_action;",
        -: 6061:  "			}",
        -: 6062:  "		break;",
        -: 6063:  "		}",
        -: 6064:  "",
        -: 6065:  "	default:",
        -: 6066:  "		YY_FATAL_ERROR(",
        -: 6067:  "			\"fatal flex scanner internal error--no action found\" );",
        -: 6068:  "	} /* end of action switch */",
        -: 6069:  "		} /* end of scanning one token */",
        -: 6070:  "	} /* end of yylex */",
        -: 6071:  "",
        -: 6072:  "%+",
        -: 6073:  "#ifdef YY_INTERACTIVE",
        -: 6074:  "int yyFlexLexer::LexerInput( char* buf, int /* max_size */ )",
        -: 6075:  "#else",
        -: 6076:  "int yyFlexLexer::LexerInput( char* buf, int max_size )",
        -: 6077:  "#endif",
        -: 6078:  "	{",
        -: 6079:  "	if ( yyin->eof() || yyin->fail() )",
        -: 6080:  "		return 0;",
        -: 6081:  "",
        -: 6082:  "#ifdef YY_INTERACTIVE",
        -: 6083:  "	yyin->get( buf[0] );",
        -: 6084:  "",
        -: 6085:  "	if ( yyin->eof() )",
        -: 6086:  "		return 0;",
        -: 6087:  "",
        -: 6088:  "	if ( yyin->bad() )",
        -: 6089:  "		return -1;",
        -: 6090:  "",
        -: 6091:  "	return 1;",
        -: 6092:  "",
        -: 6093:  "#else",
        -: 6094:  "	(void) yyin->read( buf, max_size );",
        -: 6095:  "",
        -: 6096:  "	if ( yyin->bad() )",
        -: 6097:  "		return -1;",
        -: 6098:  "	else",
        -: 6099:  "		return yyin->gcount();",
        -: 6100:  "#endif",
        -: 6101:  "	}",
        -: 6102:  "",
        -: 6103:  "void yyFlexLexer::LexerOutput( const char* buf, int size )",
        -: 6104:  "	{",
        -: 6105:  "	(void) yyout->write( buf, size );",
        -: 6106:  "	}",
        -: 6107:  "%*",
        -: 6108:  "",
        -: 6109:  "/* yy_get_next_buffer - try to read in a new buffer",
        -: 6110:  " *",
        -: 6111:  " * Returns a code representing an action:",
        -: 6112:  " *	EOB_ACT_LAST_MATCH -",
        -: 6113:  " *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position",
        -: 6114:  " *	EOB_ACT_END_OF_FILE - end of file",
        -: 6115:  " */",
        -: 6116:  "",
        -: 6117:  "%-",
        -: 6118:  "static int yy_get_next_buffer()",
        -: 6119:  "%+",
        -: 6120:  "int yyFlexLexer::yy_get_next_buffer()",
        -: 6121:  "%*",
        -: 6122:  "	{",
        -: 6123:  "	register char *dest = yy_current_buffer->yy_ch_buf;",
        -: 6124:  "	register char *source = yytext_ptr - 1; /* copy prev. char, too */",
        -: 6125:  "	register int number_to_move, i;",
        -: 6126:  "	int ret_val;",
        -: 6127:  "",
        -: 6128:  "	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )",
        -: 6129:  "		YY_FATAL_ERROR(",
        -: 6130:  "		\"fatal flex scanner internal error--end of buffer missed\" );",
        -: 6131:  "",
        -: 6132:  "	if ( yy_current_buffer->yy_fill_buffer == 0 )",
        -: 6133:  "		{ /* Don't try to fill the buffer, so this is an EOF. */",
        -: 6134:  "		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )",
        -: 6135:  "			{",
        -: 6136:  "			/* We matched a singled characater, the EOB, so",
        -: 6137:  "			 * treat this as a final EOF.",
        -: 6138:  "			 */",
        -: 6139:  "			return EOB_ACT_END_OF_FILE;",
        -: 6140:  "			}",
        -: 6141:  "",
        -: 6142:  "		else",
        -: 6143:  "			{",
        -: 6144:  "			/* We matched some text prior to the EOB, first",
        -: 6145:  "			 * process it.",
        -: 6146:  "			 */",
        -: 6147:  "			return EOB_ACT_LAST_MATCH;",
        -: 6148:  "			}",
        -: 6149:  "		}",
        -: 6150:  "",
        -: 6151:  "	/* Try to read more data. */",
        -: 6152:  "",
        -: 6153:  "	/* First move last chars to start of buffer. */",
        -: 6154:  "	number_to_move = yy_c_buf_p - yytext_ptr;",
        -: 6155:  "",
        -: 6156:  "	for ( i = 0; i < number_to_move; ++i )",
        -: 6157:  "		*(dest++) = *(source++);",
        -: 6158:  "",
        -: 6159:  "	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )",
        -: 6160:  "		/* don't do the read, it's not guaranteed to return an EOF,",
        -: 6161:  "		 * just force an EOF",
        -: 6162:  "		 */",
        -: 6163:  "		yy_n_chars = 0;",
        -: 6164:  "",
        -: 6165:  "	else",
        -: 6166:  "		{",
        -: 6167:  "		int num_to_read =",
        -: 6168:  "			yy_current_buffer->yy_buf_size - number_to_move - 1;",
        -: 6169:  "",
        -: 6170:  "		while ( num_to_read <= 0 )",
        -: 6171:  "			{ /* Not enough room in the buffer - grow it. */",
        -: 6172:  "#ifdef YY_USES_REJECT",
        -: 6173:  "			YY_FATAL_ERROR(",
        -: 6174:  "\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );",
        -: 6175:  "#else",
        -: 6176:  "",
        -: 6177:  "			/* just a shorter name for the current buffer */",
        -: 6178:  "			YY_BUFFER_STATE b = yy_current_buffer;",
        -: 6179:  "",
        -: 6180:  "			int yy_c_buf_p_offset = yy_c_buf_p - b->yy_ch_buf;",
        -: 6181:  "",
        -: 6182:  "			b->yy_buf_size *= 2;",
        -: 6183:  "			b->yy_ch_buf = (char *)",
        -: 6184:  "				yy_flex_realloc( (void *) b->yy_ch_buf,",
        -: 6185:  "						 b->yy_buf_size );",
        -: 6186:  "",
        -: 6187:  "			if ( ! b->yy_ch_buf )",
        -: 6188:  "				YY_FATAL_ERROR(",
        -: 6189:  "				\"fatal error - scanner input buffer overflow\" );",
        -: 6190:  "",
        -: 6191:  "			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];",
        -: 6192:  "",
        -: 6193:  "			num_to_read = yy_current_buffer->yy_buf_size -",
        -: 6194:  "						number_to_move - 1;",
        -: 6195:  "#endif",
        -: 6196:  "			}",
        -: 6197:  "",
        -: 6198:  "		if ( num_to_read > YY_READ_BUF_SIZE )",
        -: 6199:  "			num_to_read = YY_READ_BUF_SIZE;",
        -: 6200:  "",
        -: 6201:  "		/* Read in more data. */",
        -: 6202:  "		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),",
        -: 6203:  "			yy_n_chars, num_to_read );",
        -: 6204:  "		}",
        -: 6205:  "",
        -: 6206:  "	if ( yy_n_chars == 0 )",
        -: 6207:  "		{",
        -: 6208:  "		if ( number_to_move - YY_MORE_ADJ == 1 )",
        -: 6209:  "			{",
        -: 6210:  "			ret_val = EOB_ACT_END_OF_FILE;",
        -: 6211:  "			yyrestart( yyin );",
        -: 6212:  "			}",
        -: 6213:  "",
        -: 6214:  "		else",
        -: 6215:  "			{",
        -: 6216:  "			ret_val = EOB_ACT_LAST_MATCH;",
        -: 6217:  "			yy_current_buffer->yy_buffer_status =",
        -: 6218:  "				YY_BUFFER_EOF_PENDING;",
        -: 6219:  "			}",
        -: 6220:  "		}",
        -: 6221:  "",
        -: 6222:  "	else",
        -: 6223:  "		ret_val = EOB_ACT_CONTINUE_SCAN;",
        -: 6224:  "",
        -: 6225:  "	yy_n_chars += number_to_move;",
        -: 6226:  "	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;",
        -: 6227:  "	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;",
        -: 6228:  "",
        -: 6229:  "	/* yytext begins at the second character in yy_ch_buf; the first",
        -: 6230:  "	 * character is the one which preceded it before reading in the latest",
        -: 6231:  "	 * buffer; it needs to be kept around in case it's a newline, so",
        -: 6232:  "	 * yy_get_previous_state() will have with '^' rules active.",
        -: 6233:  "	 */",
        -: 6234:  "",
        -: 6235:  "	yytext_ptr = &yy_current_buffer->yy_ch_buf[1];",
        -: 6236:  "",
        -: 6237:  "	return ret_val;",
        -: 6238:  "	}",
        -: 6239:  "",
        -: 6240:  "",
        -: 6241:  "/* yy_get_previous_state - get the state just before the EOB char was reached */",
        -: 6242:  "",
        -: 6243:  "%-",
        -: 6244:  "static yy_state_type yy_get_previous_state()",
        -: 6245:  "%+",
        -: 6246:  "yy_state_type yyFlexLexer::yy_get_previous_state()",
        -: 6247:  "%*",
        -: 6248:  "	{",
        -: 6249:  "	register yy_state_type yy_current_state;",
        -: 6250:  "	register char *yy_cp;",
        -: 6251:  "",
        -: 6252:  "%% code to get the start state into yy_current_state goes here",
        -: 6253:  "",
        -: 6254:  "	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )",
        -: 6255:  "		{",
        -: 6256:  "%% code to find the next state goes here",
        -: 6257:  "		}",
        -: 6258:  "",
        -: 6259:  "	return yy_current_state;",
        -: 6260:  "	}",
        -: 6261:  "",
        -: 6262:  "",
        -: 6263:  "/* yy_try_NUL_trans - try to make a transition on the NUL character",
        -: 6264:  " *",
        -: 6265:  " * synopsis",
        -: 6266:  " *	next_state = yy_try_NUL_trans( current_state );",
        -: 6267:  " */",
        -: 6268:  "",
        -: 6269:  "%-",
        -: 6270:  "#ifdef YY_USE_PROTOS",
        -: 6271:  "static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )",
        -: 6272:  "#else",
        -: 6273:  "static yy_state_type yy_try_NUL_trans( yy_current_state )",
        -: 6274:  "yy_state_type yy_current_state;",
        -: 6275:  "#endif",
        -: 6276:  "%+",
        -: 6277:  "yy_state_type yyFlexLexer::yy_try_NUL_trans( yy_state_type yy_current_state )",
        -: 6278:  "%*",
        -: 6279:  "	{",
        -: 6280:  "	register int yy_is_jam;",
        -: 6281:  "%% code to find the next state, and perhaps do backing up, goes here",
        -: 6282:  "",
        -: 6283:  "	return yy_is_jam ? 0 : yy_current_state;",
        -: 6284:  "	}",
        -: 6285:  "",
        -: 6286:  "",
        -: 6287:  "%-",
        -: 6288:  "#ifdef YY_USE_PROTOS",
        -: 6289:  "static void yyunput( int c, register char *yy_bp )",
        -: 6290:  "#else",
        -: 6291:  "static void yyunput( c, yy_bp )",
        -: 6292:  "int c;",
        -: 6293:  "register char *yy_bp;",
        -: 6294:  "#endif",
        -: 6295:  "%+",
        -: 6296:  "void yyFlexLexer::yyunput( int c, register char* yy_bp )",
        -: 6297:  "%*",
        -: 6298:  "	{",
        -: 6299:  "	register char *yy_cp = yy_c_buf_p;",
        -: 6300:  "",
        -: 6301:  "	/* undo effects of setting up yytext */",
        -: 6302:  "	*yy_cp = yy_hold_char;",
        -: 6303:  "",
        -: 6304:  "	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )",
        -: 6305:  "		{ /* need to shift things up to make room */",
        -: 6306:  "		/* +2 for EOB chars. */",
        -: 6307:  "		register int number_to_move = yy_n_chars + 2;",
        -: 6308:  "		register char *dest = &yy_current_buffer->yy_ch_buf[",
        -: 6309:  "					yy_current_buffer->yy_buf_size + 2];",
        -: 6310:  "		register char *source =",
        -: 6311:  "				&yy_current_buffer->yy_ch_buf[number_to_move];",
        -: 6312:  "",
        -: 6313:  "		while ( source > yy_current_buffer->yy_ch_buf )",
        -: 6314:  "			*--dest = *--source;",
        -: 6315:  "",
        -: 6316:  "		yy_cp += dest - source;",
        -: 6317:  "		yy_bp += dest - source;",
        -: 6318:  "		yy_n_chars = yy_current_buffer->yy_buf_size;",
        -: 6319:  "",
        -: 6320:  "		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )",
        -: 6321:  "			YY_FATAL_ERROR( \"flex scanner push-back overflow\" );",
        -: 6322:  "		}",
        -: 6323:  "",
        -: 6324:  "	if ( yy_cp > yy_bp && yy_cp[-1] == '\\n' )",
        -: 6325:  "		yy_cp[-2] = '\\n';",
        -: 6326:  "",
        -: 6327:  "	*--yy_cp = (char) c;",
        -: 6328:  "",
        -: 6329:  "%% update yylineno here, if doing -l",
        -: 6330:  "",
        -: 6331:  "	/* Note: the formal parameter *must* be called \"yy_bp\" for this",
        -: 6332:  "	 * macro to now work correctly.",
        -: 6333:  "	 */",
        -: 6334:  "	YY_DO_BEFORE_ACTION; /* set up yytext again */",
        -: 6335:  "	}",
        -: 6336:  "",
        -: 6337:  "",
        -: 6338:  "%-",
        -: 6339:  "#ifdef __cplusplus",
        -: 6340:  "static int yyinput()",
        -: 6341:  "#else",
        -: 6342:  "static int input()",
        -: 6343:  "#endif",
        -: 6344:  "%+",
        -: 6345:  "int yyFlexLexer::yyinput()",
        -: 6346:  "%*",
        -: 6347:  "	{",
        -: 6348:  "	int c;",
        -: 6349:  "",
        -: 6350:  "	*yy_c_buf_p = yy_hold_char;",
        -: 6351:  "",
        -: 6352:  "	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )",
        -: 6353:  "		{",
        -: 6354:  "		/* yy_c_buf_p now points to the character we want to return.",
        -: 6355:  "		 * If this occurs *before* the EOB characters, then it's a",
        -: 6356:  "		 * valid NUL; if not, then we've hit the end of the buffer.",
        -: 6357:  "		 */",
        -: 6358:  "		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )",
        -: 6359:  "			/* This was really a NUL. */",
        -: 6360:  "			*yy_c_buf_p = '\\0';",
        -: 6361:  "",
        -: 6362:  "		else",
        -: 6363:  "			{ /* need more input */",
        -: 6364:  "			yytext_ptr = yy_c_buf_p;",
        -: 6365:  "			++yy_c_buf_p;",
        -: 6366:  "",
        -: 6367:  "			switch ( yy_get_next_buffer() )",
        -: 6368:  "				{",
        -: 6369:  "				case EOB_ACT_END_OF_FILE:",
        -: 6370:  "					{",
        -: 6371:  "					if ( yywrap() )",
        -: 6372:  "						{",
        -: 6373:  "						yy_c_buf_p =",
        -: 6374:  "						yytext_ptr + YY_MORE_ADJ;",
        -: 6375:  "						return EOF;",
        -: 6376:  "						}",
        -: 6377:  "",
        -: 6378:  "					YY_NEW_FILE;",
        -: 6379:  "#ifdef __cplusplus",
        -: 6380:  "					return yyinput();",
        -: 6381:  "#else",
        -: 6382:  "					return input();",
        -: 6383:  "#endif",
        -: 6384:  "					}",
        -: 6385:  "",
        -: 6386:  "				case EOB_ACT_CONTINUE_SCAN:",
        -: 6387:  "					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;",
        -: 6388:  "					break;",
        -: 6389:  "",
        -: 6390:  "				case EOB_ACT_LAST_MATCH:",
        -: 6391:  "#ifdef __cplusplus",
        -: 6392:  "					YY_FATAL_ERROR(",
        -: 6393:  "					\"unexpected last match in yyinput()\" );",
        -: 6394:  "#else",
        -: 6395:  "					YY_FATAL_ERROR(",
        -: 6396:  "					\"unexpected last match in input()\" );",
        -: 6397:  "#endif",
        -: 6398:  "				}",
        -: 6399:  "			}",
        -: 6400:  "		}",
        -: 6401:  "",
        -: 6402:  "	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */",
        -: 6403:  "	*yy_c_buf_p = '\\0';	/* preserve yytext */",
        -: 6404:  "	yy_hold_char = *++yy_c_buf_p;",
        -: 6405:  "",
        -: 6406:  "	return c;",
        -: 6407:  "	}",
        -: 6408:  "",
        -: 6409:  "",
        -: 6410:  "%-",
        -: 6411:  "#ifdef YY_USE_PROTOS",
        -: 6412:  "void yyrestart( FILE *input_file )",
        -: 6413:  "#else",
        -: 6414:  "void yyrestart( input_file )",
        -: 6415:  "FILE *input_file;",
        -: 6416:  "#endif",
        -: 6417:  "%+",
        -: 6418:  "void yyFlexLexer::yyrestart( istream* input_file )",
        -: 6419:  "%*",
        -: 6420:  "	{",
        -: 6421:  "	if ( ! yy_current_buffer )",
        -: 6422:  "		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );",
        -: 6423:  "",
        -: 6424:  "	yy_init_buffer( yy_current_buffer, input_file );",
        -: 6425:  "	yy_load_buffer_state();",
        -: 6426:  "	}",
        -: 6427:  "",
        -: 6428:  "",
        -: 6429:  "%-",
        -: 6430:  "#ifdef YY_USE_PROTOS",
        -: 6431:  "void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )",
        -: 6432:  "#else",
        -: 6433:  "void yy_switch_to_buffer( new_buffer )",
        -: 6434:  "YY_BUFFER_STATE new_buffer;",
        -: 6435:  "#endif",
        -: 6436:  "%+",
        -: 6437:  "void yyFlexLexer::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )",
        -: 6438:  "%*",
        -: 6439:  "	{",
        -: 6440:  "	if ( yy_current_buffer == new_buffer )",
        -: 6441:  "		return;",
        -: 6442:  "",
        -: 6443:  "	if ( yy_current_buffer )",
        -: 6444:  "		{",
        -: 6445:  "		/* Flush out information for old buffer. */",
        -: 6446:  "		*yy_c_buf_p = yy_hold_char;",
        -: 6447:  "		yy_current_buffer->yy_buf_pos = yy_c_buf_p;",
        -: 6448:  "		yy_current_buffer->yy_n_chars = yy_n_chars;",
        -: 6449:  "		}",
        -: 6450:  "",
        -: 6451:  "	yy_current_buffer = new_buffer;",
        -: 6452:  "	yy_load_buffer_state();",
        -: 6453:  "",
        -: 6454:  "	/* We don't actually know whether we did this switch during",
        -: 6455:  "	 * EOF (yywrap()) processing, but the only time this flag",
        -: 6456:  "	 * is looked at is after yywrap() is called, so it's safe",
        -: 6457:  "	 * to go ahead and always set it.",
        -: 6458:  "	 */",
        -: 6459:  "	yy_did_buffer_switch_on_eof = 1;",
        -: 6460:  "	}",
        -: 6461:  "",
        -: 6462:  "",
        -: 6463:  "%-",
        -: 6464:  "#ifdef YY_USE_PROTOS",
        -: 6465:  "void yy_load_buffer_state( void )",
        -: 6466:  "#else",
        -: 6467:  "void yy_load_buffer_state()",
        -: 6468:  "#endif",
        -: 6469:  "%+",
        -: 6470:  "void yyFlexLexer::yy_load_buffer_state()",
        -: 6471:  "%*",
        -: 6472:  "	{",
        -: 6473:  "	yy_n_chars = yy_current_buffer->yy_n_chars;",
        -: 6474:  "	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;",
        -: 6475:  "	yyin = yy_current_buffer->yy_input_file;",
        -: 6476:  "	yy_hold_char = *yy_c_buf_p;",
        -: 6477:  "	}",
        -: 6478:  "",
        -: 6479:  "",
        -: 6480:  "%-",
        -: 6481:  "#ifdef YY_USE_PROTOS",
        -: 6482:  "YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )",
        -: 6483:  "#else",
        -: 6484:  "YY_BUFFER_STATE yy_create_buffer( file, size )",
        -: 6485:  "FILE *file;",
        -: 6486:  "int size;",
        -: 6487:  "#endif",
        -: 6488:  "%+",
        -: 6489:  "YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( istream* file, int size )",
        -: 6490:  "%*",
        -: 6491:  "	{",
        -: 6492:  "	YY_BUFFER_STATE b;",
        -: 6493:  "",
        -: 6494:  "	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );",
        -: 6495:  "",
        -: 6496:  "	if ( ! b )",
        -: 6497:  "		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );",
        -: 6498:  "",
        -: 6499:  "	b->yy_buf_size = size;",
        -: 6500:  "",
        -: 6501:  "	/* yy_ch_buf has to be 2 characters longer than the size given because",
        -: 6502:  "	 * we need to put in 2 end-of-buffer characters.",
        -: 6503:  "	 */",
        -: 6504:  "	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );",
        -: 6505:  "",
        -: 6506:  "	if ( ! b->yy_ch_buf )",
        -: 6507:  "		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );",
        -: 6508:  "",
        -: 6509:  "	yy_init_buffer( b, file );",
        -: 6510:  "",
        -: 6511:  "	return b;",
        -: 6512:  "	}",
        -: 6513:  "",
        -: 6514:  "",
        -: 6515:  "%-",
        -: 6516:  "#ifdef YY_USE_PROTOS",
        -: 6517:  "void yy_delete_buffer( YY_BUFFER_STATE b )",
        -: 6518:  "#else",
        -: 6519:  "void yy_delete_buffer( b )",
        -: 6520:  "YY_BUFFER_STATE b;",
        -: 6521:  "#endif",
        -: 6522:  "%+",
        -: 6523:  "void yyFlexLexer::yy_delete_buffer( YY_BUFFER_STATE b )",
        -: 6524:  "%*",
        -: 6525:  "	{",
        -: 6526:  "	if ( b == yy_current_buffer )",
        -: 6527:  "		yy_current_buffer = (YY_BUFFER_STATE) 0;",
        -: 6528:  "",
        -: 6529:  "	yy_flex_free( (void *) b->yy_ch_buf );",
        -: 6530:  "	yy_flex_free( (void *) b );",
        -: 6531:  "	}",
        -: 6532:  "",
        -: 6533:  "",
        -: 6534:  "%-",
        -: 6535:  "#ifdef YY_USE_PROTOS",
        -: 6536:  "void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )",
        -: 6537:  "#else",
        -: 6538:  "void yy_init_buffer( b, file )",
        -: 6539:  "YY_BUFFER_STATE b;",
        -: 6540:  "FILE *file;",
        -: 6541:  "#endif",
        -: 6542:  "%+",
        -: 6543:  "void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, istream* file )",
        -: 6544:  "%*",
        -: 6545:  "	{",
        -: 6546:  "	b->yy_input_file = file;",
        -: 6547:  "",
        -: 6548:  "	/* We put in the '\\n' and start reading from [1] so that an",
        -: 6549:  "	 * initial match-at-newline will be true.",
        -: 6550:  "	 */",
        -: 6551:  "",
        -: 6552:  "	b->yy_ch_buf[0] = '\\n';",
        -: 6553:  "	b->yy_n_chars = 1;",
        -: 6554:  "",
        -: 6555:  "	/* We always need two end-of-buffer characters.  The first causes",
        -: 6556:  "	 * a transition to the end-of-buffer state.  The second causes",
        -: 6557:  "	 * a jam in that state.",
        -: 6558:  "	 */",
        -: 6559:  "	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;",
        -: 6560:  "	b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;",
        -: 6561:  "",
        -: 6562:  "	b->yy_buf_pos = &b->yy_ch_buf[1];",
        -: 6563:  "",
        -: 6564:  "%-",
        -: 6565:  "	b->yy_is_interactive = file ? isatty( fileno(file) ) : 0;",
        -: 6566:  "%+",
        -: 6567:  "	b->yy_is_interactive = 0;",
        -: 6568:  "%*",
        -: 6569:  "",
        -: 6570:  "	b->yy_fill_buffer = 1;",
        -: 6571:  "",
        -: 6572:  "	b->yy_buffer_status = YY_BUFFER_NEW;",
        -: 6573:  "	}",
        -: 6574:  "",
        -: 6575:  "",
        -: 6576:  "%-",
        -: 6577:  "#ifdef YY_USE_PROTOS",
        -: 6578:  "static void yy_push_state( int new_state )",
        -: 6579:  "#else",
        -: 6580:  "static void yy_push_state( new_state )",
        -: 6581:  "int new_state;",
        -: 6582:  "#endif",
        -: 6583:  "%+",
        -: 6584:  "void yyFlexLexer::yy_push_state( int new_state )",
        -: 6585:  "%*",
        -: 6586:  "	{",
        -: 6587:  "	if ( yy_start_stack_ptr >= yy_start_stack_depth )",
        -: 6588:  "		{",
        -: 6589:  "		int new_size;",
        -: 6590:  "",
        -: 6591:  "		yy_start_stack_depth += YY_START_STACK_INCR;",
        -: 6592:  "		new_size = yy_start_stack_depth * sizeof( int );",
        -: 6593:  "",
        -: 6594:  "		if ( ! yy_start_stack )",
        -: 6595:  "			yy_start_stack = (int *) yy_flex_alloc( new_size );",
        -: 6596:  "",
        -: 6597:  "		else",
        -: 6598:  "			yy_start_stack = (int *) yy_flex_realloc(",
        -: 6599:  "					(void *) yy_start_stack, new_size );",
        -: 6600:  "",
        -: 6601:  "		if ( ! yy_start_stack )",
        -: 6602:  "			YY_FATAL_ERROR(",
        -: 6603:  "			\"out of memory expanding start-condition stack\" );",
        -: 6604:  "		}",
        -: 6605:  "",
        -: 6606:  "	yy_start_stack[yy_start_stack_ptr++] = YY_START;",
        -: 6607:  "",
        -: 6608:  "	BEGIN(new_state);",
        -: 6609:  "	}",
        -: 6610:  "",
        -: 6611:  "",
        -: 6612:  "%-",
        -: 6613:  "static void yy_pop_state()",
        -: 6614:  "%+",
        -: 6615:  "void yyFlexLexer::yy_pop_state()",
        -: 6616:  "%*",
        -: 6617:  "	{",
        -: 6618:  "	if ( --yy_start_stack_ptr < 0 )",
        -: 6619:  "		YY_FATAL_ERROR( \"start-condition stack underflow\" );",
        -: 6620:  "",
        -: 6621:  "	BEGIN(yy_start_stack[yy_start_stack_ptr]);",
        -: 6622:  "	}",
        -: 6623:  "",
        -: 6624:  "",
        -: 6625:  "%-",
        -: 6626:  "static int yy_top_state()",
        -: 6627:  "%+",
        -: 6628:  "int yyFlexLexer::yy_top_state()",
        -: 6629:  "%*",
        -: 6630:  "	{",
        -: 6631:  "	return yy_start_stack[yy_start_stack_ptr - 1];",
        -: 6632:  "	}",
        -: 6633:  "",
        -: 6634:  "",
        -: 6635:  "%-",
        -: 6636:  "#ifdef YY_USE_PROTOS",
        -: 6637:  "static void yy_fatal_error( const char msg[] )",
        -: 6638:  "#else",
        -: 6639:  "static void yy_fatal_error( msg )",
        -: 6640:  "char msg[];",
        -: 6641:  "#endif",
        -: 6642:  "	{",
        -: 6643:  "FILE *err;",  /* ### modified(Jan.24.2001) ### */
        -: 6644:  "	(void) fprintf( err, \"%s\\n\", msg );",
        -: 6645:  "	exit( 1 );",
        -: 6646:  "	}",
        -: 6647:  "",
        -: 6648:  "%+",
        -: 6649:  "",
        -: 6650:  "void yyFlexLexer::LexerError( const char msg[] )",
        -: 6651:  "	{",
        -: 6652:  "	cerr << msg << '\\n';",
        -: 6653:  "	exit( 1 );",
        -: 6654:  "	}",
        -: 6655:  "%*",
        -: 6656:  "",
        -: 6657:  "",
        -: 6658:  "/* Redefine yyless() so it works in section 3 code. */",
        -: 6659:  "",
        -: 6660:  "#undef yyless",
        -: 6661:  "#define yyless(n) \\",
        -: 6662:  "	do \\",
        -: 6663:  "		{ \\",
        -: 6664:  "		/* Undo effects of setting up yytext. */ \\",
        -: 6665:  "		yytext[yyleng] = yy_hold_char; \\",
        -: 6666:  "		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \\",
        -: 6667:  "		yy_hold_char = *yy_c_buf_p; \\",
        -: 6668:  "		*yy_c_buf_p = '\\0'; \\",
        -: 6669:  "		yyleng = n; \\",
        -: 6670:  "		} \\",
        -: 6671:  "	while ( 0 )",
        -: 6672:  "",
        -: 6673:  "",
        -: 6674:  "/* Internal utility routines. */",
        -: 6675:  "",
        -: 6676:  "#ifndef yytext_ptr",
        -: 6677:  "#ifdef YY_USE_PROTOS",
        -: 6678:  "static void yy_flex_strncpy( char *s1, const char *s2, int n )",
        -: 6679:  "#else",
        -: 6680:  "static void yy_flex_strncpy( s1, s2, n )",
        -: 6681:  "char *s1;",
        -: 6682:  "const char *s2;",
        -: 6683:  "int n;",
        -: 6684:  "#endif",
        -: 6685:  "	{",
        -: 6686:  "	register int i;",
        -: 6687:  "	for ( i = 0; i < n; ++i )",
        -: 6688:  "		s1[i] = s2[i];",
        -: 6689:  "	}",
        -: 6690:  "#endif",
        -: 6691:  "",
        -: 6692:  "",
        -: 6693:  "#ifdef YY_USE_PROTOS",
        -: 6694:  "static void *yy_flex_alloc( unsigned int size )",
        -: 6695:  "#else",
        -: 6696:  "static void *yy_flex_alloc( size )",
        -: 6697:  "unsigned int size;",
        -: 6698:  "#endif",
        -: 6699:  "	{",
        -: 6700:  "	return (void *) malloc( size );",
        -: 6701:  "	}",
        -: 6702:  "",
        -: 6703:  "#ifdef YY_USE_PROTOS",
        -: 6704:  "static void *yy_flex_realloc( void *ptr, unsigned int size )",
        -: 6705:  "#else",
        -: 6706:  "static void *yy_flex_realloc( ptr, size )",
        -: 6707:  "void *ptr;",
        -: 6708:  "unsigned int size;",
        -: 6709:  "#endif",
        -: 6710:  "	{",
        -: 6711:  "	return (void *) realloc( ptr, size );",
        -: 6712:  "	}",
        -: 6713:  "",
        -: 6714:  "#ifdef YY_USE_PROTOS",
        -: 6715:  "static void yy_flex_free( void *ptr )",
        -: 6716:  "#else",
        -: 6717:  "static void yy_flex_free( ptr )",
        -: 6718:  "void *ptr;",
        -: 6719:  "#endif",
        -: 6720:  "	{",
        -: 6721:  "	free( ptr );",
        -: 6722:  "	}",
        -: 6723:  0
        -: 6724:};
        -: 6725:/* sym - symbol table routines */
        -: 6726:
        -: 6727:/*-
        -: 6728: * Copyright (c) 1990 The Regents of the University of California.
        -: 6729: * All rights reserved.
        -: 6730: *
        -: 6731: * This code is derived from software contributed to Berkeley by
        -: 6732: * Vern Paxson.
        -: 6733: * 
        -: 6734: * The United States Government has rights in this work pursuant
        -: 6735: * to contract no. DE-AC03-76SF00098 between the United States
        -: 6736: * Department of Energy and the University of California.
        -: 6737: *
        -: 6738: * Redistribution and use in source and binary forms are permitted provided
        -: 6739: * that: (1) source distributions retain this entire copyright notice and
        -: 6740: * comment, and (2) distributions including binaries display the following
        -: 6741: * acknowledgement:  ``This product includes software developed by the
        -: 6742: * University of California, Berkeley and its contributors'' in the
        -: 6743: * documentation or other materials provided with the distribution and in
        -: 6744: * all advertising materials mentioning features or use of this software.
        -: 6745: * Neither the name of the University nor the names of its contributors may
        -: 6746: * be used to endorse or promote products derived from this software without
        -: 6747: * specific prior written permission.
        -: 6748: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 6749: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 6750: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 6751: */
        -: 6752:
        -: 6753:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 6754:
        -: 6755:
        -: 6756:
        -: 6757:/* declare functions that have forward references */
        -: 6758:
        -: 6759:int hashfunct PROTO((register char[], int));
        -: 6760:
        -: 6761:
        -: 6762:struct hash_entry *ndtbl[NAME_TABLE_HASH_SIZE];
        -: 6763:struct hash_entry *sctbl[START_COND_HASH_SIZE];
        -: 6764:struct hash_entry *ccltab[CCL_HASH_SIZE];
        -: 6765:
        -: 6766:struct hash_entry *findsym();
        -: 6767:
        -: 6768:
        -: 6769:/* addsym - add symbol and definitions to symbol table
        -: 6770: *
        -: 6771: * -1 is returned if the symbol already exists, and the change not made.
        -: 6772: */
        -: 6773:
        2: 6774:int addsym( sym, str_def, int_def, table, table_size )
        -: 6775:register char sym[];
        -: 6776:char *str_def;
        -: 6777:int int_def;
        -: 6778:hash_table table;
        -: 6779:int table_size;
        -: 6780:	{
        2: 6781:	int hash_val = hashfunct( sym, table_size );
        2: 6782:	register struct hash_entry *sym_entry = table[hash_val];
        -: 6783:	register struct hash_entry *new_entry;
        -: 6784:	register struct hash_entry *successor;
        -: 6785:
        4: 6786:	while ( sym_entry )
        -: 6787:		{
    #####: 6788:		if ( ! strcmp( sym, sym_entry->name ) )
        -: 6789:			{ /* entry already exists */
    #####: 6790:			return -1;
        -: 6791:			}
        -: 6792:
    #####: 6793:		sym_entry = sym_entry->next;
        -: 6794:		}
        -: 6795:
        -: 6796:	/* create new entry */
        2: 6797:	new_entry = (struct hash_entry *)
        -: 6798:		flex_alloc( sizeof( struct hash_entry ) );
        -: 6799:
        2: 6800:	if ( new_entry == NULL )
    #####: 6801:		flexfatal( "symbol table memory allocation failed" );
        -: 6802:
        2: 6803:	if ( (successor = table[hash_val]) )
        -: 6804:		{
    #####: 6805:		new_entry->next = successor;
    #####: 6806:		successor->prev = new_entry;
        -: 6807:		}
        -: 6808:	else
        2: 6809:		new_entry->next = NULL;
        -: 6810:
        2: 6811:	new_entry->prev = NULL;
        2: 6812:	new_entry->name = sym;
        2: 6813:	new_entry->str_val = str_def;
        2: 6814:	new_entry->int_val = int_def;
        -: 6815:
        2: 6816:	table[hash_val] = new_entry;
        -: 6817:
        2: 6818:	return 0;
        -: 6819:	}
        -: 6820:
        -: 6821:
        -: 6822:/* cclinstal - save the text of a character class */
        -: 6823:
    #####: 6824:void cclinstal( ccltxt, cclnum )
        -: 6825:Char ccltxt[];
        -: 6826:int cclnum;
        -: 6827:	{
        -: 6828:	/* We don't bother checking the return status because we are not
        -: 6829:	 * called unless the symbol is new.
        -: 6830:	 */
        -: 6831:	Char *copy_unsigned_string();
        -: 6832:
    #####: 6833:	(void) addsym( (char *) copy_unsigned_string( ccltxt ),
        -: 6834:			(char *) 0, cclnum,
        -: 6835:			ccltab, CCL_HASH_SIZE );
    #####: 6836:	}
        -: 6837:
        -: 6838:
        -: 6839:/* ccllookup - lookup the number associated with character class text
        -: 6840: *
        -: 6841: * Returns 0 if there's no CCL associated with the text.
        -: 6842: */
        -: 6843:
    #####: 6844:int ccllookup( ccltxt )
        -: 6845:Char ccltxt[];
        -: 6846:	{
    #####: 6847:	return findsym( (char *) ccltxt, ccltab, CCL_HASH_SIZE )->int_val;
        -: 6848:	}
        -: 6849:
        -: 6850:
        -: 6851:/* findsym - find symbol in symbol table */
        -: 6852:
        2: 6853:struct hash_entry *findsym( sym, table, table_size )
        -: 6854:register char sym[];
        -: 6855:hash_table table;
        -: 6856:int table_size;
        -: 6857:	{
        -: 6858:	static struct hash_entry empty_entry =
        -: 6859:		{
        -: 6860:		(struct hash_entry *) 0, (struct hash_entry *) 0,
        -: 6861:		(char *) 0, (char *) 0, 0,
        -: 6862:		} ;
        2: 6863:	register struct hash_entry *sym_entry =
        2: 6864:		table[hashfunct( sym, table_size )];
        -: 6865:
        4: 6866:	while ( sym_entry )
        -: 6867:		{
        2: 6868:		if ( ! strcmp( sym, sym_entry->name ) )
        2: 6869:			return sym_entry;
    #####: 6870:		sym_entry = sym_entry->next;
        -: 6871:		}
        -: 6872:
    #####: 6873:	return &empty_entry;
        -: 6874:	}
        -: 6875:
        -: 6876:    
        -: 6877:/* hashfunct - compute the hash value for "str" and hash size "hash_size" */
        -: 6878:
        4: 6879:int hashfunct( str, hash_size )
        -: 6880:register char str[];
        -: 6881:int hash_size;
        -: 6882:	{
        -: 6883:	register int hashval;
        -: 6884:	register int locstr;
        -: 6885:
        4: 6886:	hashval = 0;
        4: 6887:	locstr = 0;
        -: 6888:
       30: 6889:	while ( str[locstr] )
        -: 6890:		{
       22: 6891:		hashval = (hashval << 1) + (unsigned char) str[locstr++];
       22: 6892:		hashval %= hash_size;
        -: 6893:		}
        -: 6894:
        4: 6895:	return hashval;
        -: 6896:	}
        -: 6897:
        -: 6898:
        -: 6899:/* ndinstal - install a name definition */
        -: 6900:
    #####: 6901:void ndinstal( name, definition )
        -: 6902:char name[];
        -: 6903:Char definition[];
        -: 6904:	{
        -: 6905:	char *copy_string();
        -: 6906:	Char *copy_unsigned_string();
        -: 6907:
    #####: 6908:	if ( addsym( copy_string( name ),
    #####: 6909:			(char *) copy_unsigned_string( definition ), 0,
        -: 6910:			ndtbl, NAME_TABLE_HASH_SIZE ) )
    #####: 6911:		synerr( "name defined twice" );
    #####: 6912:	}
        -: 6913:
        -: 6914:
        -: 6915:/* ndlookup - lookup a name definition
        -: 6916: *
        -: 6917: * Returns a nil pointer if the name definition does not exist.
        -: 6918: */
        -: 6919:
    #####: 6920:Char *ndlookup( nd )
        -: 6921:char nd[];
        -: 6922:	{
    #####: 6923:	return (Char *) findsym( nd, ndtbl, NAME_TABLE_HASH_SIZE )->str_val;
        -: 6924:	}
        -: 6925:
        -: 6926:
        -: 6927:/* scextend - increase the maximum number of start conditions */
        -: 6928:
    #####: 6929:void scextend()
        -: 6930:	{
    #####: 6931:	current_max_scs += MAX_SCS_INCREMENT;
        -: 6932:
    #####: 6933:	++num_reallocs;
        -: 6934:
    #####: 6935:	scset = reallocate_integer_array( scset, current_max_scs );
    #####: 6936:	scbol = reallocate_integer_array( scbol, current_max_scs );
    #####: 6937:	scxclu = reallocate_integer_array( scxclu, current_max_scs );
    #####: 6938:	sceof = reallocate_integer_array( sceof, current_max_scs );
    #####: 6939:	scname = reallocate_char_ptr_array( scname, current_max_scs );
    #####: 6940:	actvsc = reallocate_integer_array( actvsc, current_max_scs );
    #####: 6941:	}
        -: 6942:
        -: 6943:
        -: 6944:/* scinstal - make a start condition
        -: 6945: *
        -: 6946: * NOTE
        -: 6947: *    The start condition is "exclusive" if xcluflg is true.
        -: 6948: */
        -: 6949:
        2: 6950:void scinstal( str, xcluflg )
        -: 6951:char str[];
        -: 6952:int xcluflg;
        -: 6953:	{
        -: 6954:	char *copy_string();
        -: 6955:
        -: 6956:	/* Generate start condition definition, for use in BEGIN et al. */
        2: 6957:	printf( "#define %s %d\n", str, lastsc );
        -: 6958:
        2: 6959:	if ( ++lastsc >= current_max_scs )
    #####: 6960:		scextend();
        -: 6961:
        2: 6962:	scname[lastsc] = copy_string( str );
        -: 6963:
        2: 6964:	if ( addsym( scname[lastsc], (char *) 0, lastsc,
        -: 6965:			sctbl, START_COND_HASH_SIZE ) )
    #####: 6966:		format_pinpoint_message( "start condition %s declared twice",
        -: 6967:					str );
        -: 6968:
        2: 6969:	scset[lastsc] = mkstate( SYM_EPSILON );
        2: 6970:	scbol[lastsc] = mkstate( SYM_EPSILON );
        2: 6971:	scxclu[lastsc] = xcluflg;
        2: 6972:	sceof[lastsc] = false;
        2: 6973:	}
        -: 6974:
        -: 6975:
        -: 6976:/* sclookup - lookup the number associated with a start condition
        -: 6977: *
        -: 6978: * Returns 0 if no such start condition.
        -: 6979: */
        -: 6980:
        2: 6981:int sclookup( str )
        -: 6982:char str[];
        -: 6983:	{
        2: 6984:	return findsym( str, sctbl, START_COND_HASH_SIZE )->int_val;
        -: 6985:	}
        -: 6986:/* tblcmp - table compression routines */
        -: 6987:
        -: 6988:/*-
        -: 6989: * Copyright (c) 1990 The Regents of the University of California.
        -: 6990: * All rights reserved.
        -: 6991: *
        -: 6992: * This code is derived from software contributed to Berkeley by
        -: 6993: * Vern Paxson.
        -: 6994: * 
        -: 6995: * The United States Government has rights in this work pursuant
        -: 6996: * to contract no. DE-AC03-76SF00098 between the United States
        -: 6997: * Department of Energy and the University of California.
        -: 6998: *
        -: 6999: * Redistribution and use in source and binary forms are permitted provided
        -: 7000: * that: (1) source distributions retain this entire copyright notice and
        -: 7001: * comment, and (2) distributions including binaries display the following
        -: 7002: * acknowledgement:  ``This product includes software developed by the
        -: 7003: * University of California, Berkeley and its contributors'' in the
        -: 7004: * documentation or other materials provided with the distribution and in
        -: 7005: * all advertising materials mentioning features or use of this software.
        -: 7006: * Neither the name of the University nor the names of its contributors may
        -: 7007: * be used to endorse or promote products derived from this software without
        -: 7008: * specific prior written permission.
        -: 7009: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 7010: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 7011: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 7012: */
        -: 7013:
        -: 7014:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 7015:
        -: 7016:
        -: 7017:
        -: 7018:/* declarations for functions that have forward references */
        -: 7019:
        -: 7020:void mkentry PROTO((register int*, int, int, int, int));
        -: 7021:void mkprot PROTO((int[], int, int));
        -: 7022:void mktemplate PROTO((int[], int, int));
        -: 7023:void mv2front PROTO((int));
        -: 7024:int tbldiff PROTO((int[], int, int[]));
        -: 7025:
        -: 7026:
        -: 7027:/* bldtbl - build table entries for dfa state
        -: 7028: *
        -: 7029: * synopsis
        -: 7030: *   int state[numecs], statenum, totaltrans, comstate, comfreq;
        -: 7031: *   bldtbl( state, statenum, totaltrans, comstate, comfreq );
        -: 7032: *
        -: 7033: * State is the statenum'th dfa state.  It is indexed by equivalence class and
        -: 7034: * gives the number of the state to enter for a given equivalence class.
        -: 7035: * totaltrans is the total number of transitions out of the state.  Comstate
        -: 7036: * is that state which is the destination of the most transitions out of State.
        -: 7037: * Comfreq is how many transitions there are out of State to Comstate.
        -: 7038: *
        -: 7039: * A note on terminology:
        -: 7040: *    "protos" are transition tables which have a high probability of
        -: 7041: * either being redundant (a state processed later will have an identical
        -: 7042: * transition table) or nearly redundant (a state processed later will have
        -: 7043: * many of the same out-transitions).  A "most recently used" queue of
        -: 7044: * protos is kept around with the hope that most states will find a proto
        -: 7045: * which is similar enough to be usable, and therefore compacting the
        -: 7046: * output tables.
        -: 7047: *    "templates" are a special type of proto.  If a transition table is
        -: 7048: * homogeneous or nearly homogeneous (all transitions go to the same
        -: 7049: * destination) then the odds are good that future states will also go
        -: 7050: * to the same destination state on basically the same character set.
        -: 7051: * These homogeneous states are so common when dealing with large rule
        -: 7052: * sets that they merit special attention.  If the transition table were
        -: 7053: * simply made into a proto, then (typically) each subsequent, similar
        -: 7054: * state will differ from the proto for two out-transitions.  One of these
        -: 7055: * out-transitions will be that character on which the proto does not go
        -: 7056: * to the common destination, and one will be that character on which the
        -: 7057: * state does not go to the common destination.  Templates, on the other
        -: 7058: * hand, go to the common state on EVERY transition character, and therefore
        -: 7059: * cost only one difference.
        -: 7060: */
        -: 7061:
        5: 7062:void bldtbl( state, statenum, totaltrans, comstate, comfreq )
        -: 7063:int state[], statenum, totaltrans, comstate, comfreq;
        -: 7064:	{
        -: 7065:	int extptr, extrct[2][CSIZE + 1];
        -: 7066:	int mindiff, minprot, i, d;
        -: 7067:
        -: 7068:	/* If extptr is 0 then the first array of extrct holds the result
        -: 7069:	 * of the "best difference" to date, which is those transitions
        -: 7070:	 * which occur in "state" but not in the proto which, to date,
        -: 7071:	 * has the fewest differences between itself and "state".  If
        -: 7072:	 * extptr is 1 then the second array of extrct hold the best
        -: 7073:	 * difference.  The two arrays are toggled between so that the
        -: 7074:	 * best difference to date can be kept around and also a difference
        -: 7075:	 * just created by checking against a candidate "best" proto.
        -: 7076:	 */
        -: 7077:
        5: 7078:	extptr = 0;
        -: 7079:
        -: 7080:	/* If the state has too few out-transitions, don't bother trying to
        -: 7081:	 * compact its tables.
        -: 7082:	 */
        -: 7083:
        5: 7084:	if ( (totaltrans * 100) < (numecs * PROTO_SIZE_PERCENTAGE) )
        1: 7085:		mkentry( state, numecs, statenum, JAMSTATE, totaltrans );
        -: 7086:
        -: 7087:	else
        -: 7088:		{
        -: 7089:		/* "checkcom" is true if we should only check "state" against
        -: 7090:		 * protos which have the same "comstate" value.
        -: 7091:		 */
        4: 7092:		int checkcom =
        4: 7093:			comfreq * 100 > totaltrans * CHECK_COM_PERCENTAGE;
        -: 7094:
        4: 7095:		minprot = firstprot;
        4: 7096:		mindiff = totaltrans;
        -: 7097:
        4: 7098:		if ( checkcom )
        -: 7099:			{
        -: 7100:			/* Find first proto which has the same "comstate". */
        4: 7101:			for ( i = firstprot; i != NIL; i = protnext[i] )
        3: 7102:				if ( protcomst[i] == comstate )
        -: 7103:					{
        3: 7104:					minprot = i;
        3: 7105:					mindiff = tbldiff( state, minprot,
        3: 7106:							extrct[extptr] );
        3: 7107:					break;
        -: 7108:					}
        -: 7109:			}
        -: 7110:
        -: 7111:		else
        -: 7112:			{
        -: 7113:			/* Since we've decided that the most common destination
        -: 7114:			 * out of "state" does not occur with a high enough
        -: 7115:			 * frequency, we set the "comstate" to zero, assuring
        -: 7116:			 * that if this state is entered into the proto list,
        -: 7117:			 * it will not be considered a template.
        -: 7118:			 */
    #####: 7119:			comstate = 0;
        -: 7120:
    #####: 7121:			if ( firstprot != NIL )
        -: 7122:				{
    #####: 7123:				minprot = firstprot;
    #####: 7124:				mindiff = tbldiff( state, minprot,
    #####: 7125:						extrct[extptr] );
        -: 7126:				}
        -: 7127:			}
        -: 7128:
        -: 7129:		/* We now have the first interesting proto in "minprot".  If
        -: 7130:		 * it matches within the tolerances set for the first proto,
        -: 7131:		 * we don't want to bother scanning the rest of the proto list
        -: 7132:		 * to see if we have any other reasonable matches.
        -: 7133:		 */
        -: 7134:
        4: 7135:		if ( mindiff * 100 > totaltrans * FIRST_MATCH_DIFF_PERCENTAGE )
        -: 7136:			{
        -: 7137:			/* Not a good enough match.  Scan the rest of the
        -: 7138:			 * protos.
        -: 7139:			 */
        1: 7140:			for ( i = minprot; i != NIL; i = protnext[i] )
        -: 7141:				{
    #####: 7142:				d = tbldiff( state, i, extrct[1 - extptr] );
    #####: 7143:				if ( d < mindiff )
        -: 7144:					{
    #####: 7145:					extptr = 1 - extptr;
    #####: 7146:					mindiff = d;
    #####: 7147:					minprot = i;
        -: 7148:					}
        -: 7149:				}
        -: 7150:			}
        -: 7151:
        -: 7152:		/* Check if the proto we've decided on as our best bet is close
        -: 7153:		 * enough to the state we want to match to be usable.
        -: 7154:		 */
        -: 7155:
        4: 7156:		if ( mindiff * 100 > totaltrans * ACCEPTABLE_DIFF_PERCENTAGE )
        -: 7157:			{
        -: 7158:			/* No good.  If the state is homogeneous enough,
        -: 7159:			 * we make a template out of it.  Otherwise, we
        -: 7160:			 * make a proto.
        -: 7161:			 */
        -: 7162:
        2: 7163:			if ( comfreq * 100 >=
        1: 7164:			     totaltrans * TEMPLATE_SAME_PERCENTAGE )
        1: 7165:				mktemplate( state, statenum, comstate );
        -: 7166:
        -: 7167:			else
        -: 7168:				{
    #####: 7169:				mkprot( state, statenum, comstate );
    #####: 7170:				mkentry( state, numecs, statenum,
        -: 7171:					JAMSTATE, totaltrans );
        -: 7172:				}
        -: 7173:			}
        -: 7174:
        -: 7175:		else
        -: 7176:			{ /* use the proto */
        3: 7177:			mkentry( extrct[extptr], numecs, statenum,
        -: 7178:				prottbl[minprot], mindiff );
        -: 7179:
        -: 7180:			/* If this state was sufficiently different from the
        -: 7181:			 * proto we built it from, make it, too, a proto.
        -: 7182:			 */
        -: 7183:
        6: 7184:			if ( mindiff * 100 >=
        3: 7185:			     totaltrans * NEW_PROTO_DIFF_PERCENTAGE )
    #####: 7186:				mkprot( state, statenum, comstate );
        -: 7187:
        -: 7188:			/* Since mkprot added a new proto to the proto queue,
        -: 7189:			 * it's possible that "minprot" is no longer on the
        -: 7190:			 * proto queue (if it happened to have been the last
        -: 7191:			 * entry, it would have been bumped off).  If it's
        -: 7192:			 * not there, then the new proto took its physical
        -: 7193:			 * place (though logically the new proto is at the
        -: 7194:			 * beginning of the queue), so in that case the
        -: 7195:			 * following call will do nothing.
        -: 7196:			 */
        -: 7197:
        3: 7198:			mv2front( minprot );
        -: 7199:			}
        -: 7200:		}
        5: 7201:	}
        -: 7202:
        -: 7203:
        -: 7204:/* cmptmps - compress template table entries
        -: 7205: *
        -: 7206: * Template tables are compressed by using the 'template equivalence
        -: 7207: * classes', which are collections of transition character equivalence
        -: 7208: * classes which always appear together in templates - really meta-equivalence
        -: 7209: * classes.
        -: 7210: */
        -: 7211:
        1: 7212:void cmptmps()
        -: 7213:	{
        -: 7214:	int tmpstorage[CSIZE + 1];
        1: 7215:	register int *tmp = tmpstorage, i, j;
        -: 7216:	int totaltrans, trans;
        -: 7217:
        1: 7218:	peakpairs = numtemps * numecs + tblend;
        -: 7219:
        1: 7220:	if ( usemecs )
        -: 7221:		{
        -: 7222:		/* Create equivalence classes based on data gathered on
        -: 7223:		 * template transitions.
        -: 7224:		 */
        1: 7225:		nummecs = cre8ecs( tecfwd, tecbck, numecs );
        -: 7226:		}
        -: 7227:
        -: 7228:	else
    #####: 7229:		nummecs = numecs;
        -: 7230:
        2: 7231:	while ( lastdfa + numtemps + 1 >= current_max_dfas )
    #####: 7232:		increase_max_dfas();
        -: 7233:
        -: 7234:	/* Loop through each template. */
        -: 7235:
        2: 7236:	for ( i = 1; i <= numtemps; ++i )
        -: 7237:		{
        -: 7238:		/* Number of non-jam transitions out of this template. */
        1: 7239:		totaltrans = 0;
        -: 7240:
        2: 7241:		for ( j = 1; j <= numecs; ++j )
        -: 7242:			{
        1: 7243:			trans = tnxt[numecs * i + j];
        -: 7244:
        1: 7245:			if ( usemecs )
        -: 7246:				{
        -: 7247:				/* The absolute value of tecbck is the
        -: 7248:				 * meta-equivalence class of a given
        -: 7249:				 * equivalence class, as set up by cre8ecs().
        -: 7250:				 */
        1: 7251:				if ( tecbck[j] > 0 )
        -: 7252:					{
        1: 7253:					tmp[tecbck[j]] = trans;
        -: 7254:
        1: 7255:					if ( trans > 0 )
        1: 7256:						++totaltrans;
        -: 7257:					}
        -: 7258:				}
        -: 7259:
        -: 7260:			else
        -: 7261:				{
    #####: 7262:				tmp[j] = trans;
        -: 7263:
    #####: 7264:				if ( trans > 0 )
    #####: 7265:					++totaltrans;
        -: 7266:				}
        -: 7267:			}
        -: 7268:
        -: 7269:		/* It is assumed (in a rather subtle way) in the skeleton
        -: 7270:		 * that if we're using meta-equivalence classes, the def[]
        -: 7271:		 * entry for all templates is the jam template, i.e.,
        -: 7272:		 * templates never default to other non-jam table entries
        -: 7273:		 * (e.g., another template)
        -: 7274:		 */
        -: 7275:
        -: 7276:		/* Leave room for the jam-state after the last real state. */
        1: 7277:		mkentry( tmp, nummecs, lastdfa + i + 1, JAMSTATE, totaltrans );
        -: 7278:		}
        1: 7279:	}
        -: 7280:
        -: 7281:
        -: 7282:
        -: 7283:/* expand_nxt_chk - expand the next check arrays */
        -: 7284:
    #####: 7285:void expand_nxt_chk()
        -: 7286:	{
    #####: 7287:	register int old_max = current_max_xpairs;
        -: 7288:
    #####: 7289:	current_max_xpairs += MAX_XPAIRS_INCREMENT;
        -: 7290:
    #####: 7291:	++num_reallocs;
        -: 7292:
    #####: 7293:	nxt = reallocate_integer_array( nxt, current_max_xpairs );
    #####: 7294:	chk = reallocate_integer_array( chk, current_max_xpairs );
        -: 7295:
    #####: 7296:	zero_out( (char *) (chk + old_max),
        -: 7297:		MAX_XPAIRS_INCREMENT * sizeof( int ) / sizeof( char ) );
    #####: 7298:	}
        -: 7299:
        -: 7300:
        -: 7301:/* find_table_space - finds a space in the table for a state to be placed
        -: 7302: *
        -: 7303: * synopsis
        -: 7304: *     int *state, numtrans, block_start;
        -: 7305: *     int find_table_space();
        -: 7306: *
        -: 7307: *     block_start = find_table_space( state, numtrans );
        -: 7308: *
        -: 7309: * State is the state to be added to the full speed transition table.
        -: 7310: * Numtrans is the number of out-transitions for the state.
        -: 7311: *
        -: 7312: * find_table_space() returns the position of the start of the first block (in
        -: 7313: * chk) able to accommodate the state
        -: 7314: *
        -: 7315: * In determining if a state will or will not fit, find_table_space() must take
        -: 7316: * into account the fact that an end-of-buffer state will be added at [0],
        -: 7317: * and an action number will be added in [-1].
        -: 7318: */
        -: 7319:
    #####: 7320:int find_table_space( state, numtrans )
        -: 7321:int *state, numtrans;
        -: 7322:	{
        -: 7323:	/* Firstfree is the position of the first possible occurrence of two
        -: 7324:	 * consecutive unused records in the chk and nxt arrays.
        -: 7325:	 */
        -: 7326:	register int i;
        -: 7327:	register int *state_ptr, *chk_ptr;
        -: 7328:	register int *ptr_to_last_entry_in_state;
        -: 7329:
        -: 7330:	/* If there are too many out-transitions, put the state at the end of
        -: 7331:	 * nxt and chk.
        -: 7332:	 */
    #####: 7333:	if ( numtrans > MAX_XTIONS_FULL_INTERIOR_FIT )
        -: 7334:		{
        -: 7335:		/* If table is empty, return the first available spot in
        -: 7336:		 * chk/nxt, which should be 1.
        -: 7337:		 */
    #####: 7338:		if ( tblend < 2 )
    #####: 7339:			return 1;
        -: 7340:
        -: 7341:		/* Start searching for table space near the end of
        -: 7342:		 * chk/nxt arrays.
        -: 7343:		 */
    #####: 7344:		i = tblend - numecs;
        -: 7345:		}
        -: 7346:
        -: 7347:	else
        -: 7348:		/* Start searching for table space from the beginning
        -: 7349:		 * (skipping only the elements which will definitely not
        -: 7350:		 * hold the new state).
        -: 7351:		 */
    #####: 7352:		i = firstfree;
        -: 7353:
        -: 7354:	while ( 1 )	/* loops until a space is found */
        -: 7355:		{
    #####: 7356:		while ( i + numecs >= current_max_xpairs )
    #####: 7357:			expand_nxt_chk();
        -: 7358:
        -: 7359:		/* Loops until space for end-of-buffer and action number
        -: 7360:		 * are found.
        -: 7361:		 */
        -: 7362:		while ( 1 )
        -: 7363:			{
        -: 7364:			/* Check for action number space. */
    #####: 7365:			if ( chk[i - 1] == 0 )
        -: 7366:				{
        -: 7367:				/* Check for end-of-buffer space. */
    #####: 7368:				if ( chk[i] == 0 )
    #####: 7369:					break;
        -: 7370:
        -: 7371:				else
        -: 7372:					/* Since i != 0, there is no use
        -: 7373:					 * checking to see if (++i) - 1 == 0,
        -: 7374:					 * because that's the same as i == 0,
        -: 7375:					 * so we skip a space.
        -: 7376:					 */
    #####: 7377:					i += 2;
        -: 7378:				}
        -: 7379:
        -: 7380:			else
    #####: 7381:				++i;
        -: 7382:
    #####: 7383:			while ( i + numecs >= current_max_xpairs )
    #####: 7384:				expand_nxt_chk();
    #####: 7385:			}
        -: 7386:
        -: 7387:		/* If we started search from the beginning, store the new
        -: 7388:		 * firstfree for the next call of find_table_space().
        -: 7389:		 */
    #####: 7390:		if ( numtrans <= MAX_XTIONS_FULL_INTERIOR_FIT )
    #####: 7391:			firstfree = i + 1;
        -: 7392:
        -: 7393:		/* Check to see if all elements in chk (and therefore nxt)
        -: 7394:		 * that are needed for the new state have not yet been taken.
        -: 7395:		 */
        -: 7396:
    #####: 7397:		state_ptr = &state[1];
    #####: 7398:		ptr_to_last_entry_in_state = &chk[i + numecs + 1];
        -: 7399:
    #####: 7400:		for ( chk_ptr = &chk[i + 1];
    #####: 7401:		      chk_ptr != ptr_to_last_entry_in_state; ++chk_ptr )
    #####: 7402:			if ( *(state_ptr++) != 0 && *chk_ptr != 0 )
    #####: 7403:				break;
        -: 7404:
    #####: 7405:		if ( chk_ptr == ptr_to_last_entry_in_state )
    #####: 7406:			return i;
        -: 7407:
        -: 7408:		else
    #####: 7409:		++i;
    #####: 7410:		}
        -: 7411:	}
        -: 7412:
        -: 7413:
        -: 7414:/* inittbl - initialize transition tables
        -: 7415: *
        -: 7416: * Initializes "firstfree" to be one beyond the end of the table.  Initializes
        -: 7417: * all "chk" entries to be zero.
        -: 7418: */
        1: 7419:void inittbl()
        -: 7420:	{
        -: 7421:	register int i;
        -: 7422:
        1: 7423:	zero_out( (char *) chk,
        -: 7424:		current_max_xpairs * sizeof( int ) / sizeof( char ) );
        -: 7425:
        1: 7426:	tblend = 0;
        1: 7427:	firstfree = tblend + 1;
        1: 7428:	numtemps = 0;
        -: 7429:
        1: 7430:	if ( usemecs )
        -: 7431:		{
        -: 7432:		/* Set up doubly-linked meta-equivalence classes; these
        -: 7433:		 * are sets of equivalence classes which all have identical
        -: 7434:		 * transitions out of TEMPLATES.
        -: 7435:		 */
        -: 7436:
        1: 7437:		tecbck[1] = NIL;
        -: 7438:
        1: 7439:		for ( i = 2; i <= numecs; ++i )
        -: 7440:			{
    #####: 7441:			tecbck[i] = i - 1;
    #####: 7442:			tecfwd[i - 1] = i;
        -: 7443:			}
        -: 7444:
        1: 7445:		tecfwd[numecs] = NIL;
        -: 7446:		}
        1: 7447:	}
        -: 7448:
        -: 7449:
        -: 7450:/* mkdeftbl - make the default, "jam" table entries */
        -: 7451:
        1: 7452:void mkdeftbl()
        -: 7453:	{
        -: 7454:	int i;
        -: 7455:
        1: 7456:	jamstate = lastdfa + 1;
        -: 7457:
        1: 7458:	++tblend; /* room for transition on end-of-buffer character */
        -: 7459:
        2: 7460:	while ( tblend + numecs >= current_max_xpairs )
    #####: 7461:		expand_nxt_chk();
        -: 7462:
        -: 7463:	/* Add in default end-of-buffer transition. */
        1: 7464:	nxt[tblend] = end_of_buffer_state;
        1: 7465:	chk[tblend] = jamstate;
        -: 7466:
        2: 7467:	for ( i = 1; i <= numecs; ++i )
        -: 7468:		{
        1: 7469:		nxt[tblend + i] = 0;
        1: 7470:		chk[tblend + i] = jamstate;
        -: 7471:		}
        -: 7472:
        1: 7473:	jambase = tblend;
        -: 7474:
        1: 7475:	base[jamstate] = jambase;
        1: 7476:	def[jamstate] = 0;
        -: 7477:
        1: 7478:	tblend += numecs;
        1: 7479:	++numtemps;
        1: 7480:	}
        -: 7481:
        -: 7482:
        -: 7483:/* mkentry - create base/def and nxt/chk entries for transition array
        -: 7484: *
        -: 7485: * synopsis
        -: 7486: *   int state[numchars + 1], numchars, statenum, deflink, totaltrans;
        -: 7487: *   mkentry( state, numchars, statenum, deflink, totaltrans );
        -: 7488: *
        -: 7489: * "state" is a transition array "numchars" characters in size, "statenum"
        -: 7490: * is the offset to be used into the base/def tables, and "deflink" is the
        -: 7491: * entry to put in the "def" table entry.  If "deflink" is equal to
        -: 7492: * "JAMSTATE", then no attempt will be made to fit zero entries of "state"
        -: 7493: * (i.e., jam entries) into the table.  It is assumed that by linking to
        -: 7494: * "JAMSTATE" they will be taken care of.  In any case, entries in "state"
        -: 7495: * marking transitions to "SAME_TRANS" are treated as though they will be
        -: 7496: * taken care of by whereever "deflink" points.  "totaltrans" is the total
        -: 7497: * number of transitions out of the state.  If it is below a certain threshold,
        -: 7498: * the tables are searched for an interior spot that will accommodate the
        -: 7499: * state array.
        -: 7500: */
        -: 7501:
        6: 7502:void mkentry( state, numchars, statenum, deflink, totaltrans )
        -: 7503:register int *state;
        -: 7504:int numchars, statenum, deflink, totaltrans;
        -: 7505:	{
        -: 7506:	register int minec, maxec, i, baseaddr;
        -: 7507:	int tblbase, tbllast;
        -: 7508:
        6: 7509:	if ( totaltrans == 0 )
        -: 7510:		{ /* there are no out-transitions */
        5: 7511:		if ( deflink == JAMSTATE )
        1: 7512:			base[statenum] = JAMSTATE;
        -: 7513:		else
        4: 7514:			base[statenum] = 0;
        -: 7515:
        5: 7516:		def[statenum] = deflink;
        5: 7517:		return;
        -: 7518:		}
        -: 7519:
        1: 7520:	for ( minec = 1; minec <= numchars; ++minec )
        -: 7521:		{
        1: 7522:		if ( state[minec] != SAME_TRANS )
        1: 7523:			if ( state[minec] != 0 || deflink != JAMSTATE )
        -: 7524:				break;
        -: 7525:		}
        -: 7526:
        1: 7527:	if ( totaltrans == 1 )
        -: 7528:		{
        -: 7529:		/* There's only one out-transition.  Save it for later to fill
        -: 7530:		 * in holes in the tables.
        -: 7531:		 */
        1: 7532:		stack1( statenum, minec, state[minec], deflink );
        1: 7533:		return;
        -: 7534:		}
        -: 7535:
    #####: 7536:	for ( maxec = numchars; maxec > 0; --maxec )
        -: 7537:		{
    #####: 7538:		if ( state[maxec] != SAME_TRANS )
    #####: 7539:			if ( state[maxec] != 0 || deflink != JAMSTATE )
        -: 7540:				break;
        -: 7541:		}
        -: 7542:
        -: 7543:	/* Whether we try to fit the state table in the middle of the table
        -: 7544:	 * entries we have already generated, or if we just take the state
        -: 7545:	 * table at the end of the nxt/chk tables, we must make sure that we
        -: 7546:	 * have a valid base address (i.e., non-negative).  Note that
        -: 7547:	 * negative base addresses dangerous at run-time (because indexing
        -: 7548:	 * the nxt array with one and a low-valued character will access
        -: 7549:	 * memory before the start of the array.
        -: 7550:	 */
        -: 7551:
        -: 7552:	/* Find the first transition of state that we need to worry about. */
    #####: 7553:	if ( totaltrans * 100 <= numchars * INTERIOR_FIT_PERCENTAGE )
        -: 7554:		{
        -: 7555:		/* Attempt to squeeze it into the middle of the tables. */
    #####: 7556:		baseaddr = firstfree;
        -: 7557:
    #####: 7558:		while ( baseaddr < minec )
        -: 7559:			{
        -: 7560:			/* Using baseaddr would result in a negative base
        -: 7561:			 * address below; find the next free slot.
        -: 7562:			 */
    #####: 7563:			for ( ++baseaddr; chk[baseaddr] != 0; ++baseaddr )
        -: 7564:				;
        -: 7565:			}
        -: 7566:
    #####: 7567:		while ( baseaddr + maxec - minec + 1 >= current_max_xpairs )
    #####: 7568:			expand_nxt_chk();
        -: 7569:
    #####: 7570:		for ( i = minec; i <= maxec; ++i )
    #####: 7571:			if ( state[i] != SAME_TRANS &&
    #####: 7572:			     (state[i] != 0 || deflink != JAMSTATE) &&
    #####: 7573:			     chk[baseaddr + i - minec] != 0 )
        -: 7574:				{ /* baseaddr unsuitable - find another */
    #####: 7575:				for ( ++baseaddr;
    #####: 7576:				      baseaddr < current_max_xpairs &&
    #####: 7577:				      chk[baseaddr] != 0; ++baseaddr )
        -: 7578:					;
        -: 7579:
    #####: 7580:				while ( baseaddr + maxec - minec + 1 >=
        -: 7581:					current_max_xpairs )
    #####: 7582:					expand_nxt_chk();
        -: 7583:
        -: 7584:				/* Reset the loop counter so we'll start all
        -: 7585:				 * over again next time it's incremented.
        -: 7586:				 */
        -: 7587:
    #####: 7588:				i = minec - 1;
        -: 7589:				}
        -: 7590:		}
        -: 7591:
        -: 7592:	else
        -: 7593:		{
        -: 7594:		/* Ensure that the base address we eventually generate is
        -: 7595:		 * non-negative.
        -: 7596:		 */
    #####: 7597:		baseaddr = MAX( tblend + 1, minec );
        -: 7598:		}
        -: 7599:
    #####: 7600:	tblbase = baseaddr - minec;
    #####: 7601:	tbllast = tblbase + maxec;
        -: 7602:
    #####: 7603:	while ( tbllast + 1 >= current_max_xpairs )
    #####: 7604:		expand_nxt_chk();
        -: 7605:
    #####: 7606:	base[statenum] = tblbase;
    #####: 7607:	def[statenum] = deflink;
        -: 7608:
    #####: 7609:	for ( i = minec; i <= maxec; ++i )
    #####: 7610:		if ( state[i] != SAME_TRANS )
    #####: 7611:			if ( state[i] != 0 || deflink != JAMSTATE )
        -: 7612:				{
    #####: 7613:				nxt[tblbase + i] = state[i];
    #####: 7614:				chk[tblbase + i] = statenum;
        -: 7615:				}
        -: 7616:
    #####: 7617:	if ( baseaddr == firstfree )
        -: 7618:		/* Find next free slot in tables. */
    #####: 7619:		for ( ++firstfree; chk[firstfree] != 0; ++firstfree )
        -: 7620:			;
        -: 7621:
    #####: 7622:	tblend = MAX( tblend, tbllast );
        -: 7623:	}
        -: 7624:
        -: 7625:
        -: 7626:/* mk1tbl - create table entries for a state (or state fragment) which
        -: 7627: *            has only one out-transition
        -: 7628: */
        -: 7629:
        2: 7630:void mk1tbl( state, sym, onenxt, onedef )
        -: 7631:int state, sym, onenxt, onedef;
        -: 7632:	{
        2: 7633:	if ( firstfree < sym )
    #####: 7634:		firstfree = sym;
        -: 7635:
        4: 7636:	while ( chk[firstfree] != 0 )
    #####: 7637:		if ( ++firstfree >= current_max_xpairs )
    #####: 7638:			expand_nxt_chk();
        -: 7639:
        2: 7640:	base[state] = firstfree - sym;
        2: 7641:	def[state] = onedef;
        2: 7642:	chk[firstfree] = state;
        2: 7643:	nxt[firstfree] = onenxt;
        -: 7644:
        2: 7645:	if ( firstfree > tblend )
        -: 7646:		{
        2: 7647:		tblend = firstfree++;
        -: 7648:
        2: 7649:		if ( firstfree >= current_max_xpairs )
    #####: 7650:			expand_nxt_chk();
        -: 7651:		}
        2: 7652:	}
        -: 7653:
        -: 7654:
        -: 7655:/* mkprot - create new proto entry */
        -: 7656:
        1: 7657:void mkprot( state, statenum, comstate )
        -: 7658:int state[], statenum, comstate;
        -: 7659:	{
        -: 7660:	int i, slot, tblbase;
        -: 7661:
        1: 7662:	if ( ++numprots >= MSP || numecs * numprots >= PROT_SAVE_SIZE )
        -: 7663:		{
        -: 7664:		/* Gotta make room for the new proto by dropping last entry in
        -: 7665:		 * the queue.
        -: 7666:		 */
    #####: 7667:		slot = lastprot;
    #####: 7668:		lastprot = protprev[lastprot];
    #####: 7669:		protnext[lastprot] = NIL;
        -: 7670:		}
        -: 7671:
        -: 7672:	else
        1: 7673:		slot = numprots;
        -: 7674:
        1: 7675:	protnext[slot] = firstprot;
        -: 7676:
        1: 7677:	if ( firstprot != NIL )
    #####: 7678:		protprev[firstprot] = slot;
        -: 7679:
        1: 7680:	firstprot = slot;
        1: 7681:	prottbl[slot] = statenum;
        1: 7682:	protcomst[slot] = comstate;
        -: 7683:
        -: 7684:	/* Copy state into save area so it can be compared with rapidly. */
        1: 7685:	tblbase = numecs * (slot - 1);
        -: 7686:
        2: 7687:	for ( i = 1; i <= numecs; ++i )
        1: 7688:		protsave[tblbase + i] = state[i];
        1: 7689:	}
        -: 7690:
        -: 7691:
        -: 7692:/* mktemplate - create a template entry based on a state, and connect the state
        -: 7693: *              to it
        -: 7694: */
        -: 7695:
        1: 7696:void mktemplate( state, statenum, comstate )
        -: 7697:int state[], statenum, comstate;
        -: 7698:	{
        -: 7699:	int i, numdiff, tmpbase, tmp[CSIZE + 1];
        -: 7700:	Char transset[CSIZE + 1];
        -: 7701:	int tsptr;
        -: 7702:
        1: 7703:	++numtemps;
        -: 7704:
        1: 7705:	tsptr = 0;
        -: 7706:
        -: 7707:	/* Calculate where we will temporarily store the transition table
        -: 7708:	 * of the template in the tnxt[] array.  The final transition table
        -: 7709:	 * gets created by cmptmps().
        -: 7710:	 */
        -: 7711:
        1: 7712:	tmpbase = numtemps * numecs;
        -: 7713:
        1: 7714:	if ( tmpbase + numecs >= current_max_template_xpairs )
        -: 7715:		{
    #####: 7716:		current_max_template_xpairs += MAX_TEMPLATE_XPAIRS_INCREMENT;
        -: 7717:
    #####: 7718:		++num_reallocs;
        -: 7719:
    #####: 7720:		tnxt = reallocate_integer_array( tnxt,
        -: 7721:			current_max_template_xpairs );
        -: 7722:		}
        -: 7723:
        2: 7724:	for ( i = 1; i <= numecs; ++i )
        1: 7725:		if ( state[i] == 0 )
    #####: 7726:			tnxt[tmpbase + i] = 0;
        -: 7727:		else
        -: 7728:			{
        1: 7729:			transset[tsptr++] = i;
        1: 7730:			tnxt[tmpbase + i] = comstate;
        -: 7731:			}
        -: 7732:
        1: 7733:	if ( usemecs )
        1: 7734:		mkeccl( transset, tsptr, tecfwd, tecbck, numecs, 0 );
        -: 7735:
        1: 7736:	mkprot( tnxt + tmpbase, -numtemps, comstate );
        -: 7737:
        -: 7738:	/* We rely on the fact that mkprot adds things to the beginning
        -: 7739:	 * of the proto queue.
        -: 7740:	 */
        -: 7741:
        1: 7742:	numdiff = tbldiff( state, firstprot, tmp );
        1: 7743:	mkentry( tmp, numecs, statenum, -numtemps, numdiff );
        1: 7744:	}
        -: 7745:
        -: 7746:
        -: 7747:/* mv2front - move proto queue element to front of queue */
        -: 7748:
        3: 7749:void mv2front( qelm )
        -: 7750:int qelm;
        -: 7751:	{
        3: 7752:	if ( firstprot != qelm )
        -: 7753:		{
    #####: 7754:		if ( qelm == lastprot )
    #####: 7755:			lastprot = protprev[lastprot];
        -: 7756:
    #####: 7757:		protnext[protprev[qelm]] = protnext[qelm];
        -: 7758:
    #####: 7759:		if ( protnext[qelm] != NIL )
    #####: 7760:			protprev[protnext[qelm]] = protprev[qelm];
        -: 7761:
    #####: 7762:		protprev[qelm] = NIL;
    #####: 7763:		protnext[qelm] = firstprot;
    #####: 7764:		protprev[firstprot] = qelm;
    #####: 7765:		firstprot = qelm;
        -: 7766:		}
        3: 7767:	}
        -: 7768:
        -: 7769:
        -: 7770:/* place_state - place a state into full speed transition table
        -: 7771: *
        -: 7772: * State is the statenum'th state.  It is indexed by equivalence class and
        -: 7773: * gives the number of the state to enter for a given equivalence class.
        -: 7774: * Transnum is the number of out-transitions for the state.
        -: 7775: */
        -: 7776:
    #####: 7777:void place_state( state, statenum, transnum )
        -: 7778:int *state, statenum, transnum;
        -: 7779:	{
        -: 7780:	register int i;
        -: 7781:	register int *state_ptr;
    #####: 7782:	int position = find_table_space( state, transnum );
        -: 7783:
        -: 7784:	/* "base" is the table of start positions. */
    #####: 7785:	base[statenum] = position;
        -: 7786:
        -: 7787:	/* Put in action number marker; this non-zero number makes sure that
        -: 7788:	 * find_table_space() knows that this position in chk/nxt is taken
        -: 7789:	 * and should not be used for another accepting number in another
        -: 7790:	 * state.
        -: 7791:	 */
    #####: 7792:	chk[position - 1] = 1;
        -: 7793:
        -: 7794:	/* Put in end-of-buffer marker; this is for the same purposes as
        -: 7795:	 * above.
        -: 7796:	 */
    #####: 7797:	chk[position] = 1;
        -: 7798:
        -: 7799:	/* Place the state into chk and nxt. */
    #####: 7800:	state_ptr = &state[1];
        -: 7801:
    #####: 7802:	for ( i = 1; i <= numecs; ++i, ++state_ptr )
    #####: 7803:		if ( *state_ptr != 0 )
        -: 7804:			{
    #####: 7805:			chk[position + i] = i;
    #####: 7806:			nxt[position + i] = *state_ptr;
        -: 7807:			}
        -: 7808:
    #####: 7809:	if ( position + numecs > tblend )
    #####: 7810:		tblend = position + numecs;
    #####: 7811:	}
        -: 7812:
        -: 7813:
        -: 7814:/* stack1 - save states with only one out-transition to be processed later
        -: 7815: *
        -: 7816: * If there's room for another state on the "one-transition" stack, the
        -: 7817: * state is pushed onto it, to be processed later by mk1tbl.  If there's
        -: 7818: * no room, we process the sucker right now.
        -: 7819: */
        -: 7820:
        2: 7821:void stack1( statenum, sym, nextstate, deflink )
        -: 7822:int statenum, sym, nextstate, deflink;
        -: 7823:	{
        2: 7824:	if ( onesp >= ONE_STACK_SIZE - 1 )
    #####: 7825:		mk1tbl( statenum, sym, nextstate, deflink );
        -: 7826:
        -: 7827:	else
        -: 7828:		{
        2: 7829:		++onesp;
        2: 7830:		onestate[onesp] = statenum;
        2: 7831:		onesym[onesp] = sym;
        2: 7832:		onenext[onesp] = nextstate;
        2: 7833:		onedef[onesp] = deflink;
        -: 7834:		}
        2: 7835:	}
        -: 7836:
        -: 7837:
        -: 7838:/* tbldiff - compute differences between two state tables
        -: 7839: *
        -: 7840: * "state" is the state array which is to be extracted from the pr'th
        -: 7841: * proto.  "pr" is both the number of the proto we are extracting from
        -: 7842: * and an index into the save area where we can find the proto's complete
        -: 7843: * state table.  Each entry in "state" which differs from the corresponding
        -: 7844: * entry of "pr" will appear in "ext".
        -: 7845: *
        -: 7846: * Entries which are the same in both "state" and "pr" will be marked
        -: 7847: * as transitions to "SAME_TRANS" in "ext".  The total number of differences
        -: 7848: * between "state" and "pr" is returned as function value.  Note that this
        -: 7849: * number is "numecs" minus the number of "SAME_TRANS" entries in "ext".
        -: 7850: */
        -: 7851:
        4: 7852:int tbldiff( state, pr, ext )
        -: 7853:int state[], pr, ext[];
        -: 7854:	{
        4: 7855:	register int i, *sp = state, *ep = ext, *protp;
        4: 7856:	register int numdiff = 0;
        -: 7857:
        4: 7858:	protp = &protsave[numecs * (pr - 1)];
        -: 7859:
        8: 7860:	for ( i = numecs; i > 0; --i )
        -: 7861:		{
        4: 7862:		if ( *++protp == *++sp )
        4: 7863:			*++ep = SAME_TRANS;
        -: 7864:		else
        -: 7865:			{
    #####: 7866:			*++ep = *sp;
    #####: 7867:			++numdiff;
        -: 7868:			}
        -: 7869:		}
        -: 7870:
        4: 7871:	return numdiff;
        -: 7872:	}
        -: 7873:/* yylex - scanner front-end for flex */
        -: 7874:
        -: 7875:/*-
        -: 7876: * Copyright (c) 1990 The Regents of the University of California.
        -: 7877: * All rights reserved.
        -: 7878: *
        -: 7879: * This code is derived from software contributed to Berkeley by
        -: 7880: * Vern Paxson.
        -: 7881: * 
        -: 7882: * The United States Government has rights in this work pursuant
        -: 7883: * to contract no. DE-AC03-76SF00098 between the United States
        -: 7884: * Department of Energy and the University of California.
        -: 7885: *
        -: 7886: * Redistribution and use in source and binary forms are permitted provided
        -: 7887: * that: (1) source distributions retain this entire copyright notice and
        -: 7888: * comment, and (2) distributions including binaries display the following
        -: 7889: * acknowledgement:  ``This product includes software developed by the
        -: 7890: * University of California, Berkeley and its contributors'' in the
        -: 7891: * documentation or other materials provided with the distribution and in
        -: 7892: * all advertising materials mentioning features or use of this software.
        -: 7893: * Neither the name of the University nor the names of its contributors may
        -: 7894: * be used to endorse or promote products derived from this software without
        -: 7895: * specific prior written permission.
        -: 7896: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 7897: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 7898: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 7899: */
        -: 7900:
        -: 7901:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 7902:
        -: 7903:
        -: 7904:
        -: 7905:/* yylex - scan for a regular expression token */
        -: 7906:
       18: 7907:int yylex()
        -: 7908:	{
        -: 7909:	int toktype;
        -: 7910:	static int beglin = false;
        -: 7911:
       18: 7912:	if ( eofseen )
    #####: 7913:		toktype = EOF;
        -: 7914:	else
       18: 7915:		toktype = flexscan();
        -: 7916:
       18: 7917:	if ( toktype == EOF || toktype == 0 )
        -: 7918:		{
        1: 7919:		eofseen = 1;
        -: 7920:
        1: 7921:		if ( sectnum == 1 )
        -: 7922:			{
    #####: 7923:			synerr( "premature EOF" );
    #####: 7924:			sectnum = 2;
    #####: 7925:			toktype = SECTEND;
        -: 7926:			}
        -: 7927:
        -: 7928:		else
        1: 7929:			toktype = 0;
        -: 7930:		}
        -: 7931:
       18: 7932:	if ( trace )
        -: 7933:		{
    #####: 7934:		if ( beglin )
        -: 7935:			{
    #####: 7936:			fprintf( err, "%d\t", num_rules + 1 );
    #####: 7937:			beglin = 0;
        -: 7938:			}
        -: 7939:
    #####: 7940:		switch ( toktype )
        -: 7941:			{
        -: 7942:			case '<':
        -: 7943:			case '>':
        -: 7944:			case '^':
        -: 7945:			case '$':
        -: 7946:			case '"':
        -: 7947:			case '[':
        -: 7948:			case ']':
        -: 7949:			case '{':
        -: 7950:			case '}':
        -: 7951:			case '|':
        -: 7952:			case '(':
        -: 7953:			case ')':
        -: 7954:			case '-':
        -: 7955:			case '/':
        -: 7956:			case '\\':
        -: 7957:			case '?':
        -: 7958:			case '.':
        -: 7959:			case '*':
        -: 7960:			case '+':
        -: 7961:			case ',':
    #####: 7962:				(void) putc( toktype, err );
    #####: 7963:				break;
        -: 7964:
        -: 7965:			case '\n':
    #####: 7966:				(void) putc( '\n', err );
        -: 7967:
    #####: 7968:				if ( sectnum == 2 )
    #####: 7969:				beglin = 1;
        -: 7970:
    #####: 7971:				break;
        -: 7972:
        -: 7973:			case SCDECL:
    #####: 7974:				fputs( "%s", err );
    #####: 7975:				break;
        -: 7976:
        -: 7977:			case XSCDECL:
    #####: 7978:				fputs( "%x", err );
    #####: 7979:				break;
        -: 7980:
        -: 7981:			case WHITESPACE:
    #####: 7982:				(void) putc( ' ', err );
    #####: 7983:				break;
        -: 7984:
        -: 7985:			case SECTEND:
    #####: 7986:				fputs( "%%\n", err );
        -: 7987:
        -: 7988:				/* We set beglin to be true so we'll start
        -: 7989:				 * writing out numbers as we echo rules.
        -: 7990:				 * flexscan() has already assigned sectnum.
        -: 7991:				 */
        -: 7992:
    #####: 7993:				if ( sectnum == 2 )
    #####: 7994:				beglin = 1;
        -: 7995:
    #####: 7996:				break;
        -: 7997:
        -: 7998:			case NAME:
    #####: 7999:				fprintf( err, "'%s'", nmstr );
    #####: 8000:				break;
        -: 8001:
        -: 8002:			case CHAR:
    #####: 8003:				switch ( yylval )
        -: 8004:					{
        -: 8005:					case '<':
        -: 8006:					case '>':
        -: 8007:					case '^':
        -: 8008:					case '$':
        -: 8009:					case '"':
        -: 8010:					case '[':
        -: 8011:					case ']':
        -: 8012:					case '{':
        -: 8013:					case '}':
        -: 8014:					case '|':
        -: 8015:					case '(':
        -: 8016:					case ')':
        -: 8017:					case '-':
        -: 8018:					case '/':
        -: 8019:					case '\\':
        -: 8020:					case '?':
        -: 8021:					case '.':
        -: 8022:					case '*':
        -: 8023:					case '+':
        -: 8024:					case ',':
    #####: 8025:						fprintf( err, "\\%c",
        -: 8026:							yylval );
    #####: 8027:						break;
        -: 8028:
        -: 8029:					default:
    #####: 8030:						if ( ! isascii( yylval ) ||
    #####: 8031:						     ! isprint( yylval ) )
    #####: 8032:							fprintf( err,
        -: 8033:								"\\%.3o",
        -: 8034:							(unsigned int) yylval );
        -: 8035:						else
    #####: 8036:							(void) putc( yylval,
        -: 8037:								err );
    #####: 8038:					break;
        -: 8039:					}
        -: 8040:
    #####: 8041:				break;
        -: 8042:
        -: 8043:			case NUMBER:
    #####: 8044:				fprintf( err, "%d", yylval );
    #####: 8045:				break;
        -: 8046:
        -: 8047:			case PREVCCL:
    #####: 8048:				fprintf( err, "[%d]", yylval );
    #####: 8049:				break;
        -: 8050:
        -: 8051:			case EOF_OP:
    #####: 8052:				fprintf( err, "<<EOF>>" );
    #####: 8053:				break;
        -: 8054:
        -: 8055:			case 0:
    #####: 8056:				fprintf( err, "End Marker" );
    #####: 8057:				break;
        -: 8058:
        -: 8059:			default:
    #####: 8060:				fprintf( err,
        -: 8061:					"*Something Weird* - tok: %d val: %d\n",
        -: 8062:					toktype, yylval );
    #####: 8063:				break;
        -: 8064:			}
        -: 8065:		}
        -: 8066:
       18: 8067:	return toktype;
        -: 8068:	}
        -: 8069:
        -: 8070:/*  A Bison parser, made from ./parse.y
        -: 8071:    by GNU Bison version 1.28  */
        -: 8072:
        -: 8073:#define YYBISON 1  /* Identify Bison output.  */
        -: 8074:
        -: 8075:#define	CHAR	257
        -: 8076:#define	NUMBER	258
        -: 8077:#define	SECTEND	259
        -: 8078:#define	SCDECL	260
        -: 8079:#define	XSCDECL	261
        -: 8080:#define	WHITESPACE	262
        -: 8081:#define	NAME	263
        -: 8082:#define	PREVCCL	264
        -: 8083:#define	EOF_OP	265
        -: 8084:
        -: 8085:
        -: 8086:/*-
        -: 8087: * Copyright (c) 1990 The Regents of the University of California.
        -: 8088: * All rights reserved.
        -: 8089: *
        -: 8090: * This code is derived from software contributed to Berkeley by
        -: 8091: * Vern Paxson.
        -: 8092: * 
        -: 8093: * The United States Government has rights in this work pursuant
        -: 8094: * to contract no. DE-AC03-76SF00098 between the United States
        -: 8095: * Department of Energy and the University of California.
        -: 8096: *
        -: 8097: * Redistribution and use in source and binary forms are permitted provided
        -: 8098: * that: (1) source distributions retain this entire copyright notice and
        -: 8099: * comment, and (2) distributions including binaries display the following
        -: 8100: * acknowledgement:  ``This product includes software developed by the
        -: 8101: * University of California, Berkeley and its contributors'' in the
        -: 8102: * documentation or other materials provided with the distribution and in
        -: 8103: * all advertising materials mentioning features or use of this software.
        -: 8104: * Neither the name of the University nor the names of its contributors may
        -: 8105: * be used to endorse or promote products derived from this software without
        -: 8106: * specific prior written permission.
        -: 8107: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -: 8108: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -: 8109: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -: 8110: */
        -: 8111:
        -: 8112:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -: 8113:
        -: 8114:
        -: 8115:/* Some versions of bison are broken in that they use alloca() but don't
        -: 8116: * declare it properly.  The following is the patented (just kidding!)
        -: 8117: * #ifdef chud to fix the problem, courtesy of Francois Pinard.
        -: 8118: */
        -: 8119:#ifdef YYBISON
        -: 8120:/* AIX requires this to be the first thing in the file.  */
        -: 8121:#if (defined(__GNUC__) && (!defined(LINUX)))
        -: 8122:#define alloca __builtin_alloca
        -: 8123:#else /* not __GNUC__ */
        -: 8124:#if HAVE_ALLOCA_H
        -: 8125:#include <alloca.h>
        -: 8126:#else /* not HAVE_ALLOCA_H */
        -: 8127:#ifdef _AIX
        -: 8128: #pragma alloca
        -: 8129:#else /* not _AIX */
        -: 8130:char *alloca ();
        -: 8131:#endif /* not _AIX */
        -: 8132:#endif /* not HAVE_ALLOCA_H */
        -: 8133:#endif /* not __GNUC__ */
        -: 8134:#endif /* YYBISON */
        -: 8135:
        -: 8136:/* Bletch, ^^^^ that was ugly! */
        -: 8137:
        -: 8138:
        -: 8139:
        -: 8140:int pat, scnum, eps, headcnt, trailcnt, anyccl, lastchar, i, actvp, rulelen;
        -: 8141:int trlcontxt, xcluflg, cclsorted, varlength, variable_trail_rule;
        -: 8142:int *active_ss;
        -: 8143:Char clower();
        -: 8144:void build_eof_action();
        -: 8145:void yyerror();
        -: 8146:
        -: 8147:static int madeany = false;  /* whether we've made the '.' character class */
        -: 8148:int previous_continued_action;	/* whether the previous rule's action was '|' */
        -: 8149:
        -: 8150:/* On some over-ambitious machines, such as DEC Alpha's, the default
        -: 8151: * token type is "long" instead of "int"; this leads to problems with
        -: 8152: * declaring yylval in flexdef.h.  But so far, all the yacc's I've seen
        -: 8153: * wrap their definitions of YYSTYPE with "#ifndef YYSTYPE"'s, so the
        -: 8154: * following should ensure that the default token type is "int".
        -: 8155: */
        -: 8156:#define YYSTYPE int
        -: 8157:
        -: 8158:#ifndef YYSTYPE
        -: 8159:#define YYSTYPE int
        -: 8160:#endif
        -: 8161:#include <stdio.h>
        -: 8162:
        -: 8163:#ifndef __cplusplus
        -: 8164:#ifndef __STDC__
        -: 8165:#define const
        -: 8166:#endif
        -: 8167:#endif
        -: 8168:
        -: 8169:
        -: 8170:
        -: 8171:#define	YYFINAL		85
        -: 8172:#define	YYFLAG		-32768
        -: 8173:#define	YYNTBASE	32
        -: 8174:
        -: 8175:#define YYTRANSLATE(x) ((unsigned)(x) <= 265 ? yytranslate[x] : 53)
        -: 8176:
        -: 8177:static const char yytranslate[] = {     0,
        -: 8178:     2,     2,     2,     2,     2,     2,     2,     2,     2,    12,
        -: 8179:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8180:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8181:     2,     2,     2,    26,     2,    18,     2,     2,     2,    27,
        -: 8182:    28,    16,    21,    17,    31,    25,    20,     2,     2,     2,
        -: 8183:     2,     2,     2,     2,     2,     2,     2,     2,     2,    14,
        -: 8184:     2,    15,    22,     2,     2,     2,     2,     2,     2,     2,
        -: 8185:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8186:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8187:    29,     2,    30,    13,     2,     2,     2,     2,     2,     2,
        -: 8188:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8189:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8190:     2,     2,    23,    19,    24,     2,     2,     2,     2,     2,
        -: 8191:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8192:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8193:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8194:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8195:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8196:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8197:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8198:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8199:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8200:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8201:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8202:     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -: 8203:     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
        -: 8204:     7,     8,     9,    10,    11
        -: 8205:};
        -: 8206:
        -: 8207:#if YYDEBUG != 0
        -: 8208:static const short yyprhs[] = {     0,
        -: 8209:     0,     6,     7,    13,    14,    17,    19,    21,    23,    27,
        -: 8210:    29,    31,    36,    37,    38,    42,    45,    48,    50,    53,
        -: 8211:    55,    57,    61,    65,    69,    70,    73,    75,    77,    80,
        -: 8212:    84,    87,    89,    93,    95,    98,   101,   103,   106,   109,
        -: 8213:   112,   119,   125,   130,   132,   134,   136,   140,   144,   146,
        -: 8214:   150,   155,   160,   163,   164,   167
        -: 8215:};
        -: 8216:
        -: 8217:static const short yyrhs[] = {    33,
        -: 8218:    34,    35,    38,    39,     0,     0,    34,    36,     8,    37,
        -: 8219:    12,     0,     0,     1,    12,     0,     5,     0,     6,     0,
        -: 8220:     7,     0,    37,     8,     9,     0,     9,     0,     1,     0,
        -: 8221:    38,    39,    40,    12,     0,     0,     0,    41,    13,    45,
        -: 8222:     0,    41,    45,     0,    13,    45,     0,    45,     0,    41,
        -: 8223:    11,     0,    11,     0,     1,     0,    14,    42,    15,     0,
        -: 8224:    14,    16,    15,     0,    42,    17,    44,     0,     0,    43,
        -: 8225:    44,     0,     1,     0,     9,     0,    47,    46,     0,    47,
        -: 8226:    46,    18,     0,    46,    18,     0,    46,     0,    46,    19,
        -: 8227:    48,     0,    48,     0,    46,    20,     0,    48,    49,     0,
        -: 8228:    49,     0,    49,    16,     0,    49,    21,     0,    49,    22,
        -: 8229:     0,    49,    23,     4,    17,     4,    24,     0,    49,    23,
        -: 8230:     4,    17,    24,     0,    49,    23,     4,    24,     0,    25,
        -: 8231:     0,    50,     0,    10,     0,    26,    52,    26,     0,    27,
        -: 8232:    46,    28,     0,     3,     0,    29,    51,    30,     0,    29,
        -: 8233:    13,    51,    30,     0,    51,     3,    31,     3,     0,    51,
        -: 8234:     3,     0,     0,    52,     3,     0,     0
        -: 8235:};
        -: 8236:
        -: 8237:#endif
        -: 8238:
        -: 8239:#if YYDEBUG != 0
        -: 8240:static const short yyrline[] = { 0,
        -: 8241:    82,   111,   124,   125,   126,   130,   143,   146,   150,   153,
        -: 8242:   156,   160,   161,   164,   175,   195,   206,   230,   241,   244,
        -: 8243:   263,   267,   269,   278,   280,   282,   282,   286,   307,   362,
        -: 8244:   365,   408,   426,   432,   437,   464,   472,   476,   483,   489,
        -: 8245:   495,   523,   537,   556,   578,   596,   603,   606,   609,   620,
        -: 8246:   623,   630,   658,   669,   677,   687
        -: 8247:};
        -: 8248:#endif
        -: 8249:
        -: 8250:
        -: 8251:#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
        -: 8252:
        -: 8253:static const char * const yytname[] = {   "$","error","$undefined.","CHAR","NUMBER",
        -: 8254:"SECTEND","SCDECL","XSCDECL","WHITESPACE","NAME","PREVCCL","EOF_OP","'\\n'",
        -: 8255:"'^'","'<'","'>'","'*'","','","'$'","'|'","'/'","'+'","'?'","'{'","'}'","'.'",
        -: 8256:"'\\\"'","'('","')'","'['","']'","'-'","goal","initlex","sect1","sect1end","startconddecl",
        -: 8257:"namelist1","sect2","initforrule","flexrule","scon","namelist2","@1","sconname",
        -: 8258:"rule","re","re2","series","singleton","fullccl","ccl","string", NULL
        -: 8259:};
        -: 8260:#endif
        -: 8261:
        -: 8262:static const short yyr1[] = {     0,
        -: 8263:    32,    33,    34,    34,    34,    35,    36,    36,    37,    37,
        -: 8264:    37,    38,    38,    39,    40,    40,    40,    40,    40,    40,
        -: 8265:    40,    41,    41,    42,    43,    42,    42,    44,    45,    45,
        -: 8266:    45,    45,    46,    46,    47,    48,    48,    49,    49,    49,
        -: 8267:    49,    49,    49,    49,    49,    49,    49,    49,    49,    50,
        -: 8268:    50,    51,    51,    51,    52,    52
        -: 8269:};
        -: 8270:
        -: 8271:static const short yyr2[] = {     0,
        -: 8272:     5,     0,     5,     0,     2,     1,     1,     1,     3,     1,
        -: 8273:     1,     4,     0,     0,     3,     2,     2,     1,     2,     1,
        -: 8274:     1,     3,     3,     3,     0,     2,     1,     1,     2,     3,
        -: 8275:     2,     1,     3,     1,     2,     2,     1,     2,     2,     2,
        -: 8276:     6,     5,     4,     1,     1,     1,     3,     3,     1,     3,
        -: 8277:     4,     4,     2,     0,     2,     0
        -: 8278:};
        -: 8279:
        -: 8280:static const short yydefact[] = {     2,
        -: 8281:     0,     0,     0,     5,     6,     7,     8,    13,     0,    14,
        -: 8282:     0,     0,    11,    10,     0,    21,    49,    46,    20,     0,
        -: 8283:     0,    44,    56,     0,    54,     0,     0,    18,    32,     0,
        -: 8284:    34,    37,    45,     0,     3,    17,    27,     0,     0,     0,
        -: 8285:     0,     0,    54,     0,    12,    19,     0,    16,    31,     0,
        -: 8286:    35,    29,    36,    38,    39,    40,     0,     9,    23,    22,
        -: 8287:     0,    28,    26,    55,    47,    48,     0,    53,    50,    15,
        -: 8288:    33,    30,     0,    24,    51,     0,     0,    43,    52,     0,
        -: 8289:    42,    41,     0,     0,     0
        -: 8290:};
        -: 8291:
        -: 8292:static const short yydefgoto[] = {    83,
        -: 8293:     1,     3,     8,     9,    15,    10,    12,    26,    27,    39,
        -: 8294:    40,    63,    28,    29,    30,    31,    32,    33,    44,    41
        -: 8295:};
        -: 8296:
        -: 8297:static const short yypact[] = {-32768,
        -: 8298:    61,    -2,    64,-32768,-32768,-32768,-32768,-32768,    13,-32768,
        -: 8299:    34,     1,-32768,-32768,    30,-32768,-32768,-32768,-32768,    21,
        -: 8300:    48,-32768,-32768,    21,    31,    33,    26,-32768,    54,    21,
        -: 8301:    21,    38,-32768,    47,-32768,-32768,-32768,    43,     5,    56,
        -: 8302:    15,   -11,-32768,     2,-32768,-32768,    21,-32768,-32768,    21,
        -: 8303:-32768,    57,    38,-32768,-32768,-32768,    59,-32768,-32768,-32768,
        -: 8304:    56,-32768,-32768,-32768,-32768,-32768,     4,    46,-32768,-32768,
        -: 8305:    21,-32768,    -8,-32768,-32768,    75,    -1,-32768,-32768,    55,
        -: 8306:-32768,-32768,    80,    81,-32768
        -: 8307:};
        -: 8308:
        -: 8309:static const short yypgoto[] = {-32768,
        -: 8310:-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
        -: 8311:-32768,    22,   -14,    -5,-32768,    32,   -31,-32768,    41,-32768
        -: 8312:};
        -: 8313:
        -: 8314:
        -: 8315:#define	YYLAST		84
        -: 8316:
        -: 8317:
        -: 8318:static const short yytable[] = {    53,
        -: 8319:    -1,    16,    80,    17,    68,    36,    68,    50,    77,     4,
        -: 8320:    18,    19,    48,    20,    21,    78,    66,    64,    42,    60,
        -: 8321:    11,    61,    81,    17,    52,    22,    23,    24,    17,    25,
        -: 8322:    18,    69,    70,    75,    13,    18,    46,    34,    47,    53,
        -: 8323:    65,    35,    14,    43,    45,    22,    23,    24,    37,    25,
        -: 8324:    22,    23,    24,    54,    25,    58,   -25,    59,    55,    56,
        -: 8325:    57,     2,    73,    38,    62,    -4,    -4,    -4,     5,     6,
        -: 8326:     7,    49,    50,    51,    72,    50,    76,    79,    82,    84,
        -: 8327:    85,    71,    74,    67
        -: 8328:};
        -: 8329:
        -: 8330:static const short yycheck[] = {    31,
        -: 8331:     0,     1,     4,     3,     3,    20,     3,    19,    17,    12,
        -: 8332:    10,    11,    27,    13,    14,    24,    28,     3,    24,    15,
        -: 8333:     8,    17,    24,     3,    30,    25,    26,    27,     3,    29,
        -: 8334:    10,    30,    47,    30,     1,    10,    11,     8,    13,    71,
        -: 8335:    26,    12,     9,    13,    12,    25,    26,    27,     1,    29,
        -: 8336:    25,    26,    27,    16,    29,     9,     9,    15,    21,    22,
        -: 8337:    23,     1,     4,    16,     9,     5,     6,     7,     5,     6,
        -: 8338:     7,    18,    19,    20,    18,    19,    31,     3,    24,     0,
        -: 8339:     0,    50,    61,    43
        -: 8340:};
        -: 8341:/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
        -: 8342:/* This file comes from bison-1.28.  */
        -: 8343:
        -: 8344:/* Skeleton output parser for bison,
        -: 8345:   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
        -: 8346:
        -: 8347:   This program is free software; you can redistribute it and/or modify
        -: 8348:   it under the terms of the GNU General Public License as published by
        -: 8349:   the Free Software Foundation; either version 2, or (at your option)
        -: 8350:   any later version.
        -: 8351:
        -: 8352:   This program is distributed in the hope that it will be useful,
        -: 8353:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 8354:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 8355:   GNU General Public License for more details.
        -: 8356:
        -: 8357:   You should have received a copy of the GNU General Public License
        -: 8358:   along with this program; if not, write to the Free Software
        -: 8359:   Foundation, Inc., 59 Temple Place - Suite 330,
        -: 8360:   Boston, MA 02111-1307, USA.  */
        -: 8361:
        -: 8362:/* As a special exception, when this file is copied by Bison into a
        -: 8363:   Bison output file, you may use that output file without restriction.
        -: 8364:   This special exception was added by the Free Software Foundation
        -: 8365:   in version 1.24 of Bison.  */
        -: 8366:
        -: 8367:/* This is the parser code that is written into each bison parser
        -: 8368:  when the %semantic_parser declaration is not specified in the grammar.
        -: 8369:  It was written by Richard Stallman by simplifying the hairy parser
        -: 8370:  used when %semantic_parser is specified.  */
        -: 8371:
        -: 8372:#ifndef YYSTACK_USE_ALLOCA
        -: 8373:#ifdef alloca
        -: 8374:#define YYSTACK_USE_ALLOCA
        -: 8375:#else /* alloca not defined */
        -: 8376:#ifdef __GNUC__
        -: 8377:#define YYSTACK_USE_ALLOCA
        -: 8378:#define alloca __builtin_alloca
        -: 8379:#else /* not GNU C.  */
        -: 8380:#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
        -: 8381:#define YYSTACK_USE_ALLOCA
        -: 8382:#include <alloca.h>
        -: 8383:#else /* not sparc */
        -: 8384:/* We think this test detects Watcom and Microsoft C.  */
        -: 8385:/* This used to test MSDOS, but that is a bad idea
        -: 8386:   since that symbol is in the user namespace.  */
        -: 8387:#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
        -: 8388:#if 0 /* No need for malloc.h, which pollutes the namespace;
        -: 8389:	 instead, just don't use alloca.  */
        -: 8390:#include <malloc.h>
        -: 8391:#endif
        -: 8392:#else /* not MSDOS, or __TURBOC__ */
        -: 8393:#if defined(_AIX)
        -: 8394:/* I don't know what this was needed for, but it pollutes the namespace.
        -: 8395:   So I turned it off.   rms, 2 May 1997.  */
        -: 8396:/* #include <malloc.h>  */
        -: 8397: #pragma alloca
        -: 8398:#define YYSTACK_USE_ALLOCA
        -: 8399:#else /* not MSDOS, or __TURBOC__, or _AIX */
        -: 8400:#if 0
        -: 8401:#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
        -: 8402:		 and on HPUX 10.  Eventually we can turn this on.  */
        -: 8403:#define YYSTACK_USE_ALLOCA
        -: 8404:#define alloca __builtin_alloca
        -: 8405:#endif /* __hpux */
        -: 8406:#endif
        -: 8407:#endif /* not _AIX */
        -: 8408:#endif /* not MSDOS, or __TURBOC__ */
        -: 8409:#endif /* not sparc */
        -: 8410:#endif /* not GNU C */
        -: 8411:#endif /* alloca not defined */
        -: 8412:#endif /* YYSTACK_USE_ALLOCA not defined */
        -: 8413:
        -: 8414:#ifdef YYSTACK_USE_ALLOCA
        -: 8415:#define YYSTACK_ALLOC alloca
        -: 8416:#else
        -: 8417:#define YYSTACK_ALLOC malloc
        -: 8418:#endif
        -: 8419:
        -: 8420:/* Note: there must be only one dollar sign in this file.
        -: 8421:   It is replaced by the list of actions, each action
        -: 8422:   as one case of the switch.  */
        -: 8423:
        -: 8424:#define yyerrok		(yyerrstatus = 0)
        -: 8425:#define yyclearin	(yychar = YYEMPTY)
        -: 8426:#define YYEMPTY		-2
        -: 8427:#define YYEOF		0
        -: 8428:#define YYACCEPT	goto yyacceptlab
        -: 8429:#define YYABORT 	goto yyabortlab
        -: 8430:#define YYERROR		goto yyerrlab1
        -: 8431:/* Like YYERROR except do call yyerror.
        -: 8432:   This remains here temporarily to ease the
        -: 8433:   transition to the new meaning of YYERROR, for GCC.
        -: 8434:   Once GCC version 2 has supplanted version 1, this can go.  */
        -: 8435:#define YYFAIL		goto yyerrlab
        -: 8436:#define YYRECOVERING()  (!!yyerrstatus)
        -: 8437:#define YYBACKUP(token, value) \
        -: 8438:do								\
        -: 8439:  if (yychar == YYEMPTY && yylen == 1)				\
        -: 8440:    { yychar = (token), yylval = (value);			\
        -: 8441:      yychar1 = YYTRANSLATE (yychar);				\
        -: 8442:      YYPOPSTACK;						\
        -: 8443:      goto yybackup;						\
        -: 8444:    }								\
        -: 8445:  else								\
        -: 8446:    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
        -: 8447:while (0)
        -: 8448:
        -: 8449:#define YYTERROR	1
        -: 8450:#define YYERRCODE	256
        -: 8451:
        -: 8452:#ifndef YYPURE
        -: 8453:#define YYLEX		yylex()
        -: 8454:#endif
        -: 8455:
        -: 8456:#ifdef YYPURE
        -: 8457:#ifdef YYLSP_NEEDED
        -: 8458:#ifdef YYLEX_PARAM
        -: 8459:#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
        -: 8460:#else
        -: 8461:#define YYLEX		yylex(&yylval, &yylloc)
        -: 8462:#endif
        -: 8463:#else /* not YYLSP_NEEDED */
        -: 8464:#ifdef YYLEX_PARAM
        -: 8465:#define YYLEX		yylex(&yylval, YYLEX_PARAM)
        -: 8466:#else
        -: 8467:#define YYLEX		yylex(&yylval)
        -: 8468:#endif
        -: 8469:#endif /* not YYLSP_NEEDED */
        -: 8470:#endif
        -: 8471:
        -: 8472:/* If nonreentrant, generate the variables here */
        -: 8473:
        -: 8474:#ifndef YYPURE
        -: 8475:
        -: 8476:int	yychar;			/*  the lookahead symbol		*/
        -: 8477:YYSTYPE	yylval;			/*  the semantic value of the		*/
        -: 8478:				/*  lookahead symbol			*/
        -: 8479:
        -: 8480:#ifdef YYLSP_NEEDED
        -: 8481:YYLTYPE yylloc;			/*  location data for the lookahead	*/
        -: 8482:				/*  symbol				*/
        -: 8483:#endif
        -: 8484:
        -: 8485:int yynerrs;			/*  number of parse errors so far       */
        -: 8486:#endif  /* not YYPURE */
        -: 8487:
        -: 8488:#if YYDEBUG != 0
        -: 8489:int yydebug;			/*  nonzero means print parse trace	*/
        -: 8490:/* Since this is uninitialized, it does not stop multiple parsers
        -: 8491:   from coexisting.  */
        -: 8492:#endif
        -: 8493:
        -: 8494:/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
        -: 8495:
        -: 8496:#ifndef	YYINITDEPTH
        -: 8497:#define YYINITDEPTH 200
        -: 8498:#endif
        -: 8499:
        -: 8500:/*  YYMAXDEPTH is the maximum size the stacks can grow to
        -: 8501:    (effective only if the built-in stack extension method is used).  */
        -: 8502:
        -: 8503:#if YYMAXDEPTH == 0
        -: 8504:#undef YYMAXDEPTH
        -: 8505:#endif
        -: 8506:
        -: 8507:#ifndef YYMAXDEPTH
        -: 8508:#define YYMAXDEPTH 10000
        -: 8509:#endif
        -: 8510:/* Define __yy_memcpy.  Note that the size argument
        -: 8511:   should be passed with type unsigned int, because that is what the non-GCC
        -: 8512:   definitions require.  With GCC, __builtin_memcpy takes an arg
        -: 8513:   of type size_t, but it can handle unsigned int.  */
        -: 8514:
        -: 8515:#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
        -: 8516:#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
        -: 8517:#else				/* not GNU C or C++ */
        -: 8518:#ifndef __cplusplus
        -: 8519:
        -: 8520:/* This is the most reliable way to avoid incompatibilities
        -: 8521:   in available built-in functions on various systems.  */
        -: 8522:static void
        -: 8523:__yy_memcpy (to, from, count)
        -: 8524:     char *to;
        -: 8525:     char *from;
        -: 8526:     unsigned int count;
        -: 8527:{
        -: 8528:  register char *f = from;
        -: 8529:  register char *t = to;
        -: 8530:  register int i = count;
        -: 8531:
        -: 8532:  while (i-- > 0)
        -: 8533:    *t++ = *f++;
        -: 8534:}
        -: 8535:
        -: 8536:#else /* __cplusplus */
        -: 8537:
        -: 8538:/* This is the most reliable way to avoid incompatibilities
        -: 8539:   in available built-in functions on various systems.  */
        -: 8540:static void
        -: 8541:__yy_memcpy (char *to, char *from, unsigned int count)
        -: 8542:{
        -: 8543:  register char *t = to;
        -: 8544:  register char *f = from;
        -: 8545:  register int i = count;
        -: 8546:
        -: 8547:  while (i-- > 0)
        -: 8548:    *t++ = *f++;
        -: 8549:}
        -: 8550:
        -: 8551:#endif
        -: 8552:#endif
        -: 8553:
        -: 8554:/* The user can define YYPARSE_PARAM as the name of an argument to be passed
        -: 8555:   into yyparse.  The argument should have type void *.
        -: 8556:   It should actually point to an object.
        -: 8557:   Grammar actions can access the variable by casting it
        -: 8558:   to the proper pointer type.  */
        -: 8559:
        -: 8560:#ifdef YYPARSE_PARAM
        -: 8561:#ifdef __cplusplus
        -: 8562:#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
        -: 8563:#define YYPARSE_PARAM_DECL
        -: 8564:#else /* not __cplusplus */
        -: 8565:#define YYPARSE_PARAM_ARG YYPARSE_PARAM
        -: 8566:#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
        -: 8567:#endif /* not __cplusplus */
        -: 8568:#else /* not YYPARSE_PARAM */
        -: 8569:#define YYPARSE_PARAM_ARG
        -: 8570:#define YYPARSE_PARAM_DECL
        -: 8571:#endif /* not YYPARSE_PARAM */
        -: 8572:
        -: 8573:/* Prevent warning if -Wstrict-prototypes.  */
        -: 8574:#ifdef __GNUC__
        -: 8575:#ifdef YYPARSE_PARAM
        -: 8576:int yyparse (void *);
        -: 8577:#else
        -: 8578:int yyparse (void);
        -: 8579:#endif
        -: 8580:#endif
        -: 8581:
        -: 8582:int
        1: 8583:yyparse(YYPARSE_PARAM_ARG)
        -: 8584:     YYPARSE_PARAM_DECL
        -: 8585:{
        -: 8586:  register int yystate;
        -: 8587:  register int yyn;
        -: 8588:  register short *yyssp;
        -: 8589:  register YYSTYPE *yyvsp;
        -: 8590:  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
        1: 8591:  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
        -: 8592:
        -: 8593:  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
        -: 8594:  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
        -: 8595:
        1: 8596:  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
        1: 8597:  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
        -: 8598:
        -: 8599:#ifdef YYLSP_NEEDED
        -: 8600:  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
        -: 8601:  YYLTYPE *yyls = yylsa;
        -: 8602:  YYLTYPE *yylsp;
        -: 8603:
        -: 8604:#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
        -: 8605:#else
        -: 8606:#define YYPOPSTACK   (yyvsp--, yyssp--)
        -: 8607:#endif
        -: 8608:
        1: 8609:  int yystacksize = YYINITDEPTH;
        1: 8610:  int yyfree_stacks = 0;
        -: 8611:
        -: 8612:#ifdef YYPURE
        -: 8613:  int yychar;
        -: 8614:  YYSTYPE yylval;
        -: 8615:  int yynerrs;
        -: 8616:#ifdef YYLSP_NEEDED
        -: 8617:  YYLTYPE yylloc;
        -: 8618:#endif
        -: 8619:#endif
        -: 8620:
        -: 8621:  YYSTYPE yyval;		/*  the variable used to return		*/
        -: 8622:				/*  semantic values from the action	*/
        -: 8623:				/*  routines				*/
        -: 8624:
        -: 8625:  int yylen;
        -: 8626:
        -: 8627:#if YYDEBUG != 0
        -: 8628:  if (yydebug)
        -: 8629:    fprintf(err, "Starting parse\n");
        -: 8630:#endif
        -: 8631:
        1: 8632:  yystate = 0;
        1: 8633:  yyerrstatus = 0;
        1: 8634:  yynerrs = 0;
        1: 8635:  yychar = YYEMPTY;		/* Cause a token to be read.  */
        -: 8636:
        -: 8637:  /* Initialize stack pointers.
        -: 8638:     Waste one element of value and location stack
        -: 8639:     so that they stay on the same level as the state stack.
        -: 8640:     The wasted elements are never initialized.  */
        -: 8641:
        1: 8642:  yyssp = yyss - 1;
        1: 8643:  yyvsp = yyvs;
        -: 8644:#ifdef YYLSP_NEEDED
        -: 8645:  yylsp = yyls;
        -: 8646:#endif
        -: 8647:
        -: 8648:/* Push a new state, which is found in  yystate  .  */
        -: 8649:/* In all cases, when you get here, the value and location stacks
        -: 8650:   have just been pushed. so pushing a state here evens the stacks.  */
        -: 8651:yynewstate:
        -: 8652:
       45: 8653:  *++yyssp = yystate;
        -: 8654:
       45: 8655:  if (yyssp >= yyss + yystacksize - 1)
        -: 8656:    {
        -: 8657:      /* Give user a chance to reallocate the stack */
        -: 8658:      /* Use copies of these so that the &'s don't force the real ones into memory. */
    #####: 8659:      YYSTYPE *yyvs1 = yyvs;
    #####: 8660:      short *yyss1 = yyss;
        -: 8661:#ifdef YYLSP_NEEDED
        -: 8662:      YYLTYPE *yyls1 = yyls;
        -: 8663:#endif
        -: 8664:
        -: 8665:      /* Get the current used size of the three stacks, in elements.  */
    #####: 8666:      int size = yyssp - yyss + 1;
        -: 8667:
        -: 8668:#ifdef yyoverflow
        -: 8669:      /* Each stack pointer address is followed by the size of
        -: 8670:	 the data in use in that stack, in bytes.  */
        -: 8671:#ifdef YYLSP_NEEDED
        -: 8672:      /* This used to be a conditional around just the two extra args,
        -: 8673:	 but that might be undefined if yyoverflow is a macro.  */
        -: 8674:      yyoverflow("parser stack overflow",
        -: 8675:		 &yyss1, size * sizeof (*yyssp),
        -: 8676:		 &yyvs1, size * sizeof (*yyvsp),
        -: 8677:		 &yyls1, size * sizeof (*yylsp),
        -: 8678:		 &yystacksize);
        -: 8679:#else
        -: 8680:      yyoverflow("parser stack overflow",
        -: 8681:		 &yyss1, size * sizeof (*yyssp),
        -: 8682:		 &yyvs1, size * sizeof (*yyvsp),
        -: 8683:		 &yystacksize);
        -: 8684:#endif
        -: 8685:
        -: 8686:      yyss = yyss1; yyvs = yyvs1;
        -: 8687:#ifdef YYLSP_NEEDED
        -: 8688:      yyls = yyls1;
        -: 8689:#endif
        -: 8690:#else /* no yyoverflow */
        -: 8691:      /* Extend the stack our own way.  */
    #####: 8692:      if (yystacksize >= YYMAXDEPTH)
        -: 8693:	{
    #####: 8694:	  yyerror("parser stack overflow");
    #####: 8695:	  if (yyfree_stacks)
        -: 8696:	    {
    #####: 8697:	      free (yyss);
    #####: 8698:	      free (yyvs);
        -: 8699:#ifdef YYLSP_NEEDED
        -: 8700:	      free (yyls);
        -: 8701:#endif
        -: 8702:	    }
    #####: 8703:	  return 2;
        -: 8704:	}
    #####: 8705:      yystacksize *= 2;
    #####: 8706:      if (yystacksize > YYMAXDEPTH)
    #####: 8707:	yystacksize = YYMAXDEPTH;
        -: 8708:#ifndef YYSTACK_USE_ALLOCA
        -: 8709:      yyfree_stacks = 1;
        -: 8710:#endif
    #####: 8711:      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
    #####: 8712:      __yy_memcpy ((char *)yyss, (char *)yyss1,
        -: 8713:		   size * (unsigned int) sizeof (*yyssp));
    #####: 8714:      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
    #####: 8715:      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
        -: 8716:		   size * (unsigned int) sizeof (*yyvsp));
        -: 8717:#ifdef YYLSP_NEEDED
        -: 8718:      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
        -: 8719:      __yy_memcpy ((char *)yyls, (char *)yyls1,
        -: 8720:		   size * (unsigned int) sizeof (*yylsp));
        -: 8721:#endif
        -: 8722:#endif /* no yyoverflow */
        -: 8723:
    #####: 8724:      yyssp = yyss + size - 1;
    #####: 8725:      yyvsp = yyvs + size - 1;
        -: 8726:#ifdef YYLSP_NEEDED
        -: 8727:      yylsp = yyls + size - 1;
        -: 8728:#endif
        -: 8729:
        -: 8730:#if YYDEBUG != 0
        -: 8731:      if (yydebug)
        -: 8732:	fprintf(err, "Stack size increased to %d\n", yystacksize);
        -: 8733:#endif
        -: 8734:
    #####: 8735:      if (yyssp >= yyss + yystacksize - 1)
    #####: 8736:	YYABORT;
        -: 8737:    }
        -: 8738:
        -: 8739:#if YYDEBUG != 0
        -: 8740:  if (yydebug)
        -: 8741:    fprintf(err, "Entering state %d\n", yystate);
        -: 8742:#endif
        -: 8743:
       45: 8744:  goto yybackup;
        -: 8745: yybackup:
        -: 8746:
        -: 8747:/* Do appropriate processing given the current state.  */
        -: 8748:/* Read a lookahead token if we need one and don't already have one.  */
        -: 8749:/* yyresume: */
        -: 8750:
        -: 8751:  /* First try to decide what to do without reference to lookahead token.  */
        -: 8752:
       45: 8753:  yyn = yypact[yystate];
       45: 8754:  if (yyn == YYFLAG)
       22: 8755:    goto yydefault;
        -: 8756:
        -: 8757:  /* Not known => get a lookahead token if don't already have one.  */
        -: 8758:
        -: 8759:  /* yychar is either YYEMPTY or YYEOF
        -: 8760:     or a valid token in external form.  */
        -: 8761:
       23: 8762:  if (yychar == YYEMPTY)
        -: 8763:    {
        -: 8764:#if YYDEBUG != 0
        -: 8765:      if (yydebug)
        -: 8766:	fprintf(err, "Reading a token: ");
        -: 8767:#endif
       18: 8768:      yychar = YYLEX;
        -: 8769:    }
        -: 8770:
        -: 8771:  /* Convert token to internal form (in yychar1) for indexing tables with */
        -: 8772:
       23: 8773:  if (yychar <= 0)		/* This means end of input. */
        -: 8774:    {
        3: 8775:      yychar1 = 0;
        3: 8776:      yychar = YYEOF;		/* Don't call YYLEX any more */
        -: 8777:
        -: 8778:#if YYDEBUG != 0
        -: 8779:      if (yydebug)
        -: 8780:	fprintf(err, "Now at end of input.\n");
        -: 8781:#endif
        -: 8782:    }
        -: 8783:  else
        -: 8784:    {
       20: 8785:      yychar1 = YYTRANSLATE(yychar);
        -: 8786:
        -: 8787:#if YYDEBUG != 0
        -: 8788:      if (yydebug)
        -: 8789:	{
        -: 8790:	  fprintf (err, "Next token is %d (%s", yychar, yytname[yychar1]);
        -: 8791:	  /* Give the individual parser a way to print the precise meaning
        -: 8792:	     of a token, for further debugging info.  */
        -: 8793:#ifdef YYPRINT
        -: 8794:	  YYPRINT (err, yychar, yylval);
        -: 8795:#endif
        -: 8796:	  fprintf (err, ")\n");
        -: 8797:	}
        -: 8798:#endif
        -: 8799:    }
        -: 8800:
       23: 8801:  yyn += yychar1;
       23: 8802:  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
        -: 8803:    goto yydefault;
        -: 8804:
       23: 8805:  yyn = yytable[yyn];
        -: 8806:
        -: 8807:  /* yyn is what to do for this token type in this state.
        -: 8808:     Negative => reduce, -yyn is rule number.
        -: 8809:     Positive => shift, yyn is new state.
        -: 8810:       New state is final state => don't bother to shift,
        -: 8811:       just return success.
        -: 8812:     0, or most negative number => error.  */
        -: 8813:
       23: 8814:  if (yyn < 0)
        -: 8815:    {
        4: 8816:      if (yyn == YYFLAG)
    #####: 8817:	goto yyerrlab;
        4: 8818:      yyn = -yyn;
        4: 8819:      goto yyreduce;
        -: 8820:    }
       19: 8821:  else if (yyn == 0)
    #####: 8822:    goto yyerrlab;
        -: 8823:
       19: 8824:  if (yyn == YYFINAL)
        1: 8825:    YYACCEPT;
        -: 8826:
        -: 8827:  /* Shift the lookahead token.  */
        -: 8828:
        -: 8829:#if YYDEBUG != 0
        -: 8830:  if (yydebug)
        -: 8831:    fprintf(err, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
        -: 8832:#endif
        -: 8833:
        -: 8834:  /* Discard the token being shifted unless it is eof.  */
       18: 8835:  if (yychar != YYEOF)
       17: 8836:    yychar = YYEMPTY;
        -: 8837:
       18: 8838:  *++yyvsp = yylval;
        -: 8839:#ifdef YYLSP_NEEDED
        -: 8840:  *++yylsp = yylloc;
        -: 8841:#endif
        -: 8842:
        -: 8843:  /* count tokens shifted since error; after three, turn off error status.  */
       18: 8844:  if (yyerrstatus) yyerrstatus--;
        -: 8845:
       18: 8846:  yystate = yyn;
       18: 8847:  goto yynewstate;
        -: 8848:
        -: 8849:/* Do the default action for the current state.  */
        -: 8850:yydefault:
        -: 8851:
       22: 8852:  yyn = yydefact[yystate];
       22: 8853:  if (yyn == 0)
    #####: 8854:    goto yyerrlab;
        -: 8855:
        -: 8856:/* Do a reduction.  yyn is the number of a rule to reduce with.  */
        -: 8857:yyreduce:
       26: 8858:  yylen = yyr2[yyn];
       26: 8859:  if (yylen > 0)
       17: 8860:    yyval = yyvsp[1-yylen]; /* implement default value of the action */
        -: 8861:
        -: 8862:#if YYDEBUG != 0
        -: 8863:  if (yydebug)
        -: 8864:    {
        -: 8865:      int i;
        -: 8866:
        -: 8867:      fprintf (err, "Reducing via rule %d (line %d), ",
        -: 8868:	       yyn, yyrline[yyn]);
        -: 8869:
        -: 8870:      /* Print the symbols being reduced, and their result.  */
        -: 8871:      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
        -: 8872:	fprintf (err, "%s ", yytname[yyrhs[i]]);
        -: 8873:      fprintf (err, " -> %s\n", yytname[yyr1[yyn]]);
        -: 8874:    }
        -: 8875:#endif
        -: 8876:
        -: 8877:
       26: 8878:  switch (yyn) {
        -: 8879:
        -: 8880:case 1:
        -: 8881:{ /* add default rule */
        -: 8882:			int def_rule;
        -: 8883:
        1: 8884:			pat = cclinit();
        1: 8885:			cclnegate( pat );
        -: 8886:
        1: 8887:			def_rule = mkstate( -pat );
        -: 8888:
        -: 8889:			/* Remember the number of the default rule so we
        -: 8890:			 * don't generate "can't match" warnings for it.
        -: 8891:			 */
        1: 8892:			default_rule = num_rules;
        -: 8893:
        1: 8894:			finish_rule( def_rule, false, 0, 0 );
        -: 8895:
        3: 8896:			for ( i = 1; i <= lastsc; ++i )
        2: 8897:				scset[i] = mkbranch( scset[i], def_rule );
        -: 8898:
        1: 8899:			if ( spprdflt )
    #####: 8900:				add_action(
        -: 8901:				"YY_FATAL_ERROR( \"flex scanner jammed\" )" );
        -: 8902:			else
        1: 8903:				add_action( "ECHO" );
        -: 8904:
        1: 8905:			add_action( ";\n\tYY_BREAK\n" );
        -: 8906:			;
        1: 8907:    break;}
        -: 8908:case 2:
        -: 8909:{ /* initialize for processing rules */
        -: 8910:
        -: 8911:			/* Create default DFA start condition. */
        1: 8912:			scinstal( "INITIAL", false );
        -: 8913:
        -: 8914:			/* Initially, the start condition scoping is
        -: 8915:			 * "no start conditions active".
        -: 8916:			 */
        1: 8917:			actvp = 0;
        -: 8918:			;
        1: 8919:    break;}
        -: 8920:case 5:
    #####: 8921:{ synerr( "unknown error processing section 1" ); ;
    #####: 8922:    break;}
        -: 8923:case 6:
        -: 8924:{
        -: 8925:			/* We now know how many start conditions there
        -: 8926:			 * are, so create the "activity" map indicating
        -: 8927:			 * which conditions are active.
        -: 8928:			 */
        1: 8929:			active_ss = allocate_integer_array( lastsc + 1 );
        -: 8930:
        3: 8931:			for ( i = 1; i <= lastsc; ++i )
        2: 8932:				active_ss[i] = 0;
        -: 8933:			;
        1: 8934:    break;}
        -: 8935:case 7:
    #####: 8936:{ xcluflg = false; ;
    #####: 8937:    break;}
        -: 8938:case 8:
        1: 8939:{ xcluflg = true; ;
        1: 8940:    break;}
        -: 8941:case 9:
    #####: 8942:{ scinstal( nmstr, xcluflg ); ;
    #####: 8943:    break;}
        -: 8944:case 10:
        1: 8945:{ scinstal( nmstr, xcluflg ); ;
        1: 8946:    break;}
        -: 8947:case 11:
    #####: 8948:{ synerr( "bad start condition list" ); ;
    #####: 8949:    break;}
        -: 8950:case 14:
        -: 8951:{
        -: 8952:			/* Initialize for a parse of one rule. */
        4: 8953:			trlcontxt = variable_trail_rule = varlength = false;
        4: 8954:			trailcnt = headcnt = rulelen = 0;
        4: 8955:			current_state_type = STATE_NORMAL;
        4: 8956:			previous_continued_action = continued_action;
        4: 8957:			new_rule();
        -: 8958:			;
        4: 8959:    break;}
        -: 8960:case 15:
        -: 8961:{
    #####: 8962:			pat = yyvsp[0];
    #####: 8963:			finish_rule( pat, variable_trail_rule,
        -: 8964:				headcnt, trailcnt );
        -: 8965:
    #####: 8966:			for ( i = 1; i <= actvp; ++i )
    #####: 8967:				scbol[actvsc[i]] =
    #####: 8968:					mkbranch( scbol[actvsc[i]], pat );
        -: 8969:
    #####: 8970:			if ( ! bol_needed )
        -: 8971:				{
    #####: 8972:				bol_needed = true;
        -: 8973:
    #####: 8974:				if ( performance_report > 1 )
    #####: 8975:					pinpoint_message( 
        -: 8976:			"'^' operator results in sub-optimal performance" );
        -: 8977:				}
        -: 8978:			;
    #####: 8979:    break;}
        -: 8980:case 16:
        -: 8981:{
    #####: 8982:			pat = yyvsp[0];
    #####: 8983:			finish_rule( pat, variable_trail_rule,
        -: 8984:				headcnt, trailcnt );
        -: 8985:
    #####: 8986:			for ( i = 1; i <= actvp; ++i )
    #####: 8987:				scset[actvsc[i]] =
    #####: 8988:					mkbranch( scset[actvsc[i]], pat );
        -: 8989:			;
    #####: 8990:    break;}
        -: 8991:case 17:
        -: 8992:{
    #####: 8993:			pat = yyvsp[0];
    #####: 8994:			finish_rule( pat, variable_trail_rule,
        -: 8995:				headcnt, trailcnt );
        -: 8996:
        -: 8997:			/* Add to all non-exclusive start conditions,
        -: 8998:			 * including the default (0) start condition.
        -: 8999:			 */
        -: 9000:
    #####: 9001:			for ( i = 1; i <= lastsc; ++i )
    #####: 9002:				if ( ! scxclu[i] )
    #####: 9003:					scbol[i] = mkbranch( scbol[i], pat );
        -: 9004:
    #####: 9005:			if ( ! bol_needed )
        -: 9006:				{
    #####: 9007:				bol_needed = true;
        -: 9008:
    #####: 9009:				if ( performance_report > 1 )
    #####: 9010:					pinpoint_message(
        -: 9011:			"'^' operator results in sub-optimal performance" );
        -: 9012:				}
        -: 9013:			;
    #####: 9014:    break;}
        -: 9015:case 18:
        -: 9016:{
    #####: 9017:			pat = yyvsp[0];
    #####: 9018:			finish_rule( pat, variable_trail_rule,
        -: 9019:				headcnt, trailcnt );
        -: 9020:
    #####: 9021:			for ( i = 1; i <= lastsc; ++i )
    #####: 9022:				if ( ! scxclu[i] )
    #####: 9023:					scset[i] = mkbranch( scset[i], pat );
        -: 9024:			;
    #####: 9025:    break;}
        -: 9026:case 19:
        2: 9027:{ build_eof_action(); ;
        2: 9028:    break;}
        -: 9029:case 20:
        -: 9030:{
        -: 9031:			/* This EOF applies to all start conditions
        -: 9032:			 * which don't already have EOF actions.
        -: 9033:			 */
        1: 9034:			actvp = 0;
        -: 9035:
        3: 9036:			for ( i = 1; i <= lastsc; ++i )
        2: 9037:				if ( ! sceof[i] )
        1: 9038:					actvsc[++actvp] = i;
        -: 9039:
        1: 9040:			if ( actvp == 0 )
    #####: 9041:				warn(
        -: 9042:			"all start conditions already have <<EOF>> rules" );
        -: 9043:
        -: 9044:			else
        1: 9045:				build_eof_action();
        -: 9046:			;
        1: 9047:    break;}
        -: 9048:case 21:
    #####: 9049:{ synerr( "unrecognized rule" ); ;
    #####: 9050:    break;}
        -: 9051:case 23:
        -: 9052:{
    #####: 9053:			actvp = 0;
        -: 9054:
    #####: 9055:			for ( i = 1; i <= lastsc; ++i )
    #####: 9056:				actvsc[++actvp] = i;
        -: 9057:			;
    #####: 9058:    break;}
        -: 9059:case 25:
        2: 9060:{ actvp = 0; ;
        2: 9061:    break;}
        -: 9062:case 27:
    #####: 9063:{ synerr( "bad start condition list" ); ;
    #####: 9064:    break;}
        -: 9065:case 28:
        -: 9066:{
        2: 9067:			if ( (scnum = sclookup( nmstr )) == 0 )
    #####: 9068:				format_pinpoint_message(
        -: 9069:					"undeclared start condition %s",
        -: 9070:					nmstr );
        -: 9071:			else
        -: 9072:				{
        2: 9073:				if ( ++actvp >= current_max_scs )
        -: 9074:					/* Some bozo has included multiple
        -: 9075:					 * instances of start condition names.
        -: 9076:					 */
    #####: 9077:					pinpoint_message(
        -: 9078:				"too many start conditions in <> construct!" );
        -: 9079:
        -: 9080:				else
        2: 9081:					actvsc[actvp] = scnum;
        -: 9082:				}
        -: 9083:			;
        2: 9084:    break;}
        -: 9085:case 29:
        -: 9086:{
    #####: 9087:			if ( transchar[lastst[yyvsp[0]]] != SYM_EPSILON )
        -: 9088:				/* Provide final transition \now/ so it
        -: 9089:				 * will be marked as a trailing context
        -: 9090:				 * state.
        -: 9091:				 */
    #####: 9092:				yyvsp[0] = link_machines( yyvsp[0],
        -: 9093:						mkstate( SYM_EPSILON ) );
        -: 9094:
    #####: 9095:			mark_beginning_as_normal( yyvsp[0] );
    #####: 9096:			current_state_type = STATE_NORMAL;
        -: 9097:
    #####: 9098:			if ( previous_continued_action )
        -: 9099:				{
        -: 9100:				/* We need to treat this as variable trailing
        -: 9101:				 * context so that the backup does not happen
        -: 9102:				 * in the action but before the action switch
        -: 9103:				 * statement.  If the backup happens in the
        -: 9104:				 * action, then the rules "falling into" this
        -: 9105:				 * one's action will *also* do the backup,
        -: 9106:				 * erroneously.
        -: 9107:				 */
    #####: 9108:				if ( ! varlength || headcnt != 0 )
    #####: 9109:					warn(
        -: 9110:		"trailing context made variable due to preceding '|' action" );
        -: 9111:
        -: 9112:				/* Mark as variable. */
    #####: 9113:				varlength = true;
    #####: 9114:				headcnt = 0;
        -: 9115:				}
        -: 9116:
    #####: 9117:			if ( lex_compat || (varlength && headcnt == 0) )
        -: 9118:				{ /* variable trailing context rule */
        -: 9119:				/* Mark the first part of the rule as the
        -: 9120:				 * accepting "head" part of a trailing
        -: 9121:				 * context rule.
        -: 9122:				 *
        -: 9123:				 * By the way, we didn't do this at the
        -: 9124:				 * beginning of this production because back
        -: 9125:				 * then current_state_type was set up for a
        -: 9126:				 * trail rule, and add_accept() can create
        -: 9127:				 * a new state ...
        -: 9128:				 */
    #####: 9129:				add_accept( yyvsp[-1],
        -: 9130:					num_rules | YY_TRAILING_HEAD_MASK );
    #####: 9131:				variable_trail_rule = true;
        -: 9132:				}
        -: 9133:			
        -: 9134:			else
    #####: 9135:				trailcnt = rulelen;
        -: 9136:
    #####: 9137:			yyval = link_machines( yyvsp[-1], yyvsp[0] );
        -: 9138:			;
    #####: 9139:    break;}
        -: 9140:case 30:
    #####: 9141:{ synerr( "trailing context used twice" ); ;
    #####: 9142:    break;}
        -: 9143:case 31:
        -: 9144:{
    #####: 9145:			headcnt = 0;
    #####: 9146:			trailcnt = 1;
    #####: 9147:			rulelen = 1;
        -: 9148:#ifndef	F_HD_7
    #####: 9149:			varlength = false; 
        -: 9150:#else
        -: 9151:			varlength = true; 
        -: 9152:#endif
        -: 9153:
    #####: 9154:			current_state_type = STATE_TRAILING_CONTEXT;
        -: 9155:
    #####: 9156:			if ( trlcontxt )
        -: 9157:				{
    #####: 9158:				synerr( "trailing context used twice" );
    #####: 9159:				yyval = mkstate( SYM_EPSILON );
        -: 9160:				}
        -: 9161:
    #####: 9162:			else if ( previous_continued_action )
        -: 9163:				{
        -: 9164:				/* See the comment in the rule for "re2 re"
        -: 9165:				 * above.
        -: 9166:				 */
    #####: 9167:				warn(
        -: 9168:		"trailing context made variable due to preceding '|' action" );
        -: 9169:
    #####: 9170:				varlength = true;
        -: 9171:				}
        -: 9172:
    #####: 9173:			if ( lex_compat || varlength )
        -: 9174:				{
        -: 9175:				/* Again, see the comment in the rule for
        -: 9176:				 * "re2 re" above.
        -: 9177:				 */
    #####: 9178:				add_accept( yyvsp[-1],
        -: 9179:					num_rules | YY_TRAILING_HEAD_MASK );
    #####: 9180:				variable_trail_rule = true;
        -: 9181:				}
        -: 9182:
    #####: 9183:			trlcontxt = true;
        -: 9184:
    #####: 9185:			eps = mkstate( SYM_EPSILON );
    #####: 9186:			yyval = link_machines( yyvsp[-1],
        -: 9187:				link_machines( eps, mkstate( '\n' ) ) );
        -: 9188:			;
    #####: 9189:    break;}
        -: 9190:case 32:
        -: 9191:{
    #####: 9192:			yyval = yyvsp[0];
        -: 9193:
    #####: 9194:			if ( trlcontxt )
        -: 9195:				{
    #####: 9196:				if ( lex_compat || (varlength && headcnt == 0) )
        -: 9197:					/* Both head and trail are
        -: 9198:					 * variable-length.
        -: 9199:					 */
    #####: 9200:					variable_trail_rule = true;
        -: 9201:				else
    #####: 9202:					trailcnt = rulelen;
        -: 9203:				}
        -: 9204:			;
    #####: 9205:    break;}
        -: 9206:case 33:
        -: 9207:{
    #####: 9208:			varlength = true;
    #####: 9209:			yyval = mkor( yyvsp[-2], yyvsp[0] );
        -: 9210:			;
    #####: 9211:    break;}
        -: 9212:case 34:
    #####: 9213:{ yyval = yyvsp[0]; ;
    #####: 9214:    break;}
        -: 9215:case 35:
        -: 9216:{
        -: 9217:			/* This rule is written separately so the
        -: 9218:			 * reduction will occur before the trailing
        -: 9219:			 * series is parsed.
        -: 9220:			 */
        -: 9221:
    #####: 9222:			if ( trlcontxt )
    #####: 9223:				synerr( "trailing context used twice" );
        -: 9224:			else
    #####: 9225:				trlcontxt = true;
        -: 9226:
    #####: 9227:			if ( varlength )
        -: 9228:				/* We hope the trailing context is
        -: 9229:				 * fixed-length.
        -: 9230:				 */
    #####: 9231:				varlength = false;
        -: 9232:			else
    #####: 9233:				headcnt = rulelen;
        -: 9234:
    #####: 9235:			rulelen = 0;
        -: 9236:
    #####: 9237:			current_state_type = STATE_TRAILING_CONTEXT;
    #####: 9238:			yyval = yyvsp[-1];
        -: 9239:			;
    #####: 9240:    break;}
        -: 9241:case 36:
        -: 9242:{
        -: 9243:			/* This is where concatenation of adjacent patterns
        -: 9244:			 * gets done.
        -: 9245:			 */
    #####: 9246:			yyval = link_machines( yyvsp[-1], yyvsp[0] );
        -: 9247:			;
    #####: 9248:    break;}
        -: 9249:case 37:
    #####: 9250:{ yyval = yyvsp[0]; ;
    #####: 9251:    break;}
        -: 9252:case 38:
        -: 9253:{
    #####: 9254:			varlength = true;
        -: 9255:
    #####: 9256:			yyval = mkclos( yyvsp[-1] );
        -: 9257:			;
    #####: 9258:    break;}
        -: 9259:case 39:
        -: 9260:{
    #####: 9261:			varlength = true;
    #####: 9262:			yyval = mkposcl( yyvsp[-1] );
        -: 9263:			;
    #####: 9264:    break;}
        -: 9265:case 40:
        -: 9266:{
    #####: 9267:			varlength = true;
    #####: 9268:			yyval = mkopt( yyvsp[-1] );
        -: 9269:			;
    #####: 9270:    break;}
        -: 9271:case 41:
        -: 9272:{
    #####: 9273:			varlength = true;
        -: 9274:
    #####: 9275:			if ( yyvsp[-3] > yyvsp[-1] || yyvsp[-3] < 0 )
        -: 9276:				{
    #####: 9277:				synerr( "bad iteration values" );
    #####: 9278:				yyval = yyvsp[-5];
        -: 9279:				}
        -: 9280:			else
        -: 9281:				{
    #####: 9282:				if ( yyvsp[-3] == 0 )
        -: 9283:					{
    #####: 9284:					if ( yyvsp[-1] <= 0 )
        -: 9285:						{
    #####: 9286:						synerr(
        -: 9287:						"bad iteration values" );
    #####: 9288:						yyval = yyvsp[-5];
        -: 9289:						}
        -: 9290:					else
    #####: 9291:						yyval = mkopt(
    #####: 9292:							mkrep( yyvsp[-5], 1, yyvsp[-1] ) );
        -: 9293:					}
        -: 9294:				else
    #####: 9295:					yyval = mkrep( yyvsp[-5], yyvsp[-3], yyvsp[-1] );
        -: 9296:				}
        -: 9297:			;
    #####: 9298:    break;}
        -: 9299:case 42:
        -: 9300:{
    #####: 9301:			varlength = true;
        -: 9302:
    #####: 9303:			if ( yyvsp[-2] <= 0 )
        -: 9304:				{
    #####: 9305:				synerr( "iteration value must be positive" );
    #####: 9306:				yyval = yyvsp[-4];
        -: 9307:				}
        -: 9308:
        -: 9309:			else
    #####: 9310:				yyval = mkrep( yyvsp[-4], yyvsp[-2], INFINITY );
        -: 9311:			;
    #####: 9312:    break;}
        -: 9313:case 43:
        -: 9314:{
        -: 9315:			/* The singleton could be something like "(foo)",
        -: 9316:			 * in which case we have no idea what its length
        -: 9317:			 * is, so we punt here.
        -: 9318:			 */
    #####: 9319:			varlength = true;
        -: 9320:
    #####: 9321:			if ( yyvsp[-1] <= 0 )
        -: 9322:				{
    #####: 9323:				synerr( "iteration value must be positive" );
    #####: 9324:				yyval = yyvsp[-3];
        -: 9325:				}
        -: 9326:
        -: 9327:			else
    #####: 9328:				yyval = link_machines( yyvsp[-3],
    #####: 9329:						copysingl( yyvsp[-3], yyvsp[-1] - 1 ) );
        -: 9330:			;
    #####: 9331:    break;}
        -: 9332:case 44:
        -: 9333:{
    #####: 9334:			if ( ! madeany )
        -: 9335:				{
        -: 9336:				/* Create the '.' character class. */
    #####: 9337:				anyccl = cclinit();
    #####: 9338:				ccladd( anyccl, '\n' );
    #####: 9339:				cclnegate( anyccl );
        -: 9340:
    #####: 9341:				if ( useecs )
    #####: 9342:					mkeccl( ccltbl + cclmap[anyccl],
    #####: 9343:						ccllen[anyccl], nextecm,
        -: 9344:						ecgroup, csize, csize );
        -: 9345:
    #####: 9346:				madeany = true;
        -: 9347:				}
        -: 9348:
    #####: 9349:			++rulelen;
        -: 9350:
    #####: 9351:			yyval = mkstate( -anyccl );
        -: 9352:			;
    #####: 9353:    break;}
        -: 9354:case 45:
        -: 9355:{
    #####: 9356:			if ( ! cclsorted )
        -: 9357:				/* Sort characters for fast searching.  We
        -: 9358:				 * use a shell sort since this list could
        -: 9359:				 * be large.
        -: 9360:				 */
    #####: 9361:				cshell( ccltbl + cclmap[yyvsp[0]], ccllen[yyvsp[0]], true );
        -: 9362:
    #####: 9363:			if ( useecs )
    #####: 9364:				mkeccl( ccltbl + cclmap[yyvsp[0]], ccllen[yyvsp[0]],
        -: 9365:					nextecm, ecgroup, csize, csize );
        -: 9366:
    #####: 9367:			++rulelen;
        -: 9368:
    #####: 9369:			yyval = mkstate( -yyvsp[0] );
        -: 9370:			;
    #####: 9371:    break;}
        -: 9372:case 46:
        -: 9373:{
    #####: 9374:			++rulelen;
        -: 9375:
    #####: 9376:			yyval = mkstate( -yyvsp[0] );
        -: 9377:			;
    #####: 9378:    break;}
        -: 9379:case 47:
    #####: 9380:{ yyval = yyvsp[-1]; ;
    #####: 9381:    break;}
        -: 9382:case 48:
    #####: 9383:{ yyval = yyvsp[-1]; ;
    #####: 9384:    break;}
        -: 9385:case 49:
        -: 9386:{
    #####: 9387:			++rulelen;
        -: 9388:
    #####: 9389:			if ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
    #####: 9390:				yyvsp[0] = clower( yyvsp[0] );
        -: 9391:
    #####: 9392:			yyval = mkstate( yyvsp[0] );
        -: 9393:			;
    #####: 9394:    break;}
        -: 9395:case 50:
    #####: 9396:{ yyval = yyvsp[-1]; ;
    #####: 9397:    break;}
        -: 9398:case 51:
        -: 9399:{
    #####: 9400:			cclnegate( yyvsp[-1] );
    #####: 9401:			yyval = yyvsp[-1];
        -: 9402:			;
    #####: 9403:    break;}
        -: 9404:case 52:
        -: 9405:{
    #####: 9406:			if ( caseins )
        -: 9407:				{
    #####: 9408:				if ( yyvsp[-2] >= 'A' && yyvsp[-2] <= 'Z' )
    #####: 9409:					yyvsp[-2] = clower( yyvsp[-2] );
    #####: 9410:				if ( yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
    #####: 9411:					yyvsp[0] = clower( yyvsp[0] );
        -: 9412:				}
        -: 9413:
    #####: 9414:			if ( yyvsp[-2] > yyvsp[0] )
    #####: 9415:				synerr( "negative range in character class" );
        -: 9416:
        -: 9417:			else
        -: 9418:				{
    #####: 9419:				for ( i = yyvsp[-2]; i <= yyvsp[0]; ++i )
    #####: 9420:					ccladd( yyvsp[-3], i );
        -: 9421:
        -: 9422:				/* Keep track if this ccl is staying in
        -: 9423:				 * alphabetical order.
        -: 9424:				 */
    #####: 9425:				cclsorted = cclsorted && (yyvsp[-2] > lastchar);
    #####: 9426:				lastchar = yyvsp[0];
        -: 9427:				}
        -: 9428:
    #####: 9429:			yyval = yyvsp[-3];
        -: 9430:			;
    #####: 9431:    break;}
        -: 9432:case 53:
        -: 9433:{
    #####: 9434:			if ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
    #####: 9435:				yyvsp[0] = clower( yyvsp[0] );
        -: 9436:
    #####: 9437:			ccladd( yyvsp[-1], yyvsp[0] );
    #####: 9438:			cclsorted = cclsorted && (yyvsp[0] > lastchar);
    #####: 9439:			lastchar = yyvsp[0];
    #####: 9440:			yyval = yyvsp[-1];
        -: 9441:			;
    #####: 9442:    break;}
        -: 9443:case 54:
        -: 9444:{
    #####: 9445:			cclsorted = true;
    #####: 9446:			lastchar = 0;
    #####: 9447:			yyval = cclinit();
        -: 9448:			;
    #####: 9449:    break;}
        -: 9450:case 55:
        -: 9451:{
    #####: 9452:			if ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )
    #####: 9453:				yyvsp[0] = clower( yyvsp[0] );
        -: 9454:
    #####: 9455:			++rulelen;
        -: 9456:
    #####: 9457:			yyval = link_machines( yyvsp[-1], mkstate( yyvsp[0] ) );
        -: 9458:			;
    #####: 9459:    break;}
        -: 9460:case 56:
    #####: 9461:{ yyval = mkstate( SYM_EPSILON ); ;
    #####: 9462:    break;}
        -: 9463:}
        -: 9464:   /* the action file gets copied in in place of this dollarsign */
       26: 9465:  yyvsp -= yylen;
       26: 9466:  yyssp -= yylen;
        -: 9467:#ifdef YYLSP_NEEDED
        -: 9468:  yylsp -= yylen;
        -: 9469:#endif
        -: 9470:
        -: 9471:#if YYDEBUG != 0
        -: 9472:  if (yydebug)
        -: 9473:    {
        -: 9474:      short *ssp1 = yyss - 1;
        -: 9475:      fprintf (err, "state stack now");
        -: 9476:      while (ssp1 != yyssp)
        -: 9477:	fprintf (err, " %d", *++ssp1);
        -: 9478:      fprintf (err, "\n");
        -: 9479:    }
        -: 9480:#endif
        -: 9481:
       26: 9482:  *++yyvsp = yyval;
        -: 9483:
        -: 9484:#ifdef YYLSP_NEEDED
        -: 9485:  yylsp++;
        -: 9486:  if (yylen == 0)
        -: 9487:    {
        -: 9488:      yylsp->first_line = yylloc.first_line;
        -: 9489:      yylsp->first_column = yylloc.first_column;
        -: 9490:      yylsp->last_line = (yylsp-1)->last_line;
        -: 9491:      yylsp->last_column = (yylsp-1)->last_column;
        -: 9492:      yylsp->text = 0;
        -: 9493:    }
        -: 9494:  else
        -: 9495:    {
        -: 9496:      yylsp->last_line = (yylsp+yylen-1)->last_line;
        -: 9497:      yylsp->last_column = (yylsp+yylen-1)->last_column;
        -: 9498:    }
        -: 9499:#endif
        -: 9500:
        -: 9501:  /* Now "shift" the result of the reduction.
        -: 9502:     Determine what state that goes to,
        -: 9503:     based on the state we popped back to
        -: 9504:     and the rule number reduced by.  */
        -: 9505:
       26: 9506:  yyn = yyr1[yyn];
        -: 9507:
       26: 9508:  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
       26: 9509:  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    #####: 9510:    yystate = yytable[yystate];
        -: 9511:  else
       26: 9512:    yystate = yydefgoto[yyn - YYNTBASE];
        -: 9513:
       26: 9514:  goto yynewstate;
        -: 9515:
        -: 9516:yyerrlab:   /* here on detecting error */
        -: 9517:
    #####: 9518:  if (! yyerrstatus)
        -: 9519:    /* If not already recovering from an error, report this error.  */
        -: 9520:    {
    #####: 9521:      ++yynerrs;
        -: 9522:
        -: 9523:#ifdef YYERROR_VERBOSE
        -: 9524:      yyn = yypact[yystate];
        -: 9525:
        -: 9526:      if (yyn > YYFLAG && yyn < YYLAST)
        -: 9527:	{
        -: 9528:	  int size = 0;
        -: 9529:	  char *msg;
        -: 9530:	  int x, count;
        -: 9531:
        -: 9532:	  count = 0;
        -: 9533:	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
        -: 9534:	  for (x = (yyn < 0 ? -yyn : 0);
        -: 9535:	       x < (sizeof(yytname) / sizeof(char *)); x++)
        -: 9536:	    if (yycheck[x + yyn] == x)
        -: 9537:	      size += strlen(yytname[x]) + 15, count++;
        -: 9538:	  msg = (char *) malloc(size + 15);
        -: 9539:	  if (msg != 0)
        -: 9540:	    {
        -: 9541:	      strcpy(msg, "parse error");
        -: 9542:
        -: 9543:	      if (count < 5)
        -: 9544:		{
        -: 9545:		  count = 0;
        -: 9546:		  for (x = (yyn < 0 ? -yyn : 0);
        -: 9547:		       x < (sizeof(yytname) / sizeof(char *)); x++)
        -: 9548:		    if (yycheck[x + yyn] == x)
        -: 9549:		      {
        -: 9550:			strcat(msg, count == 0 ? ", expecting `" : " or `");
        -: 9551:			strcat(msg, yytname[x]);
        -: 9552:			strcat(msg, "'");
        -: 9553:			count++;
        -: 9554:		      }
        -: 9555:		}
        -: 9556:	      yyerror(msg);
        -: 9557:	      free(msg);
        -: 9558:	    }
        -: 9559:	  else
        -: 9560:	    yyerror ("parse error; also virtual memory exceeded");
        -: 9561:	}
        -: 9562:      else
        -: 9563:#endif /* YYERROR_VERBOSE */
    #####: 9564:	yyerror("parse error");
        -: 9565:    }
        -: 9566:
    #####: 9567:  goto yyerrlab1;
        -: 9568:yyerrlab1:   /* here on error raised explicitly by an action */
        -: 9569:
    #####: 9570:  if (yyerrstatus == 3)
        -: 9571:    {
        -: 9572:      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
        -: 9573:
        -: 9574:      /* return failure if at end of input */
    #####: 9575:      if (yychar == YYEOF)
    #####: 9576:	YYABORT;
        -: 9577:
        -: 9578:#if YYDEBUG != 0
        -: 9579:      if (yydebug)
        -: 9580:	fprintf(err, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
        -: 9581:#endif
        -: 9582:
    #####: 9583:      yychar = YYEMPTY;
        -: 9584:    }
        -: 9585:
        -: 9586:  /* Else will try to reuse lookahead token
        -: 9587:     after shifting the error token.  */
        -: 9588:
    #####: 9589:  yyerrstatus = 3;		/* Each real token shifted decrements this */
        -: 9590:
    #####: 9591:  goto yyerrhandle;
        -: 9592:
        -: 9593:yyerrdefault:  /* current state does not do anything special for the error token. */
        -: 9594:
        -: 9595:#if 0
        -: 9596:  /* This is wrong; only states that explicitly want error tokens
        -: 9597:     should shift them.  */
        -: 9598:  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
        -: 9599:  if (yyn) goto yydefault;
        -: 9600:#endif
        -: 9601:
        -: 9602:yyerrpop:   /* pop the current state because it cannot handle the error token */
        -: 9603:
    #####: 9604:  if (yyssp == yyss) YYABORT;
    #####: 9605:  yyvsp--;
    #####: 9606:  yystate = *--yyssp;
        -: 9607:#ifdef YYLSP_NEEDED
        -: 9608:  yylsp--;
        -: 9609:#endif
        -: 9610:
        -: 9611:#if YYDEBUG != 0
        -: 9612:  if (yydebug)
        -: 9613:    {
        -: 9614:      short *ssp1 = yyss - 1;
        -: 9615:      fprintf (err, "Error: state stack now");
        -: 9616:      while (ssp1 != yyssp)
        -: 9617:	fprintf (err, " %d", *++ssp1);
        -: 9618:      fprintf (err, "\n");
        -: 9619:    }
        -: 9620:#endif
        -: 9621:
        -: 9622:yyerrhandle:
        -: 9623:
    #####: 9624:  yyn = yypact[yystate];
    #####: 9625:  if (yyn == YYFLAG)
    #####: 9626:    goto yyerrdefault;
        -: 9627:
    #####: 9628:  yyn += YYTERROR;
    #####: 9629:  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
        -: 9630:    goto yyerrdefault;
        -: 9631:
    #####: 9632:  yyn = yytable[yyn];
    #####: 9633:  if (yyn < 0)
        -: 9634:    {
    #####: 9635:      if (yyn == YYFLAG)
    #####: 9636:	goto yyerrpop;
    #####: 9637:      yyn = -yyn;
    #####: 9638:      goto yyreduce;
        -: 9639:    }
    #####: 9640:  else if (yyn == 0)
    #####: 9641:    goto yyerrpop;
        -: 9642:
    #####: 9643:  if (yyn == YYFINAL)
    #####: 9644:    YYACCEPT;
        -: 9645:
        -: 9646:#if YYDEBUG != 0
        -: 9647:  if (yydebug)
        -: 9648:    fprintf(err, "Shifting error token, ");
        -: 9649:#endif
        -: 9650:
    #####: 9651:  *++yyvsp = yylval;
        -: 9652:#ifdef YYLSP_NEEDED
        -: 9653:  *++yylsp = yylloc;
        -: 9654:#endif
        -: 9655:
    #####: 9656:  yystate = yyn;
    #####: 9657:  goto yynewstate;
        -: 9658:
        -: 9659: yyacceptlab:
        -: 9660:  /* YYACCEPT comes here.  */
        1: 9661:  if (yyfree_stacks)
        -: 9662:    {
    #####: 9663:      free (yyss);
    #####: 9664:      free (yyvs);
        -: 9665:#ifdef YYLSP_NEEDED
        -: 9666:      free (yyls);
        -: 9667:#endif
        -: 9668:    }
        1: 9669:  return 0;
        -: 9670:
        -: 9671: yyabortlab:
        -: 9672:  /* YYABORT comes here.  */
    #####: 9673:  if (yyfree_stacks)
        -: 9674:    {
    #####: 9675:      free (yyss);
    #####: 9676:      free (yyvs);
        -: 9677:#ifdef YYLSP_NEEDED
        -: 9678:      free (yyls);
        -: 9679:#endif
        -: 9680:    }
    #####: 9681:  return 1;
        -: 9682:}
        -: 9683:
        -: 9684:
        -: 9685:
        -: 9686:/* build_eof_action - build the "<<EOF>>" action for the active start
        -: 9687: *                    conditions
        -: 9688: */
        -: 9689:
        3: 9690:void build_eof_action()
        -: 9691:	{
        -: 9692:	register int i;
        -: 9693:	char action_text[MAXLINE];
        -: 9694:
        6: 9695:	for ( i = 1; i <= actvp; ++i )
        -: 9696:		{
        3: 9697:		if ( sceof[actvsc[i]] )
        1: 9698:			format_pinpoint_message(
        -: 9699:				"multiple <<EOF>> rules for start condition %s",
        1: 9700:				scname[actvsc[i]] );
        -: 9701:
        -: 9702:		else
        -: 9703:			{
        2: 9704:			sceof[actvsc[i]] = true;
        2: 9705:			sprintf( action_text, "case YY_STATE_EOF(%s):\n",
        2: 9706:			scname[actvsc[i]] );
        2: 9707:			add_action( action_text );
        -: 9708:			}
        -: 9709:		}
        -: 9710:
        3: 9711:	line_directive_out( (FILE *) 0 );
        -: 9712:
        -: 9713:	/* This isn't a normal rule after all - don't count it as
        -: 9714:	 * such, so we don't have any holes in the rule numbering
        -: 9715:	 * (which make generating "rule can never match" warnings
        -: 9716:	 * more difficult.
        -: 9717:	 */
        3: 9718:	--num_rules;
        3: 9719:	++num_eof_rules;
        3: 9720:	}
        -: 9721:
        -: 9722:
        -: 9723:/* format_synerr - write out formatted syntax error */
        -: 9724:
    #####: 9725:void format_synerr( msg, arg )
        -: 9726:char msg[], arg[];
        -: 9727:	{
        -: 9728:	char errmsg[MAXLINE];
        -: 9729:
    #####: 9730:	(void) sprintf( errmsg, msg, arg );
    #####: 9731:	synerr( errmsg );
    #####: 9732:	}
        -: 9733:
        -: 9734:
        -: 9735:/* synerr - report a syntax error */
        -: 9736:
    #####: 9737:void synerr( str )
        -: 9738:char str[];
        -: 9739:	{
    #####: 9740:	syntaxerror = true;
    #####: 9741:	pinpoint_message( str );
    #####: 9742:	}
        -: 9743:
        -: 9744:
        -: 9745:/* warn - report a warning, unless -w was given */
        -: 9746:
    #####: 9747:void warn( str )
        -: 9748:char str[];
        -: 9749:	{
    #####: 9750:	line_warning( str, linenum );
    #####: 9751:	}
        -: 9752:
        -: 9753:/* format_pinpoint_message - write out a message formatted with one string,
        -: 9754: *			     pinpointing its location
        -: 9755: */
        -: 9756:
        1: 9757:void format_pinpoint_message( msg, arg )
        -: 9758:char msg[], arg[];
        -: 9759:	{
        -: 9760:	char errmsg[MAXLINE];
        -: 9761:
        1: 9762:	(void) sprintf( errmsg, msg, arg );
        1: 9763:	pinpoint_message( errmsg );
        1: 9764:	}
        -: 9765:
        -: 9766:
        -: 9767:/* pinpoint_message - write out a message, pinpointing its location */
        -: 9768:
        1: 9769:void pinpoint_message( str )
        -: 9770:char str[];
        -: 9771:	{
        1: 9772:	line_pinpoint( str, linenum );
        1: 9773:	}
        -: 9774:
        -: 9775:
        -: 9776:/* line_warning - report a warning at a given line, unless -w was given */
        -: 9777:
    #####: 9778:void line_warning( str, line )
        -: 9779:char str[];
        -: 9780:int line;
        -: 9781:	{
        -: 9782:	char warning[MAXLINE];
        -: 9783:
    #####: 9784:	if ( ! nowarn )
        -: 9785:		{
    #####: 9786:		sprintf( warning, "warning, %s", str );
    #####: 9787:		line_pinpoint( warning, line );
        -: 9788:		}
    #####: 9789:	}
        -: 9790:
        -: 9791:
        -: 9792:/* line_pinpoint - write out a message, pinpointing it at the given line */
        -: 9793:
        1: 9794:void line_pinpoint( str, line )
        -: 9795:char str[];
        -: 9796:int line;
        -: 9797:	{
        1: 9798:	fprintf( err, "\"%s\", line %d: %s\n", infilename, line, str );
        1: 9799:	}
        -: 9800:
        -: 9801:
        -: 9802:/* yyerror - eat up an error message from the parser;
        -: 9803: *	     currently, messages are ignore
        -: 9804: */
        -: 9805:
    #####: 9806:void yyerror( msg )
        -: 9807:char msg[];
        -: 9808:	{
    #####: 9809:	}
        -: 9810:/* A lexical scanner generated by flex */
        -: 9811:
        -: 9812:/* Scanner skeleton version:
        -: 9813: * $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $
        -: 9814: */
        -: 9815:
        -: 9816:#define FLEX_SCANNER
        -: 9817:
        -: 9818:#include <stdio.h>
        -: 9819:
        -: 9820:
        -: 9821:/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
        -: 9822:#ifdef c_plusplus
        -: 9823:#ifndef __cplusplus
        -: 9824:#define __cplusplus
        -: 9825:#endif
        -: 9826:#endif
        -: 9827:
        -: 9828:
        -: 9829:#ifdef __cplusplus
        -: 9830:
        -: 9831:#include <stdlib.h>
        -: 9832:#include <unistd.h>
        -: 9833:
        -: 9834:/* Use prototypes in function declarations. */
        -: 9835:#define YY_USE_PROTOS
        -: 9836:
        -: 9837:/* The "const" storage-class-modifier is valid. */
        -: 9838:#define YY_USE_CONST
        -: 9839:
        -: 9840:#else	/* ! __cplusplus */
        -: 9841:
        -: 9842:#ifdef __STDC__
        -: 9843:
        -: 9844:#define YY_USE_PROTOS
        -: 9845:#define YY_USE_CONST
        -: 9846:
        -: 9847:#endif	/* __STDC__ */
        -: 9848:#endif	/* ! __cplusplus */
        -: 9849:
        -: 9850:
        -: 9851:#ifdef __TURBOC__
        -: 9852:#define YY_USE_CONST
        -: 9853:#endif
        -: 9854:
        -: 9855:
        -: 9856:#ifndef YY_USE_CONST
        -: 9857:#ifndef const
        -: 9858:#define const
        -: 9859:#endif
        -: 9860:#endif
        -: 9861:
        -: 9862:
        -: 9863:#if 0  // Moved to flexdef.h
        -: 9864:#ifdef YY_USE_PROTOS
        -: 9865:#define YY_PROTO(proto) proto
        -: 9866:#else
        -: 9867:#define YY_PROTO(proto) ()
        -: 9868:#endif
        -: 9869:#endif
        -: 9870:
        -: 9871:
        -: 9872:/* Returned upon end-of-file. */
        -: 9873:#define YY_NULL 0
        -: 9874:
        -: 9875:/* Promotes a possibly negative, possibly signed char to an unsigned
        -: 9876: * integer for use as an array index.  If the signed char is negative,
        -: 9877: * we want to instead treat it as an 8-bit unsigned char, hence the
        -: 9878: * double cast.
        -: 9879: */
        -: 9880:#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
        -: 9881:
        -: 9882:/* Enter a start condition.  This macro really ought to take a parameter,
        -: 9883: * but we do it the disgusting crufty way forced on us by the ()-less
        -: 9884: * definition of BEGIN.
        -: 9885: */
        -: 9886:#define BEGIN yy_start = 1 + 2 *
        -: 9887:
        -: 9888:/* Translate the current start state into a value that can be later handed
        -: 9889: * to BEGIN to return to the state.
        -: 9890: */
        -: 9891:#define YY_START ((yy_start - 1) / 2)
        -: 9892:
        -: 9893:/* Action number for EOF rule of a given start state. */
        -: 9894:#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
        -: 9895:
        -: 9896:/* Special action meaning "start processing a new file".  Now included
        -: 9897: * only for backward compatibility with previous versions of flex.
        -: 9898: */
        -: 9899:#define YY_NEW_FILE yyrestart( yyin )
        -: 9900:
        -: 9901:#define YY_END_OF_BUFFER_CHAR 0
        -: 9902:
        -: 9903:/* Size of default input buffer. */
        -: 9904:#define YY_BUF_SIZE 16384
        -: 9905:
        -: 9906:typedef struct yy_buffer_state *YY_BUFFER_STATE;
        -: 9907:
        -: 9908:extern int yyleng;
        -: 9909:extern FILE *yyin, *yyout;
        -: 9910:
        -: 9911:#ifdef __cplusplus
        -: 9912:extern "C" {
        -: 9913:#endif
        -: 9914:	extern int yywrap YY_PROTO(( void ));
        -: 9915:#ifdef __cplusplus
        -: 9916:	}
        -: 9917:#endif
        -: 9918:
        -: 9919:#define EOB_ACT_CONTINUE_SCAN 0
        -: 9920:#define EOB_ACT_END_OF_FILE 1
        -: 9921:#define EOB_ACT_LAST_MATCH 2
        -: 9922:
        -: 9923:/* The funky do-while in the following #define is used to turn the definition
        -: 9924: * int a single C statement (which needs a semi-colon terminator).  This
        -: 9925: * avoids problems with code like:
        -: 9926: *
        -: 9927: * 	if ( condition_holds )
        -: 9928: *		yyless( 5 );
        -: 9929: *	else
        -: 9930: *		do_something_else();
        -: 9931: *
        -: 9932: * Prior to using the do-while the compiler would get upset at the
        -: 9933: * "else" because it interpreted the "if" statement as being all
        -: 9934: * done when it reached the ';' after the yyless() call.
        -: 9935: */
        -: 9936:
        -: 9937:/* Return all but the first 'n' matched characters back to the input stream. */
        -: 9938:
        -: 9939:#define yyless(n) \
        -: 9940:	do \
        -: 9941:		{ \
        -: 9942:		/* Undo effects of setting up yytext. */ \
        -: 9943:		*yy_cp = yy_hold_char; \
        -: 9944:		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
        -: 9945:		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
        -: 9946:		} \
        -: 9947:	while ( 0 )
        -: 9948:
        -: 9949:#define unput(c) yyunput( c, yytext_ptr )
        -: 9950:
        -: 9951:
        -: 9952:struct yy_buffer_state
        -: 9953:	{
        -: 9954:	FILE *yy_input_file;
        -: 9955:
        -: 9956:	char *yy_ch_buf;		/* input buffer */
        -: 9957:	char *yy_buf_pos;		/* current position in input buffer */
        -: 9958:
        -: 9959:	/* Size of input buffer in bytes, not including room for EOB
        -: 9960:	 * characters.
        -: 9961:	 */
        -: 9962:	int yy_buf_size;
        -: 9963:
        -: 9964:	/* Number of characters read into yy_ch_buf, not including EOB
        -: 9965:	 * characters.
        -: 9966:	 */
        -: 9967:	int yy_n_chars;
        -: 9968:
        -: 9969:	/* Whether this is an "interactive" input source; if so, and
        -: 9970:	 * if we're using stdio for input, then we want to use getc()
        -: 9971:	 * instead of fread(), to make sure we stop fetching input after
        -: 9972:	 * each newline.
        -: 9973:	 */
        -: 9974:	int yy_is_interactive;
        -: 9975:
        -: 9976:	/* Whether to try to fill the input buffer when we reach the
        -: 9977:	 * end of it.
        -: 9978:	 */
        -: 9979:	int yy_fill_buffer;
        -: 9980:
        -: 9981:	int yy_buffer_status;
        -: 9982:#define YY_BUFFER_NEW 0
        -: 9983:#define YY_BUFFER_NORMAL 1
        -: 9984:	/* When an EOF's been seen but there's still some text to process
        -: 9985:	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
        -: 9986:	 * shouldn't try reading from the input source any more.  We might
        -: 9987:	 * still have a bunch of tokens to match, though, because of
        -: 9988:	 * possible backing-up.
        -: 9989:	 *
        -: 9990:	 * When we actually see the EOF, we change the status to "new"
        -: 9991:	 * (via yyrestart()), so that the user can continue scanning by
        -: 9992:	 * just pointing yyin at a new input file.
        -: 9993:	 */
        -: 9994:#ifndef	F_HD_8
        -: 9995:#define YY_BUFFER_EOF_PENDING 2 
        -: 9996:#else
        -: 9997:#define YY_BUFFER_EOF_PENDING 1 
        -: 9998:#endif
        -: 9999:	};
        -:10000:
        -:10001:static YY_BUFFER_STATE yy_current_buffer = 0;
        -:10002:
        -:10003:/* We provide macros for accessing buffer states in case in the
        -:10004: * future we want to put the buffer states in a more general
        -:10005: * "scanner state".
        -:10006: */
        -:10007:#define YY_CURRENT_BUFFER yy_current_buffer
        -:10008:
        -:10009:
        -:10010:/* yy_hold_char holds the character lost when yytext is formed. */
        -:10011:static char yy_hold_char;
        -:10012:
        -:10013:static int yy_n_chars;		/* number of characters read into yy_ch_buf */
        -:10014:
        -:10015:
        -:10016:int yyleng;
        -:10017:
        -:10018:/* Points to current character in buffer. */
        -:10019:static char *yy_c_buf_p = (char *) 0;
        -:10020:static int yy_init = 1;		/* whether we need to initialize */
        -:10021:static int yy_start = 0;	/* start state number */
        -:10022:
        -:10023:/* Flag which is used to allow yywrap()'s to do buffer switches
        -:10024: * instead of setting up a fresh yyin.  A bit of a hack ...
        -:10025: */
        -:10026:static int yy_did_buffer_switch_on_eof;
        -:10027:
        -:10028:static void yyunput YY_PROTO(( int c, char *buf_ptr ));
        -:10029:void yyrestart YY_PROTO(( FILE *input_file ));
        -:10030:void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
        -:10031:void yy_load_buffer_state YY_PROTO(( void ));
        -:10032:YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
        -:10033:void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
        -:10034:void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
        -:10035:
        -:10036:static int yy_start_stack_ptr = 0;
        -:10037:static int yy_start_stack_depth = 0;
        -:10038:static int *yy_start_stack = 0;
        -:10039:static void yy_push_state YY_PROTO(( int new_state ));
        -:10040:static void yy_pop_state YY_PROTO(( void ));
        -:10041:static int yy_top_state YY_PROTO(( void ));
        -:10042:
        -:10043://static void *yy_flex_alloc YY_PROTO(( unsigned int ));
        -:10044:static void *yy_flex_realloc YY_PROTO(( void *, unsigned int ));
        -:10045:static void yy_flex_free YY_PROTO(( void * ));
        -:10046:
        -:10047:#define yy_new_buffer yy_create_buffer
        -:10048:
        -:10049:#define INITIAL 0
        -:10050:#define SECT2 1
        -:10051:#define SECT2PROLOG 2
        -:10052:#define SECT3 3
        -:10053:#define CODEBLOCK 4
        -:10054:#define PICKUPDEF 5
        -:10055:#define SC 6
        -:10056:#define CARETISBOL 7
        -:10057:#define NUM 8
        -:10058:#define QUOTE 9
        -:10059:#define FIRSTCCL 10
        -:10060:#define CCL 11
        -:10061:#define ACTION 12
        -:10062:#define RECOVER 13
        -:10063:#define BRACEERROR 14
        -:10064:#define C_COMMENT 15
        -:10065:#define ACTION_COMMENT 16
        -:10066:#define ACTION_STRING 17
        -:10067:#define PERCENT_BRACE_ACTION 18
        -:10068:#define USED_LIST 19
        -:10069:#define CODEBLOCK_2 20
        -:10070:typedef unsigned char YY_CHAR;
        -:10071:typedef int yy_state_type;
        -:10072:FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
        -:10073:extern char *yytext;
        -:10074:#define yytext_ptr yytext
        -:10075:
        -:10076:#ifndef yytext_ptr
        -:10077:static void yy_flex_strncpy YY_PROTO(( char *, const char *, int ));
        -:10078:#endif
        -:10079:
        -:10080:#ifdef __cplusplus
        -:10081:static int yyinput YY_PROTO(( void ));
        -:10082:#else
        -:10083:static int input YY_PROTO(( void ));
        -:10084:#endif
        -:10085:
        -:10086:static yy_state_type yy_get_previous_state YY_PROTO(( void ));
        -:10087:static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
        -:10088:static int yy_get_next_buffer YY_PROTO(( void ));
        -:10089:static void yy_fatal_error YY_PROTO(( const char msg[] ));
        -:10090:
        -:10091:/* Done after the current pattern has been matched and before the
        -:10092: * corresponding action - sets up yytext.
        -:10093: */
        -:10094:#define YY_DO_BEFORE_ACTION \
        -:10095:	yytext_ptr = yy_bp; \
        -:10096:	yyleng = yy_cp - yy_bp; \
        -:10097:	yy_hold_char = *yy_cp; \
        -:10098:	*yy_cp = '\0'; \
        -:10099:	yy_c_buf_p = yy_cp;
        -:10100:
        -:10101:#define YY_END_OF_BUFFER 113
        -:10102:static const short int yy_accept[408] =
        -:10103:    {   0,
        -:10104:        0,    0,    0,    0,   41,   41,  110,  110,    0,    0,
        -:10105:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:10106:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:10107:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:10108:        0,    0,  113,  111,    6,   17,  111,   15,    1,   16,
        -:10109:      111,  111,  111,   14,   60,   53,   54,   60,   47,   60,
        -:10110:       59,   60,   60,   60,   60,   44,   43,   60,   60,   45,
        -:10111:       46,   41,   42,   41,   40,   39,   40,   40,  110,  110,
        -:10112:       26,   27,   26,   26,   26,   26,   26,   26,   29,   28,
        -:10113:       30,   29,   65,   61,   62,   64,   66,   80,   81,   80,
        -:10114:
        -:10115:       78,   77,   79,   67,   69,   67,   68,   67,   72,   72,
        -:10116:       72,   74,   76,   74,   74,   74,   75,   92,   97,   92,
        -:10117:       96,   98,   98,   93,   93,   93,   90,   91,  111,   31,
        -:10118:      111,   83,  111,   82,   20,   22,   20,   21,  101,  102,
        -:10119:      101,  100,  103,  105,  103,  106,  107,   88,   88,   89,
        -:10120:       88,   88,   88,   88,   88,   88,   36,   33,   32,   36,
        -:10121:       36,   36,   88,    6,   17,    0,   17,   15,    1,   16,
        -:10122:        0,   16,   13,    7,    0,    0,    0,    3,    0,    4,
        -:10123:        0,    2,   14,   53,   54,    0,    0,    0,   54,   50,
        -:10124:       50,    0,    0,   57,    0,  108,  108,  108,   49,   48,
        -:10125:
        -:10126:       49,   44,   43,    0,   43,   56,   44,   41,   42,   40,
        -:10127:       39,   39,   37,   38,  110,  110,   26,   27,   26,   26,
        -:10128:       26,   26,   29,   28,   30,   63,   64,   81,   77,   69,
        -:10129:      109,  109,  109,   70,   71,   76,   73,   92,   97,    0,
        -:10130:       95,    0,   94,   93,   93,   93,    0,   31,    0,   31,
        -:10131:       31,   83,   20,   22,   18,  101,  102,  101,  102,  102,
        -:10132:       99,  103,  105,  104,   88,   88,   88,   89,   85,   88,
        -:10133:       88,   88,   36,   33,   32,   36,   36,   84,   13,    7,
        -:10134:        0,   12,    0,    0,    0,    0,    3,    0,    0,    4,
        -:10135:        0,    5,    0,   51,    0,   52,    0,    0,   57,    0,
        -:10136:
        -:10137:       57,   57,  108,  108,   49,   49,   58,   56,   37,   38,
        -:10138:       26,   26,   26,   23,   26,    0,  109,  109,   93,   93,
        -:10139:        0,   19,    0,   85,   85,   88,   88,   36,   36,   12,
        -:10140:        0,    0,    0,    3,    0,    0,    4,    5,    5,   52,
        -:10141:       52,    0,   57,   57,   57,   57,  108,   26,   26,   23,
        -:10142:       23,    0,  109,   93,   93,   19,   19,   88,   88,   36,
        -:10143:       36,    0,    0,    0,   10,    0,   57,   57,   57,   57,
        -:10144:       26,   26,   93,   93,   88,   88,   36,   36,    0,    0,
        -:10145:        0,    0,   57,   57,   24,   25,   86,   87,   86,   87,
        -:10146:       34,   35,    0,    9,    0,    0,   11,   55,    9,    9,
        -:10147:
        -:10148:        0,    0,    8,    0,    8,    8,    0
        -:10149:    } ;
        -:10150:
        -:10151:static const int yy_ec[256] =
        -:10152:    {   0,
        -:10153:        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        -:10154:        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        -:10155:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10156:        1,    2,    1,    5,    1,    6,    7,    1,    8,    9,
        -:10157:        9,   10,    9,   11,   12,    9,   13,   14,   14,   14,
        -:10158:       14,   14,   14,   14,   14,   14,   14,    1,    1,   15,
        -:10159:        1,   16,    9,    1,   22,   23,   24,   25,   26,   27,
        -:10160:       21,   21,   28,   29,   30,   21,   31,   32,   33,   34,
        -:10161:       21,   35,   36,   37,   38,   21,   21,   39,   40,   21,
        -:10162:       17,   18,   19,   20,   21,    1,   22,   23,   24,   25,
        -:10163:
        -:10164:       26,   27,   21,   21,   28,   29,   30,   21,   31,   32,
        -:10165:       33,   34,   21,   35,   36,   37,   38,   21,   21,   39,
        -:10166:       40,   21,   41,   42,   43,    1,    1,    1,    1,    1,
        -:10167:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10168:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10169:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10170:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10171:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10172:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10173:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10174:
        -:10175:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10176:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10177:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10178:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10179:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10180:        1,    1,    1,    1,    1
        -:10181:    } ;
        -:10182:
        -:10183:static const int yy_meta[44] =
        -:10184:    {   0,
        -:10185:        1,    2,    3,    1,    4,    1,    1,    5,    1,    6,
        -:10186:        1,    7,    5,    8,    1,    1,    1,    9,   10,    1,
        -:10187:       11,   12,   12,   12,   12,   12,   12,   11,   11,   11,
        -:10188:       11,   11,   11,   11,   11,   11,   13,   11,   11,   11,
        -:10189:        5,    1,   14
        -:10190:    } ;
        -:10191:
        -:10192:static const short int yy_base[470] =
        -:10193:    {   0,
        -:10194:        0,   43,   85,  126,   89,  102, 1611, 1610,  168, 1605,
        -:10195:      108,  111,  211,    0, 1591, 1590,  252,  254,  116,  119,
        -:10196:       98,  122,  144,  146,  297,    0,   93,  104,  338,  340,
        -:10197:      149,  151,  257,  266,  268,  274,  383,    0,  425,  428,
        -:10198:     1596, 1595, 1607, 1615,  278, 1602, 1602,    0,  281, 1600,
        -:10199:     1600,  462, 1592,    0, 1615,  431, 1597, 1597, 1615,  285,
        -:10200:     1615, 1584, 1580,  331,  503,  437, 1593, 1593,  110, 1580,
        -:10201:     1615,    0, 1590, 1590,    0, 1590, 1588,  221, 1587, 1615,
        -:10202:        0, 1585, 1585, 1615,    0, 1561, 1546, 1511,    0, 1551,
        -:10203:     1543, 1543, 1615, 1615, 1498,    0, 1615, 1615, 1500, 1487,
        -:10204:
        -:10205:     1615, 1463, 1615, 1615, 1466, 1460, 1615,  332, 1615,  333,
        -:10206:      126, 1615, 1411, 1398,    0,  334, 1615,    0, 1383, 1383,
        -:10207:     1615,  341, 1371,    0, 1354, 1336, 1615, 1615,  271, 1371,
        -:10208:      287, 1370, 1366, 1615,    0, 1362, 1349, 1331,  290, 1335,
        -:10209:      347, 1325,    0, 1323, 1310, 1615,    0,    0,  350, 1306,
        -:10210:     1287, 1246, 1615,    0, 1249, 1227,    0, 1264, 1261, 1255,
        -:10211:     1225, 1197, 1213,  351, 1213, 1213, 1615,    0,  358, 1198,
        -:10212:     1193, 1615,    0,    0,  443,  361,  447,    0,  342,    0,
        -:10213:      363, 1615,    0,  451, 1191, 1188, 1149,  365, 1615, 1615,
        -:10214:     1185, 1181, 1155, 1135,  423, 1615, 1125,    0,    0, 1615,
        -:10215:
        -:10216:      546,  588, 1121, 1108, 1615,    0, 1615,    0, 1615,    0,
        -:10217:        0, 1095,    0,    0, 1088, 1615,    0, 1615,    0, 1061,
        -:10218:     1041,  630,    0, 1069, 1615, 1615,    0, 1615,  838, 1615,
        -:10219:     1615,  837,    0, 1615, 1615, 1615, 1615,    0, 1615,  434,
        -:10220:     1615,    0, 1615,    0,  821,  817,  373,  843,  376, 1615,
        -:10221:      842, 1615,    0, 1615,  463,  467,  834,  471, 1615,  833,
        -:10222:     1615,    0, 1615, 1615,    0,  441,  793, 1615,  673,    0,
        -:10223:      805,  802,    0,  830, 1615,  795,  792, 1615,    0,    0,
        -:10224:      594,  818,  817,  597,  784,  790,    0,  775,  786,    0,
        -:10225:      473,  807,  478, 1615,  486,  806,  590,  776,  790,  588,
        -:10226:
        -:10227:      469,  703,  793,    0,    0,    0, 1615,    0,    0,    0,
        -:10228:      780,  772,    0,  800,  800,  730,  788,    0,  775,  767,
        -:10229:      600,  795,  602,    0,  773,  772,  764,  770,  762, 1615,
        -:10230:      610,  772,  751,    0,  740,  745,    0, 1615,  765, 1615,
        -:10231:      764,  740,  488,  803,  601,  817, 1615,  742,  730, 1615,
        -:10232:      760,  760, 1615,  738,  726, 1615,  756,  735,  723,  733,
        -:10233:      721,  714,  716,  726, 1615,  724,  602,  831,  715,  658,
        -:10234:      512,  473,  454,  459,  435,  438,  422,  430,  606,  410,
        -:10235:      357,  342,  338,  278,    0,    0,    0,    0,    0,    0,
        -:10236:        0,    0,  614,  255,  618,  131, 1615, 1615, 1615,  156,
        -:10237:
        -:10238:      620,  622,  153,  625, 1615,   95, 1615,  858,  872,  886,
        -:10239:      900,  914,  928,  942,  956,  970,  984,  998, 1012, 1026,
        -:10240:     1040, 1054, 1062, 1075, 1081, 1094, 1108, 1122, 1136, 1150,
        -:10241:     1164, 1178, 1186, 1199, 1207, 1220, 1234, 1248, 1262, 1272,
        -:10242:     1280, 1293, 1307, 1321, 1335, 1349, 1363, 1371, 1384, 1398,
        -:10243:     1412, 1416, 1419, 1432, 1446, 1460,  710, 1474, 1487, 1501,
        -:10244:     1515,  711, 1529, 1537, 1544,  712,  743, 1557, 1571
        -:10245:    } ;
        -:10246:
        -:10247:static const short int yy_def[470] =
        -:10248:    {   0,
        -:10249:      407,  407,  408,  408,  409,  410,  411,  411,  407,    9,
        -:10250:      412,  412,  407,   13,  413,  413,  414,  414,  415,  415,
        -:10251:      416,  416,  417,  417,  407,   25,  418,  418,  413,  413,
        -:10252:      419,  419,  420,  420,  421,  421,  407,   37,  422,  422,
        -:10253:       37,   37,  407,  407,  407,  407,  407,  423,  407,  407,
        -:10254:      407,  424,  407,  425,  407,  407,  407,  407,  407,  407,
        -:10255:      407,  407,  426,  427,  407,  407,  407,  407,  407,  407,
        -:10256:      407,  428,  407,  428,  429,  430,  429,  429,  431,  407,
        -:10257:      432,  407,  432,  407,  433,  433,  433,  432,  434,  407,
        -:10258:      407,  434,  407,  407,  407,  435,  407,  407,  407,  407,
        -:10259:
        -:10260:      407,  407,  407,  407,  407,  407,  407,  427,  407,  436,
        -:10261:      437,  407,  407,  407,  438,  427,  407,  439,  407,  439,
        -:10262:      407,  440,  407,  441,  441,  441,  407,  407,  442,  407,
        -:10263:      442,  407,  407,  407,  443,  407,  443,  407,  444,  407,
        -:10264:      444,  407,  445,  407,  445,  407,  446,  447,  447,  407,
        -:10265:      447,  447,  407,  448,  448,  448,  449,  407,  407,  449,
        -:10266:      449,  449,  447,  407,  407,  407,  407,  423,  407,  407,
        -:10267:      407,  407,  450,  451,  407,  407,  407,  452,  407,  453,
        -:10268:      454,  407,  425,  407,  407,  407,  407,  455,  407,  407,
        -:10269:      407,  407,  407,  456,  426,  407,  407,  457,  458,  407,
        -:10270:
        -:10271:      407,  407,  407,  407,  407,  459,  407,  428,  407,  429,
        -:10272:      430,  430,  460,  461,  431,  407,  432,  407,  433,  433,
        -:10273:      433,  407,  434,  407,  407,  407,  435,  407,  407,  407,
        -:10274:      407,  407,  462,  407,  407,  407,  407,  439,  407,  440,
        -:10275:      407,  440,  407,  441,  441,  441,  442,  407,  442,  407,
        -:10276:      407,  407,  443,  407,  463,  444,  407,  444,  407,  407,
        -:10277:      407,  445,  407,  407,  447,  447,  447,  407,  407,  448,
        -:10278:      448,  448,  449,  407,  407,  449,  449,  407,  450,  451,
        -:10279:      407,  407,  407,  407,  407,  407,  464,  407,  407,  465,
        -:10280:      454,  407,  454,  407,  455,  407,  455,  407,  456,  456,
        -:10281:
        -:10282:      456,  456,  407,  466,  458,  201,  407,  459,  460,  461,
        -:10283:      433,  433,  222,  407,  222,  222,  407,  467,  441,  441,
        -:10284:      463,  407,  463,  269,  269,  448,  448,  449,  449,  407,
        -:10285:      407,  407,  407,  464,  407,  407,  465,  407,  407,  407,
        -:10286:      407,  407,  456,  456,  456,  456,  407,  433,  433,  407,
        -:10287:      407,  316,  407,  441,  441,  407,  407,  448,  448,  449,
        -:10288:      449,  407,  407,  407,  407,  407,  456,  456,  456,  456,
        -:10289:      433,  433,  441,  441,  448,  448,  449,  449,  468,  407,
        -:10290:      407,  407,  456,  456,  433,  433,  441,  441,  448,  448,
        -:10291:      449,  449,  468,  407,  468,  407,  407,  407,  407,  407,
        -:10292:
        -:10293:      469,  469,  407,  469,  407,  407,    0,  407,  407,  407,
        -:10294:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10295:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10296:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10297:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10298:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10299:      407,  407,  407,  407,  407,  407,  407,  407,  407
        -:10300:    } ;
        -:10301:
        -:10302:static const short int yy_nxt[1659] =
        -:10303:    {   0,
        -:10304:       44,   45,   46,   47,   44,   44,   44,   44,   44,   44,
        -:10305:       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
        -:10306:       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
        -:10307:       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
        -:10308:       44,   44,   44,   44,   49,   50,   51,   44,   44,   52,
        -:10309:       44,   44,   44,   44,   44,   53,   44,   44,   44,   44,
        -:10310:       44,   44,   44,   54,   54,   54,   54,   54,   54,   54,
        -:10311:       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
        -:10312:       54,   54,   54,   44,   44,   44,   56,   57,   58,   59,
        -:10313:       60,   73,   74,   61,   61,  130,  131,   61,  405,   62,
        -:10314:
        -:10315:       44,   63,   64,   76,   73,   77,  130,  131,   78,   90,
        -:10316:       91,   92,   90,   91,   92,  110,  206,  111,  105,  106,
        -:10317:      107,  105,  106,  107,   44,   65,   61,   66,   67,   68,
        -:10318:       59,   60,   69,  108,   61,   61,  108,  235,   61,  110,
        -:10319:       70,  111,   63,   64,  235,   71,  113,  114,  113,  114,
        -:10320:      207,  136,  137,  136,  137,  115,  405,  115,  138,  399,
        -:10321:      138,  116,  117,  116,  117,  401,   65,   61,   81,   81,
        -:10322:       82,   83,   81,   81,   81,   81,   81,   84,   81,   81,
        -:10323:       81,   81,   81,   81,   81,   81,   81,   81,   85,   85,
        -:10324:       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
        -:10325:
        -:10326:       85,   85,   86,   85,   85,   85,   85,   87,   81,   81,
        -:10327:       81,   93,   93,   44,   93,   93,   93,   93,   93,   93,
        -:10328:       94,   94,   93,   93,   93,   93,   95,   93,   93,   93,
        -:10329:       93,   96,   96,   96,   96,   96,   96,   96,   96,   96,
        -:10330:       96,   96,   96,   96,   96,   96,   96,   96,   96,   96,
        -:10331:       96,   93,   93,   93,   99,  100,   99,  100,  399,  140,
        -:10332:      141,  213,  101,  214,  101,  102,  142,  102,  140,  141,
        -:10333:      144,  145,  146,  248,  249,  142,  144,  145,  146,  164,
        -:10334:      165,  166,  169,  170,  171,  147,  190,  191,  192,  251,
        -:10335:      249,  147,  257,  258,  103,  300,  103,  118,  118,  119,
        -:10336:
        -:10337:      120,  121,  118,  118,  122,  118,  118,  118,  118,  123,
        -:10338:      118,  118,  118,  118,  118,  118,  118,  124,  124,  124,
        -:10339:      124,  124,  124,  124,  124,  124,  124,  124,  124,  124,
        -:10340:      124,  125,  124,  124,  124,  124,  126,  127,  118,  128,
        -:10341:      132,  133,  132,  133,  197,  197,  232,  197,  241,  260,
        -:10342:      258,  266,  164,  165,  166,  300,  267,  398,  242,  169,
        -:10343:      170,  171,  281,  282,  283,  292,  293,  296,  297,  198,
        -:10344:      198,  233,  198,  288,  284,  248,  249,  289,  251,  249,
        -:10345:      134,  397,  134,  148,  149,  150,  151,  148,  148,  152,
        -:10346:      148,  148,  153,  148,  148,  148,  148,  148,  148,  148,
        -:10347:
        -:10348:      148,  148,  148,  154,  154,  154,  154,  154,  154,  154,
        -:10349:      154,  154,  154,  154,  154,  154,  154,  155,  154,  154,
        -:10350:      154,  154,  156,  148,  148,  148,  158,  159,  160,  158,
        -:10351:      159,  160,  184,  185,  186,  396,  301,  187,  202,  203,
        -:10352:      204,  241,  266,  187,  281,  282,  283,  267,  281,  282,
        -:10353:      283,  242,  184,  185,  186,  392,  284,  187,  391,  161,
        -:10354:      284,  302,  161,  390,  162,  322,  323,  162,  174,  257,
        -:10355:      258,  389,  188,  260,  258,  292,  293,  285,  188,  286,
        -:10356:      339,  293,  345,  175,  388,  176,  300,  176,  296,  297,
        -:10357:      387,  176,  188,  176,  176,  177,  176,  178,  386,  179,
        -:10358:
        -:10359:      180,  367,  181,  199,  199,  300,  199,  199,  199,  199,
        -:10360:      199,  199,  199,  199,  199,  199,  200,  199,  199,  199,
        -:10361:      199,  199,  199,  201,  201,  201,  201,  201,  201,  201,
        -:10362:      201,  201,  201,  201,  201,  201,  201,  201,  201,  201,
        -:10363:      201,  201,  201,  199,  199,  199,  305,  305,  385,  305,
        -:10364:      305,  305,  305,  305,  305,  305,  305,  306,  305,  306,
        -:10365:      305,  305,  305,  305,  305,  305,  306,  306,  306,  306,
        -:10366:      306,  306,  306,  306,  306,  306,  306,  306,  306,  306,
        -:10367:      306,  306,  306,  306,  306,  306,  305,  305,  307,  202,
        -:10368:      203,  204,  341,  297,  187,  281,  282,  283,  331,  282,
        -:10369:
        -:10370:      283,  343,  322,  323,  357,  323,  299,  284,  394,  395,
        -:10371:      284,  331,  282,  283,  369,  383,  394,  395,  300,  300,
        -:10372:      400,  395,  403,  404,  403,  404,  344,  406,  404,  188,
        -:10373:      313,  313,  314,  315,  313,  313,  313,  313,  313,  316,
        -:10374:      313,  313,  313,  313,  313,  313,  313,  313,  313,  313,
        -:10375:      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
        -:10376:      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
        -:10377:      313,  313,  313,  324,  324,  300,  324,  324,  324,  324,
        -:10378:      324,  324,  325,  324,  324,  324,  324,  324,  324,  324,
        -:10379:      324,  324,  324,  325,  325,  325,  325,  325,  325,  325,
        -:10380:
        -:10381:      325,  325,  325,  325,  325,  325,  325,  325,  325,  325,
        -:10382:      325,  325,  325,  324,  324,  324,  346,  304,  318,  347,
        -:10383:      300,  304,  318,  347,  346,  346,  346,  346,  346,  346,
        -:10384:      316,  316,  300,  352,  316,  316,  316,  316,  316,  382,
        -:10385:      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
        -:10386:      353,  381,  380,  379,  353,  378,  377,  376,  375,  356,
        -:10387:      374,  373,  351,  350,  372,  371,  366,  340,  338,  365,
        -:10388:      316,  316,  316,  325,  325,  364,  325,  325,  325,  325,
        -:10389:      325,  325,  363,  325,  325,  325,  325,  325,  325,  325,
        -:10390:      325,  325,  325,  362,  361,  360,  359,  358,  356,  355,
        -:10391:
        -:10392:      354,  231,  351,  350,  349,  348,  196,  300,  342,  340,
        -:10393:      338,  336,  335,  325,  325,  325,  368,  333,  332,  330,
        -:10394:      300,  330,  329,  328,  368,  368,  368,  368,  368,  368,
        -:10395:      370,  274,  327,  326,  300,  269,  259,  259,  370,  370,
        -:10396:      370,  370,  370,  370,  384,  250,  250,  320,  300,  319,
        -:10397:      317,  229,  384,  384,  384,  384,  384,  384,   55,   55,
        -:10398:       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
        -:10399:       55,   55,   72,   72,   72,   72,   72,   72,   72,   72,
        -:10400:       72,   72,   72,   72,   72,   72,   75,   75,   75,   75,
        -:10401:       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
        -:10402:
        -:10403:       79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
        -:10404:       79,   79,   79,   79,   89,   89,   89,   89,   89,   89,
        -:10405:       89,   89,   89,   89,   89,   89,   89,   89,   44,   44,
        -:10406:       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
        -:10407:       44,   44,   98,   98,   98,   98,   98,   98,   98,   98,
        -:10408:       98,   98,   98,   98,   98,   98,  104,  104,  104,  104,
        -:10409:      104,  104,  104,  104,  104,  104,  104,  104,  104,  104,
        -:10410:      109,  109,  109,  109,  109,  109,  109,  109,  109,  109,
        -:10411:      109,  109,  109,  109,  112,  112,  112,  112,  112,  112,
        -:10412:      112,  112,  112,  112,  112,  112,  112,  112,  129,  129,
        -:10413:
        -:10414:      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
        -:10415:      129,  129,  135,  135,  135,  135,  135,  135,  135,  135,
        -:10416:      135,  135,  135,  135,  135,  135,  139,  139,  139,  139,
        -:10417:      139,  139,  139,  139,  139,  139,  139,  139,  139,  139,
        -:10418:      143,  143,  143,  143,  143,  143,  143,  143,  143,  143,
        -:10419:      143,  143,  143,  143,  157,  157,  157,  157,  157,  157,
        -:10420:      157,  157,  157,  157,  157,  157,  157,  157,  168,  168,
        -:10421:      224,  312,  168,  168,  168,  173,  173,  173,  173,  173,
        -:10422:      173,  173,  173,  173,  173,  173,  173,  183,  183,  311,
        -:10423:      216,  183,  183,  183,  194,  194,  212,  194,  194,  194,
        -:10424:
        -:10425:      194,  194,  194,  194,  194,  194,  194,  194,  196,  196,
        -:10426:      205,  196,  196,  196,  196,  196,  196,  196,  196,  196,
        -:10427:      196,  196,  208,  208,  205,  208,  208,  208,  208,  208,
        -:10428:      208,  208,  208,  208,  208,  208,  210,  210,  303,  210,
        -:10429:      210,  210,  210,  210,  210,  210,  210,  210,  210,  210,
        -:10430:      211,  211,  300,  211,  211,  211,  211,  211,  211,  211,
        -:10431:      211,  211,  211,  211,  215,  215,  215,  215,  215,  215,
        -:10432:      215,  215,  215,  215,  215,  215,  215,  215,  217,  217,
        -:10433:      298,  217,  217,  190,  217,  217,  217,  217,  190,  294,
        -:10434:      189,  217,  219,  219,  189,  172,  219,  219,  219,  223,
        -:10435:
        -:10436:      223,  172,  223,  223,  223,  223,  223,  223,  223,  223,
        -:10437:      223,  223,  223,  227,  227,  167,  167,  227,  227,  227,
        -:10438:      231,  231,  278,  231,  231,  231,  231,  231,  231,  231,
        -:10439:      231,  231,  231,  231,  234,  234,  277,  234,  234,  234,
        -:10440:      234,  234,  234,  234,  234,  234,  234,  234,  237,  237,
        -:10441:      276,  237,  237,  237,  237,  237,  237,  275,  237,  237,
        -:10442:      237,  237,  238,  238,  275,  274,  272,  238,  238,  238,
        -:10443:      238,  238,  240,  240,  271,  240,  240,  240,  240,  240,
        -:10444:      240,  240,  240,  240,  240,  240,  244,  244,  269,  268,
        -:10445:      244,  244,  244,  247,  247,  247,  247,  247,  247,  247,
        -:10446:
        -:10447:      247,  247,  247,  247,  247,  247,  247,  253,  253,  268,
        -:10448:      253,  253,  263,  253,  253,  253,  253,  253,  253,  253,
        -:10449:      253,  256,  256,  256,  256,  256,  263,  256,  256,  256,
        -:10450:      256,  256,  256,  256,  256,  262,  262,  261,  259,  262,
        -:10451:      262,  262,  262,  255,  262,  262,  262,  262,  262,  264,
        -:10452:      264,  254,  264,  264,  264,  264,  264,  264,  264,  264,
        -:10453:      264,  264,  264,  265,  265,  254,  265,  265,  252,  265,
        -:10454:      265,  265,  265,  252,  250,  246,  265,  270,  270,  245,
        -:10455:      243,  270,  270,  270,  273,  239,  239,  273,  273,  273,
        -:10456:      273,  273,  273,  273,  273,  273,  273,  273,  279,  279,
        -:10457:
        -:10458:      236,  279,  279,  279,  279,  279,  279,  279,  279,  279,
        -:10459:      279,  279,  280,  280,  236,  280,  280,  280,  280,  280,
        -:10460:      280,  280,  280,  280,  280,  280,  287,  287,  287,  290,
        -:10461:      290,  290,  291,  291,  291,  291,  291,  291,  291,  291,
        -:10462:      291,  291,  291,  291,  291,  291,  295,  295,  295,  295,
        -:10463:      295,  295,  295,  295,  295,  295,  295,  295,  295,  295,
        -:10464:      299,  299,  230,  299,  299,  299,  299,  299,  299,  230,
        -:10465:      299,  299,  299,  299,  305,  305,  229,  305,  305,  305,
        -:10466:      305,  305,  305,  305,  305,  305,  305,  308,  308,  228,
        -:10467:      308,  308,  308,  308,  308,  308,  308,  308,  308,  308,
        -:10468:
        -:10469:      308,  309,  309,  228,  309,  309,  309,  309,  309,  309,
        -:10470:      309,  309,  309,  309,  309,  310,  310,  226,  310,  310,
        -:10471:      310,  310,  310,  310,  310,  310,  310,  310,  310,  321,
        -:10472:      321,  321,  321,  321,  321,  321,  321,  321,  321,  321,
        -:10473:      321,  321,  321,  334,  334,  225,  225,  334,  334,  334,
        -:10474:      337,  337,  224,  222,  337,  337,  337,  393,  393,  393,
        -:10475:      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
        -:10476:      393,  402,  402,  402,  402,  402,  402,  402,  402,  402,
        -:10477:      402,  402,  402,  402,  402,  221,  220,  218,  218,  216,
        -:10478:      209,  212,  209,  209,  193,  205,  205,  195,  193,  189,
        -:10479:
        -:10480:      189,  182,  172,  172,  167,  167,  407,  163,  163,   97,
        -:10481:       97,   88,   80,   80,   43,  407,  407,  407,  407,  407,
        -:10482:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10483:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10484:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10485:      407,  407,  407,  407,  407,  407,  407,  407
        -:10486:    } ;
        -:10487:
        -:10488:static const short int yy_chk[1659] =
        -:10489:    {   0,
        -:10490:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10491:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10492:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10493:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:10494:        1,    1,    1,    2,    2,    2,    2,    2,    2,    2,
        -:10495:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:10496:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:10497:        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        -:10498:        2,    2,    2,    2,    2,    2,    3,    3,    3,    3,
        -:10499:        3,    5,    5,    3,    3,   27,   27,    3,  406,    3,
        -:10500:
        -:10501:       21,    3,    3,    6,    6,    6,   28,   28,    6,   11,
        -:10502:       11,   11,   12,   12,   12,   21,   69,   21,   19,   19,
        -:10503:       19,   20,   20,   20,   22,    3,    3,    4,    4,    4,
        -:10504:        4,    4,    4,   19,    4,    4,   20,  111,    4,   22,
        -:10505:        4,   22,    4,    4,  111,    4,   23,   23,   24,   24,
        -:10506:       69,   31,   31,   32,   32,   23,  403,   24,   31,  400,
        -:10507:       32,   23,   23,   24,   24,  396,    4,    4,    9,    9,
        -:10508:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:10509:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:10510:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:10511:
        -:10512:        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        -:10513:        9,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:10514:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:10515:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:10516:       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        -:10517:       13,   13,   13,   13,   17,   17,   18,   18,  394,   33,
        -:10518:       33,   78,   17,   78,   18,   17,   33,   18,   34,   34,
        -:10519:       35,   35,   35,  129,  129,   34,   36,   36,   36,   45,
        -:10520:       45,   45,   49,   49,   49,   35,   60,   60,   60,  131,
        -:10521:      131,   36,  139,  139,   17,  384,   18,   25,   25,   25,
        -:10522:
        -:10523:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:10524:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:10525:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:10526:       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
        -:10527:       29,   29,   30,   30,   64,  108,  110,  116,  122,  141,
        -:10528:      141,  149,  164,  164,  164,  383,  149,  382,  122,  169,
        -:10529:      169,  169,  176,  176,  176,  181,  181,  188,  188,   64,
        -:10530:      108,  110,  116,  179,  176,  247,  247,  179,  249,  249,
        -:10531:       29,  381,   30,   37,   37,   37,   37,   37,   37,   37,
        -:10532:       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
        -:10533:
        -:10534:       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
        -:10535:       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
        -:10536:       37,   37,   37,   37,   37,   37,   39,   39,   39,   40,
        -:10537:       40,   40,   56,   56,   56,  380,  195,   56,   66,   66,
        -:10538:       66,  240,  266,   66,  175,  175,  175,  266,  177,  177,
        -:10539:      177,  240,  184,  184,  184,  378,  175,  184,  377,   39,
        -:10540:      177,  195,   40,  376,   39,  255,  255,   40,   52,  256,
        -:10541:      256,  375,   56,  258,  258,  291,  291,  175,   66,  177,
        -:10542:      293,  293,  301,   52,  374,   52,  301,   52,  295,  295,
        -:10543:      373,   52,  184,   52,   52,   52,   52,   52,  372,   52,
        -:10544:
        -:10545:       52,  343,   52,   65,   65,  343,   65,   65,   65,   65,
        -:10546:       65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
        -:10547:       65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
        -:10548:       65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
        -:10549:       65,   65,   65,   65,   65,   65,  201,  201,  371,  201,
        -:10550:      201,  201,  201,  201,  201,  201,  201,  201,  201,  201,
        -:10551:      201,  201,  201,  201,  201,  201,  201,  201,  201,  201,
        -:10552:      201,  201,  201,  201,  201,  201,  201,  201,  201,  201,
        -:10553:      201,  201,  201,  201,  201,  201,  201,  201,  201,  202,
        -:10554:      202,  202,  297,  297,  202,  281,  281,  281,  284,  284,
        -:10555:
        -:10556:      284,  300,  321,  321,  323,  323,  300,  281,  379,  379,
        -:10557:      284,  331,  331,  331,  345,  367,  393,  393,  345,  367,
        -:10558:      395,  395,  401,  401,  402,  402,  300,  404,  404,  202,
        -:10559:      222,  222,  222,  222,  222,  222,  222,  222,  222,  222,
        -:10560:      222,  222,  222,  222,  222,  222,  222,  222,  222,  222,
        -:10561:      222,  222,  222,  222,  222,  222,  222,  222,  222,  222,
        -:10562:      222,  222,  222,  222,  222,  222,  222,  222,  222,  222,
        -:10563:      222,  222,  222,  269,  269,  370,  269,  269,  269,  269,
        -:10564:      269,  269,  269,  269,  269,  269,  269,  269,  269,  269,
        -:10565:      269,  269,  269,  269,  269,  269,  269,  269,  269,  269,
        -:10566:
        -:10567:      269,  269,  269,  269,  269,  269,  269,  269,  269,  269,
        -:10568:      269,  269,  269,  269,  269,  269,  302,  457,  462,  466,
        -:10569:      302,  457,  462,  466,  302,  302,  302,  302,  302,  302,
        -:10570:      316,  316,  369,  316,  316,  316,  316,  316,  316,  366,
        -:10571:      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
        -:10572:      467,  364,  363,  362,  467,  361,  360,  359,  358,  357,
        -:10573:      355,  354,  352,  351,  349,  348,  342,  341,  339,  336,
        -:10574:      316,  316,  316,  325,  325,  335,  325,  325,  325,  325,
        -:10575:      325,  325,  333,  325,  325,  325,  325,  325,  325,  325,
        -:10576:      325,  325,  325,  332,  329,  328,  327,  326,  322,  320,
        -:10577:
        -:10578:      319,  317,  315,  314,  312,  311,  303,  299,  298,  296,
        -:10579:      292,  289,  288,  325,  325,  325,  344,  286,  285,  283,
        -:10580:      344,  282,  277,  276,  344,  344,  344,  344,  344,  344,
        -:10581:      346,  274,  272,  271,  346,  267,  260,  257,  346,  346,
        -:10582:      346,  346,  346,  346,  368,  251,  248,  246,  368,  245,
        -:10583:      232,  229,  368,  368,  368,  368,  368,  368,  408,  408,
        -:10584:      408,  408,  408,  408,  408,  408,  408,  408,  408,  408,
        -:10585:      408,  408,  409,  409,  409,  409,  409,  409,  409,  409,
        -:10586:      409,  409,  409,  409,  409,  409,  410,  410,  410,  410,
        -:10587:      410,  410,  410,  410,  410,  410,  410,  410,  410,  410,
        -:10588:
        -:10589:      411,  411,  411,  411,  411,  411,  411,  411,  411,  411,
        -:10590:      411,  411,  411,  411,  412,  412,  412,  412,  412,  412,
        -:10591:      412,  412,  412,  412,  412,  412,  412,  412,  413,  413,
        -:10592:      413,  413,  413,  413,  413,  413,  413,  413,  413,  413,
        -:10593:      413,  413,  414,  414,  414,  414,  414,  414,  414,  414,
        -:10594:      414,  414,  414,  414,  414,  414,  415,  415,  415,  415,
        -:10595:      415,  415,  415,  415,  415,  415,  415,  415,  415,  415,
        -:10596:      416,  416,  416,  416,  416,  416,  416,  416,  416,  416,
        -:10597:      416,  416,  416,  416,  417,  417,  417,  417,  417,  417,
        -:10598:      417,  417,  417,  417,  417,  417,  417,  417,  418,  418,
        -:10599:
        -:10600:      418,  418,  418,  418,  418,  418,  418,  418,  418,  418,
        -:10601:      418,  418,  419,  419,  419,  419,  419,  419,  419,  419,
        -:10602:      419,  419,  419,  419,  419,  419,  420,  420,  420,  420,
        -:10603:      420,  420,  420,  420,  420,  420,  420,  420,  420,  420,
        -:10604:      421,  421,  421,  421,  421,  421,  421,  421,  421,  421,
        -:10605:      421,  421,  421,  421,  422,  422,  422,  422,  422,  422,
        -:10606:      422,  422,  422,  422,  422,  422,  422,  422,  423,  423,
        -:10607:      224,  221,  423,  423,  423,  424,  424,  424,  424,  424,
        -:10608:      424,  424,  424,  424,  424,  424,  424,  425,  425,  220,
        -:10609:      215,  425,  425,  425,  426,  426,  212,  426,  426,  426,
        -:10610:
        -:10611:      426,  426,  426,  426,  426,  426,  426,  426,  427,  427,
        -:10612:      204,  427,  427,  427,  427,  427,  427,  427,  427,  427,
        -:10613:      427,  427,  428,  428,  203,  428,  428,  428,  428,  428,
        -:10614:      428,  428,  428,  428,  428,  428,  429,  429,  197,  429,
        -:10615:      429,  429,  429,  429,  429,  429,  429,  429,  429,  429,
        -:10616:      430,  430,  194,  430,  430,  430,  430,  430,  430,  430,
        -:10617:      430,  430,  430,  430,  431,  431,  431,  431,  431,  431,
        -:10618:      431,  431,  431,  431,  431,  431,  431,  431,  432,  432,
        -:10619:      193,  432,  432,  192,  432,  432,  432,  432,  191,  187,
        -:10620:      186,  432,  433,  433,  185,  171,  433,  433,  433,  434,
        -:10621:
        -:10622:      434,  170,  434,  434,  434,  434,  434,  434,  434,  434,
        -:10623:      434,  434,  434,  435,  435,  166,  165,  435,  435,  435,
        -:10624:      436,  436,  163,  436,  436,  436,  436,  436,  436,  436,
        -:10625:      436,  436,  436,  436,  437,  437,  162,  437,  437,  437,
        -:10626:      437,  437,  437,  437,  437,  437,  437,  437,  438,  438,
        -:10627:      161,  438,  438,  438,  438,  438,  438,  160,  438,  438,
        -:10628:      438,  438,  439,  439,  159,  158,  156,  439,  439,  439,
        -:10629:      439,  439,  440,  440,  155,  440,  440,  440,  440,  440,
        -:10630:      440,  440,  440,  440,  440,  440,  441,  441,  152,  151,
        -:10631:      441,  441,  441,  442,  442,  442,  442,  442,  442,  442,
        -:10632:
        -:10633:      442,  442,  442,  442,  442,  442,  442,  443,  443,  150,
        -:10634:      443,  443,  145,  443,  443,  443,  443,  443,  443,  443,
        -:10635:      443,  444,  444,  444,  444,  444,  144,  444,  444,  444,
        -:10636:      444,  444,  444,  444,  444,  445,  445,  142,  140,  445,
        -:10637:      445,  445,  445,  138,  445,  445,  445,  445,  445,  446,
        -:10638:      446,  137,  446,  446,  446,  446,  446,  446,  446,  446,
        -:10639:      446,  446,  446,  447,  447,  136,  447,  447,  133,  447,
        -:10640:      447,  447,  447,  132,  130,  126,  447,  448,  448,  125,
        -:10641:      123,  448,  448,  448,  449,  120,  119,  449,  449,  449,
        -:10642:      449,  449,  449,  449,  449,  449,  449,  449,  450,  450,
        -:10643:
        -:10644:      114,  450,  450,  450,  450,  450,  450,  450,  450,  450,
        -:10645:      450,  450,  451,  451,  113,  451,  451,  451,  451,  451,
        -:10646:      451,  451,  451,  451,  451,  451,  452,  452,  452,  453,
        -:10647:      453,  453,  454,  454,  454,  454,  454,  454,  454,  454,
        -:10648:      454,  454,  454,  454,  454,  454,  455,  455,  455,  455,
        -:10649:      455,  455,  455,  455,  455,  455,  455,  455,  455,  455,
        -:10650:      456,  456,  106,  456,  456,  456,  456,  456,  456,  105,
        -:10651:      456,  456,  456,  456,  458,  458,  102,  458,  458,  458,
        -:10652:      458,  458,  458,  458,  458,  458,  458,  459,  459,  100,
        -:10653:      459,  459,  459,  459,  459,  459,  459,  459,  459,  459,
        -:10654:
        -:10655:      459,  460,  460,   99,  460,  460,  460,  460,  460,  460,
        -:10656:      460,  460,  460,  460,  460,  461,  461,   95,  461,  461,
        -:10657:      461,  461,  461,  461,  461,  461,  461,  461,  461,  463,
        -:10658:      463,  463,  463,  463,  463,  463,  463,  463,  463,  463,
        -:10659:      463,  463,  463,  464,  464,   92,   91,  464,  464,  464,
        -:10660:      465,  465,   90,   88,  465,  465,  465,  468,  468,  468,
        -:10661:      468,  468,  468,  468,  468,  468,  468,  468,  468,  468,
        -:10662:      468,  469,  469,  469,  469,  469,  469,  469,  469,  469,
        -:10663:      469,  469,  469,  469,  469,   87,   86,   83,   82,   79,
        -:10664:       77,   76,   74,   73,   70,   68,   67,   63,   62,   58,
        -:10665:
        -:10666:       57,   53,   51,   50,   47,   46,   43,   42,   41,   16,
        -:10667:       15,   10,    8,    7,  407,  407,  407,  407,  407,  407,
        -:10668:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10669:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10670:      407,  407,  407,  407,  407,  407,  407,  407,  407,  407,
        -:10671:      407,  407,  407,  407,  407,  407,  407,  407
        -:10672:    } ;
        -:10673:
        -:10674:static yy_state_type yy_last_accepting_state;
        -:10675:static char *yy_last_accepting_cpos;
        -:10676:
        -:10677:/* The intent behind this definition is that it'll catch
        -:10678: * any uses of REJECT which flex missed.
        -:10679: */
        -:10680:#define REJECT reject_used_but_not_detected
        -:10681:#define yymore() yymore_used_but_not_detected
        -:10682:#define YY_MORE_ADJ 0
        -:10683:char *yytext;
        -:10684:/* scan.l - scanner for flex input */
        -:10685:/*-
        -:10686: * Copyright (c) 1990 The Regents of the University of California.
        -:10687: * All rights reserved.
        -:10688: *
        -:10689: * This code is derived from software contributed to Berkeley by
        -:10690: * Vern Paxson.
        -:10691: * 
        -:10692: * The United States Government has rights in this work pursuant
        -:10693: * to contract no. DE-AC03-76SF00098 between the United States
        -:10694: * Department of Energy and the University of California.
        -:10695: *
        -:10696: * Redistribution and use in source and binary forms are permitted provided
        -:10697: * that: (1) source distributions retain this entire copyright notice and
        -:10698: * comment, and (2) distributions including binaries display the following
        -:10699: * acknowledgement:  ``This product includes software developed by the
        -:10700: * University of California, Berkeley and its contributors'' in the
        -:10701: * documentation or other materials provided with the distribution and in
        -:10702: * all advertising materials mentioning features or use of this software.
        -:10703: * Neither the name of the University nor the names of its contributors may
        -:10704: * be used to endorse or promote products derived from this software without
        -:10705: * specific prior written permission.
        -:10706: * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
        -:10707: * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
        -:10708: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
        -:10709: */
        -:10710:
        -:10711:/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.seeded/v1/flex.c,v 1.1.1.2 2003/09/02 20:21:59 expsir Exp $ */
        -:10712:
        -:10713:
        -:10714:#define ACTION_ECHO add_action( yytext )
        -:10715:#define MARK_END_OF_PROLOG mark_prolog();
        -:10716:
        -:10717:#define YY_DECL \
        -:10718:	int flexscan()
        -:10719:
        -:10720:#define RETURNCHAR \
        -:10721:	yylval = (unsigned char) yytext[0]; \
        -:10722:	return CHAR;
        -:10723:
        -:10724:#define RETURNNAME \
        -:10725:	strcpy( nmstr, yytext ); \
        -:10726:	return NAME;
        -:10727:
        -:10728:#define PUT_BACK_STRING(str, start) \
        -:10729:	for ( i = strlen( str ) - 1; i >= start; --i ) \
        -:10730:		unput((str)[i])
        -:10731:
        -:10732:#define CHECK_REJECT(str) \
        -:10733:	if ( all_upper( str ) ) \
        -:10734:		reject = true;
        -:10735:
        -:10736:#define CHECK_YYMORE(str) \
        -:10737:	if ( all_lower( str ) ) \
        -:10738:		yymore_used = true;
        -:10739:
        -:10740:/* Macros after this point can all be overridden by user definitions in
        -:10741: * section 1.
        -:10742: */
        -:10743:
        -:10744:#ifdef YY_MALLOC_DECL
        -:10745:YY_MALLOC_DECL
        -:10746:#else
        -:10747:#if __STDC__
        -:10748:#ifndef __cplusplus
        -:10749:#include <stdlib.h>
        -:10750:#endif
        -:10751:#else
        -:10752:/* Just try to get by without declaring the routines.  This will fail
        -:10753: * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
        -:10754: * or sizeof(void*) != sizeof(int).
        -:10755: */
        -:10756:#endif
        -:10757:#endif
        -:10758:
        -:10759:/* Amount of stuff to slurp up with each read. */
        -:10760:#ifndef YY_READ_BUF_SIZE
        -:10761:#define YY_READ_BUF_SIZE 8192
        -:10762:#endif
        -:10763:
        -:10764:/* Copy whatever the last rule matched to the standard output. */
        -:10765:
        -:10766:#ifndef ECHO
        -:10767:/* This used to be an fputs(), but since the string might contain NUL's,
        -:10768: * we now use fwrite().
        -:10769: */
        -:10770:#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
        -:10771:#endif
        -:10772:
        -:10773:/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
        -:10774: * is returned in "result".
        -:10775: */
        -:10776:#ifndef YY_INPUT
        -:10777:#define YY_INPUT(buf,result,max_size) \
        -:10778:	if ( yy_current_buffer->yy_is_interactive ) \
        -:10779:		{ \
        -:10780:		int c = getc( yyin ); \
        -:10781:		result = c == EOF ? 0 : 1; \
        -:10782:		buf[0] = (char) c; \
        -:10783:		} \
        -:10784:	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
        -:10785:		  && ferror( yyin ) ) \
        -:10786:		YY_FATAL_ERROR( "input in flex scanner failed" );
        -:10787:#endif
        -:10788:
        -:10789:/* No semi-colon after return; correct usage is to write "yyterminate();" -
        -:10790: * we don't want an extra ';' after the "return" because that will cause
        -:10791: * some compilers to complain about unreachable statements.
        -:10792: */
        -:10793:#ifndef yyterminate
        -:10794:#define yyterminate() return YY_NULL
        -:10795:#endif
        -:10796:
        -:10797:/* Number of entries by which start-condition stack grows. */
        -:10798:#ifndef YY_START_STACK_INCR
        -:10799:#define YY_START_STACK_INCR 25
        -:10800:#endif
        -:10801:
        -:10802:/* Report a fatal error. */
        -:10803:#ifndef YY_FATAL_ERROR
        -:10804:#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
        -:10805:#endif
        -:10806:
        -:10807:/* Default declaration of generated scanner - a define so the user can
        -:10808: * easily add parameters.
        -:10809: */
        -:10810:#ifndef YY_DECL
        -:10811:#define YY_DECL int yylex YY_PROTO(( void ))
        -:10812:#endif
        -:10813:
        -:10814:/* Code executed at the beginning of each rule, after yytext and yyleng
        -:10815: * have been set up.
        -:10816: */
        -:10817:#ifndef YY_USER_ACTION
        -:10818:#define YY_USER_ACTION
        -:10819:#endif
        -:10820:
        -:10821:/* Code executed at the end of each rule. */
        -:10822:#ifndef YY_BREAK
        -:10823:#define YY_BREAK break;
        -:10824:#endif
        -:10825:
       18:10826:YY_DECL
        -:10827:	{
        -:10828:	register yy_state_type yy_current_state;
        -:10829:	register char *yy_cp, *yy_bp;
        -:10830:	register int yy_act;
        -:10831:
        -:10832:
        -:10833:	static int bracelevel, didadef, indented_code, checking_used;
        -:10834:
       18:10835:	int doing_codeblock = false;
        -:10836:	int i;
        -:10837:	Char nmdef[MAXLINE], myesc();
        -:10838:
        -:10839:
        -:10840:
       18:10841:	if ( yy_init )
        -:10842:		{
        -:10843:#ifdef YY_USER_INIT
        -:10844:		YY_USER_INIT;
        -:10845:#endif
        -:10846:
        1:10847:		if ( ! yy_start )
        1:10848:			yy_start = 1;	/* first start state */
        -:10849:
        1:10850:		if ( ! yyin )
    #####:10851:			yyin = stdin;
        -:10852:
        1:10853:		if ( ! yyout )
        1:10854:			yyout = stdout;
        -:10855:
        1:10856:		if ( yy_current_buffer )
    #####:10857:			yy_init_buffer( yy_current_buffer, yyin );
        -:10858:		else
        1:10859:			yy_current_buffer =
        1:10860:				yy_create_buffer( yyin, YY_BUF_SIZE );
        -:10861:
        1:10862:		yy_load_buffer_state();
        -:10863:
        1:10864:		yy_init = 0;
        -:10865:		}
        -:10866:
        -:10867:	while ( 1 )		/* loops until end-of-file is reached */
        -:10868:		{
       86:10869:		yy_cp = yy_c_buf_p;
        -:10870:
        -:10871:		/* Support of yytext. */
       86:10872:		*yy_cp = yy_hold_char;
        -:10873:
        -:10874:		/* yy_bp points to the position in yy_ch_buf of the start of
        -:10875:		 * the current run.
        -:10876:		 */
       86:10877:		yy_bp = yy_cp;
        -:10878:
       86:10879:		yy_current_state = yy_start;
       86:10880:		if ( yy_bp[-1] == '\n' )
       19:10881:			++yy_current_state;
        -:10882:yy_match:
        -:10883:		do
        -:10884:			{
      324:10885:			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
      324:10886:			if ( yy_accept[yy_current_state] )
        -:10887:				{
      225:10888:				yy_last_accepting_state = yy_current_state;
      225:10889:				yy_last_accepting_cpos = yy_cp;
        -:10890:				}
      920:10891:			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        -:10892:				{
      272:10893:				yy_current_state = (int) yy_def[yy_current_state];
      272:10894:				if ( yy_current_state >= 408 )
      190:10895:					yy_c = yy_meta[(unsigned int) yy_c];
        -:10896:				}
      324:10897:			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
      324:10898:			++yy_cp;
        -:10899:			}
      324:10900:		while ( yy_base[yy_current_state] != 1615 );
        -:10901:
        -:10902:yy_find_action:
      159:10903:		yy_act = yy_accept[yy_current_state];
        -:10904:
      159:10905:		YY_DO_BEFORE_ACTION;
        -:10906:
        -:10907:
        -:10908:do_action:	/* This label is used only to access EOF actions. */
        -:10909:
        -:10910:
      160:10911:		switch ( yy_act )
        -:10912:	{ /* beginning of action switch */
        -:10913:			case 0: /* must back up */
        -:10914:			/* undo the effects of YY_DO_BEFORE_ACTION */
       71:10915:			*yy_cp = yy_hold_char;
       71:10916:			yy_cp = yy_last_accepting_cpos;
       71:10917:			yy_current_state = yy_last_accepting_state;
       71:10918:			goto yy_find_action;
        -:10919:
        -:10920:case 1:
        -:10921:YY_USER_ACTION
    #####:10922:indented_code = true; BEGIN(CODEBLOCK);
    #####:10923:	YY_BREAK
        -:10924:case 2:
        -:10925:YY_USER_ACTION
    #####:10926:ACTION_ECHO; BEGIN(C_COMMENT);
    #####:10927:	YY_BREAK
        -:10928:case 3:
        -:10929:YY_USER_ACTION
    #####:10930:return SCDECL;
        -:10931:	YY_BREAK
        -:10932:case 4:
        -:10933:YY_USER_ACTION
        1:10934:return XSCDECL;
        -:10935:	YY_BREAK
        -:10936:case 5:
        -:10937:YY_USER_ACTION
        -:10938:{
    #####:10939:			++linenum;
    #####:10940:			line_directive_out( (FILE *) 0 );
    #####:10941:			indented_code = false;
    #####:10942:			BEGIN(CODEBLOCK);
        -:10943:			}
    #####:10944:	YY_BREAK
        -:10945:case 6:
        -:10946:YY_USER_ACTION
        1:10947:return WHITESPACE;
        -:10948:	YY_BREAK
        -:10949:case 7:
        -:10950:YY_USER_ACTION
        -:10951:{
        1:10952:			sectnum = 2;
        1:10953:			bracelevel = 0;
        1:10954:			mark_defs1();
        1:10955:			line_directive_out( (FILE *) 0 );
        1:10956:			BEGIN(SECT2PROLOG);
        1:10957:			return SECTEND;
        -:10958:			}
        -:10959:	YY_BREAK
        -:10960:case 8:
        -:10961:YY_USER_ACTION
        -:10962:{
    #####:10963:			if ( lex_compat )
    #####:10964:				warn( "%pointer incompatible with -l option" );
        -:10965:			else
    #####:10966:				yytext_is_array = false;
    #####:10967:			++linenum;
        -:10968:			}
    #####:10969:	YY_BREAK
        -:10970:case 9:
        -:10971:YY_USER_ACTION
        -:10972:{
    #####:10973:			if ( C_plus_plus )
    #####:10974:				warn( "%array incompatible with -+ option" );
        -:10975:			else
    #####:10976:				yytext_is_array = true;
    #####:10977:			++linenum;
        -:10978:			}
    #####:10979:	YY_BREAK
        -:10980:case 10:
        -:10981:YY_USER_ACTION
        -:10982:{
    #####:10983:			warn( "%used/%unused have been deprecated" );
    #####:10984:			checking_used = REALLY_USED; BEGIN(USED_LIST);
        -:10985:			}
    #####:10986:	YY_BREAK
        -:10987:case 11:
        -:10988:YY_USER_ACTION
        -:10989:{
    #####:10990:			warn( "%used/%unused have been deprecated" );
    #####:10991:			checking_used = REALLY_NOT_USED; BEGIN(USED_LIST);
        -:10992:			}
    #####:10993:	YY_BREAK
        -:10994:case 12:
        -:10995:YY_USER_ACTION
    #####:10996:++linenum;	/* ignore */
    #####:10997:	YY_BREAK
        -:10998:case 13:
        -:10999:YY_USER_ACTION
    #####:11000:synerr( "unrecognized '%' directive" );
    #####:11001:	YY_BREAK
        -:11002:case 14:
        -:11003:YY_USER_ACTION
        -:11004:{
    #####:11005:			strcpy( nmstr, yytext );
    #####:11006:			didadef = false;
    #####:11007:			BEGIN(PICKUPDEF);
        -:11008:			}
    #####:11009:	YY_BREAK
        -:11010:case 15:
        -:11011:YY_USER_ACTION
        1:11012:RETURNNAME;
        -:11013:	YY_BREAK
        -:11014:case 16:
        -:11015:YY_USER_ACTION
    #####:11016:++linenum; /* allows blank lines in section 1 */
    #####:11017:	YY_BREAK
        -:11018:case 17:
        -:11019:YY_USER_ACTION
        1:11020:++linenum; return '\n';
        -:11021:	YY_BREAK
        -:11022:case 18:
        -:11023:YY_USER_ACTION
    #####:11024:ACTION_ECHO; BEGIN(INITIAL);
    #####:11025:	YY_BREAK
        -:11026:case 19:
        -:11027:YY_USER_ACTION
    #####:11028:++linenum; ACTION_ECHO; BEGIN(INITIAL);
    #####:11029:	YY_BREAK
        -:11030:case 20:
        -:11031:YY_USER_ACTION
    #####:11032:ACTION_ECHO;
    #####:11033:	YY_BREAK
        -:11034:case 21:
        -:11035:YY_USER_ACTION
    #####:11036:ACTION_ECHO;
    #####:11037:	YY_BREAK
        -:11038:case 22:
        -:11039:YY_USER_ACTION
    #####:11040:++linenum; ACTION_ECHO;
    #####:11041:	YY_BREAK
        -:11042:case 23:
        -:11043:YY_USER_ACTION
    #####:11044:++linenum; BEGIN(INITIAL);
    #####:11045:	YY_BREAK
        -:11046:case 24:
        -:11047:YY_USER_ACTION
    #####:11048:ACTION_ECHO; CHECK_REJECT(yytext);
    #####:11049:	YY_BREAK
        -:11050:case 25:
        -:11051:YY_USER_ACTION
    #####:11052:ACTION_ECHO; CHECK_YYMORE(yytext);
    #####:11053:	YY_BREAK
        -:11054:case 26:
        -:11055:YY_USER_ACTION
    #####:11056:ACTION_ECHO;
    #####:11057:	YY_BREAK
        -:11058:case 27:
        -:11059:YY_USER_ACTION
        -:11060:{
    #####:11061:			++linenum;
    #####:11062:			ACTION_ECHO;
    #####:11063:			if ( indented_code )
    #####:11064:				BEGIN(INITIAL);
        -:11065:			}
    #####:11066:	YY_BREAK
        -:11067:case 28:
        -:11068:YY_USER_ACTION
        -:11069:/* separates name and definition */
    #####:11070:	YY_BREAK
        -:11071:case 29:
        -:11072:YY_USER_ACTION
        -:11073:{
    #####:11074:			strcpy( (char *) nmdef, yytext );
        -:11075:
        -:11076:			/* Skip trailing whitespace. */
    #####:11077:			for ( i = strlen( (char *) nmdef ) - 1;
    #####:11078:			      i >= 0 && (nmdef[i] == ' ' || nmdef[i] == '\t');
    #####:11079:			      --i )
        -:11080:				;
        -:11081:
    #####:11082:			nmdef[i + 1] = '\0';
        -:11083:
    #####:11084:			ndinstal( nmstr, nmdef );
    #####:11085:			didadef = true;
        -:11086:			}
    #####:11087:	YY_BREAK
        -:11088:case 30:
        -:11089:YY_USER_ACTION
        -:11090:{
    #####:11091:			if ( ! didadef )
    #####:11092:				synerr( "incomplete name definition" );
    #####:11093:			BEGIN(INITIAL);
    #####:11094:			++linenum;
        -:11095:			}
    #####:11096:	YY_BREAK
        -:11097:case 31:
        -:11098:YY_USER_ACTION
    #####:11099:++linenum; BEGIN(INITIAL); RETURNNAME;
        -:11100:	YY_BREAK
        -:11101:case 32:
        -:11102:YY_USER_ACTION
    #####:11103:++linenum; BEGIN(INITIAL);
    #####:11104:	YY_BREAK
        -:11105:case 33:
        -:11106:YY_USER_ACTION
        -:11107:
    #####:11108:	YY_BREAK
        -:11109:case 34:
        -:11110:YY_USER_ACTION
        -:11111:{
    #####:11112:			if ( all_upper( yytext ) )
    #####:11113:				reject_really_used = checking_used;
        -:11114:			else
    #####:11115:				synerr(
        -:11116:				"unrecognized %used/%unused construct" );
        -:11117:			}
    #####:11118:	YY_BREAK
        -:11119:case 35:
        -:11120:YY_USER_ACTION
        -:11121:{
    #####:11122:			if ( all_lower( yytext ) )
    #####:11123:				yymore_really_used = checking_used;
        -:11124:			else
    #####:11125:				synerr(
        -:11126:				"unrecognized %used/%unused construct" );
        -:11127:			}
    #####:11128:	YY_BREAK
        -:11129:case 36:
        -:11130:YY_USER_ACTION
    #####:11131:synerr( "unrecognized %used/%unused construct" );
    #####:11132:	YY_BREAK
        -:11133:case 37:
        -:11134:YY_USER_ACTION
    #####:11135:++bracelevel; yyless( 2 );	/* eat only %{ */
    #####:11136:	YY_BREAK
        -:11137:case 38:
        -:11138:YY_USER_ACTION
    #####:11139:--bracelevel; yyless( 2 );	/* eat only %} */
    #####:11140:	YY_BREAK
        -:11141:case 39:
        -:11142:YY_USER_ACTION
    #####:11143:ACTION_ECHO;	/* indented code in prolog */
    #####:11144:	YY_BREAK
        -:11145:case 40:
        -:11146:YY_USER_ACTION
        -:11147:{	/* non-indented code */
        1:11148:			if ( bracelevel <= 0 )
        -:11149:				{ /* not in %{ ... %} */
        1:11150:				yyless( 0 );	/* put it all back */
        1:11151:				mark_prolog();
        1:11152:				BEGIN(SECT2);
        -:11153:				}
        -:11154:			else
    #####:11155:				ACTION_ECHO;
        -:11156:			}
        1:11157:	YY_BREAK
        -:11158:case 41:
        -:11159:YY_USER_ACTION
    #####:11160:ACTION_ECHO;
    #####:11161:	YY_BREAK
        -:11162:case 42:
        -:11163:YY_USER_ACTION
        2:11164:++linenum; ACTION_ECHO;
        2:11165:	YY_BREAK
        -:11166:case YY_STATE_EOF(SECT2PROLOG):
        -:11167:{
    #####:11168:			mark_prolog();
    #####:11169:			sectnum = 0;
    #####:11170:			yyterminate(); /* to stop the parser */
        -:11171:			}
        -:11172:	YY_BREAK
        -:11173:case 43:
        -:11174:YY_USER_ACTION
    #####:11175:++linenum; /* allow blank lines in section 2 */
    #####:11176:	YY_BREAK
        -:11177:case 44:
        -:11178:YY_USER_ACTION
        -:11179:{
    #####:11180:			indented_code = (yytext[0] != '%');
    #####:11181:			doing_codeblock = true;
    #####:11182:			bracelevel = 1;
        -:11183:
    #####:11184:			if ( indented_code )
    #####:11185:				ACTION_ECHO;
        -:11186:
    #####:11187:			BEGIN(CODEBLOCK_2);
        -:11188:			}
    #####:11189:	YY_BREAK
        -:11190:case 45:
        -:11191:YY_USER_ACTION
        2:11192:BEGIN(SC); return '<';
        -:11193:	YY_BREAK
        -:11194:case 46:
        -:11195:YY_USER_ACTION
    #####:11196:return '^';
        -:11197:	YY_BREAK
        -:11198:case 47:
        -:11199:YY_USER_ACTION
    #####:11200:BEGIN(QUOTE); return '"';
        -:11201:	YY_BREAK
        -:11202:case 48:
    #####:11203:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:11204:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:11205:YY_DO_BEFORE_ACTION; /* set up yytext again */
        -:11206:YY_USER_ACTION
    #####:11207:BEGIN(NUM); return '{';
        -:11208:	YY_BREAK
        -:11209:case 49:
        -:11210:YY_USER_ACTION
    #####:11211:BEGIN(BRACEERROR);
    #####:11212:	YY_BREAK
        -:11213:case 50:
    #####:11214:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:11215:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:11216:YY_DO_BEFORE_ACTION; /* set up yytext again */
        -:11217:YY_USER_ACTION
    #####:11218:return '$';
        -:11219:	YY_BREAK
        -:11220:case 51:
        -:11221:YY_USER_ACTION
        -:11222:{
    #####:11223:			bracelevel = 1;
    #####:11224:			BEGIN(PERCENT_BRACE_ACTION);
    #####:11225:			return '\n';
        -:11226:			}
        -:11227:	YY_BREAK
        -:11228:case 52:
        -:11229:YY_USER_ACTION
    #####:11230:continued_action = true; ++linenum; return '\n';
        -:11231:	YY_BREAK
        -:11232:case 53:
        -:11233:YY_USER_ACTION
        -:11234:{
        -:11235:			/* This rule is separate from the one below because
        -:11236:			 * otherwise we get variable trailing context, so
        -:11237:			 * we can't build the scanner using -{f,F}.
        -:11238:			 */
        3:11239:			bracelevel = 0;
        3:11240:			continued_action = false;
        3:11241:			BEGIN(ACTION);
        3:11242:			return '\n';
        -:11243:			}
        -:11244:	YY_BREAK
        -:11245:case 54:
        -:11246:YY_USER_ACTION
        -:11247:{
    #####:11248:			bracelevel = 0;
    #####:11249:			continued_action = false;
    #####:11250:			BEGIN(ACTION);
    #####:11251:			unput( '\n' );	/* so <ACTION> sees it */
    #####:11252:			return '\n';
        -:11253:			}
        -:11254:	YY_BREAK
        -:11255:case 55:
        -:11256:YY_USER_ACTION
        3:11257:return EOF_OP;
        -:11258:	YY_BREAK
        -:11259:case 56:
        -:11260:YY_USER_ACTION
        -:11261:{
    #####:11262:			sectnum = 3;
    #####:11263:			BEGIN(SECT3);
    #####:11264:			yyterminate(); /* to stop the parser */
        -:11265:			}
        -:11266:	YY_BREAK
        -:11267:case 57:
        -:11268:YY_USER_ACTION
        -:11269:{
        -:11270:			int cclval;
        -:11271:
    #####:11272:			strcpy( nmstr, yytext );
        -:11273:
        -:11274:			/* Check to see if we've already encountered this
        -:11275:			 * ccl.
        -:11276:			 */
    #####:11277:			if ( (cclval = ccllookup( (Char *) nmstr )) )
        -:11278:				{
    #####:11279:				if ( input() != ']' )
    #####:11280:					synerr( "bad character class" );
        -:11281:
    #####:11282:				yylval = cclval;
    #####:11283:				++cclreuse;
    #####:11284:				return PREVCCL;
        -:11285:				}
        -:11286:			else
        -:11287:				{
        -:11288:				/* We fudge a bit.  We know that this ccl will
        -:11289:				 * soon be numbered as lastccl + 1 by cclinit.
        -:11290:				 */
    #####:11291:				cclinstal( (Char *) nmstr, lastccl + 1 );
        -:11292:
        -:11293:				/* Push back everything but the leading bracket
        -:11294:				 * so the ccl can be rescanned.
        -:11295:				 */
    #####:11296:				yyless( 1 );
        -:11297:
    #####:11298:				BEGIN(FIRSTCCL);
    #####:11299:				return '[';
        -:11300:				}
        -:11301:			}
        -:11302:	YY_BREAK
        -:11303:case 58:
        -:11304:YY_USER_ACTION
        -:11305:{
        -:11306:			register Char *nmdefptr;
        -:11307:			Char *ndlookup();
        -:11308:
    #####:11309:			strcpy( nmstr, yytext + 1 );
    #####:11310:			nmstr[yyleng - 2] = '\0';  /* chop trailing brace */
        -:11311:
    #####:11312:			if ( ! (nmdefptr = ndlookup( nmstr )) )
    #####:11313:				format_synerr( "undefined definition {%s}",
        -:11314:						nmstr );
        -:11315:
        -:11316:			else
        -:11317:				{ /* push back name surrounded by ()'s */
    #####:11318:				int len = strlen( (char *) nmdefptr );
        -:11319:
    #####:11320:				if ( lex_compat || nmdefptr[0] == '^' ||
    #####:11321:				     (len > 0 && nmdefptr[len - 1] == '$') )
        -:11322:					{ /* don't use ()'s after all */
    #####:11323:					PUT_BACK_STRING((char *) nmdefptr, 0);
        -:11324:
    #####:11325:					if ( nmdefptr[0] == '^' )
    #####:11326:						BEGIN(CARETISBOL);
        -:11327:					}
        -:11328:
        -:11329:				else
        -:11330:					{
    #####:11331:					unput(')');
    #####:11332:					PUT_BACK_STRING((char *) nmdefptr, 0);
    #####:11333:					unput('(');
        -:11334:					}
        -:11335:				}
        -:11336:			}
    #####:11337:	YY_BREAK
        -:11338:case 59:
        -:11339:YY_USER_ACTION
    #####:11340:return (unsigned char) yytext[0];
        -:11341:	YY_BREAK
        -:11342:case 60:
        -:11343:YY_USER_ACTION
    #####:11344:RETURNCHAR;
        -:11345:	YY_BREAK
        -:11346:case 61:
        -:11347:YY_USER_ACTION
    #####:11348:return (unsigned char) yytext[0];
        -:11349:	YY_BREAK
        -:11350:case 62:
        -:11351:YY_USER_ACTION
        2:11352:BEGIN(SECT2); return '>';
        -:11353:	YY_BREAK
        -:11354:case 63:
    #####:11355:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:11356:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:11357:YY_DO_BEFORE_ACTION; /* set up yytext again */
        -:11358:YY_USER_ACTION
    #####:11359:BEGIN(CARETISBOL); return '>';
        -:11360:	YY_BREAK
        -:11361:case 64:
        -:11362:YY_USER_ACTION
        2:11363:RETURNNAME;
        -:11364:	YY_BREAK
        -:11365:case 65:
        -:11366:YY_USER_ACTION
        -:11367:{
    #####:11368:			format_synerr( "bad <start condition>: %s", yytext );
        -:11369:			}
    #####:11370:	YY_BREAK
        -:11371:case 66:
        -:11372:YY_USER_ACTION
    #####:11373:BEGIN(SECT2); return '^';
        -:11374:	YY_BREAK
        -:11375:case 67:
        -:11376:YY_USER_ACTION
    #####:11377:RETURNCHAR;
        -:11378:	YY_BREAK
        -:11379:case 68:
        -:11380:YY_USER_ACTION
    #####:11381:BEGIN(SECT2); return '"';
        -:11382:	YY_BREAK
        -:11383:case 69:
        -:11384:YY_USER_ACTION
        -:11385:{
    #####:11386:			synerr( "missing quote" );
    #####:11387:			BEGIN(SECT2);
    #####:11388:			++linenum;
    #####:11389:			return '"';
        -:11390:			}
        -:11391:	YY_BREAK
        -:11392:case 70:
    #####:11393:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:11394:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:11395:YY_DO_BEFORE_ACTION; /* set up yytext again */
        -:11396:YY_USER_ACTION
    #####:11397:BEGIN(CCL); return '^';
        -:11398:	YY_BREAK
        -:11399:case 71:
    #####:11400:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:11401:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:11402:YY_DO_BEFORE_ACTION; /* set up yytext again */
        -:11403:YY_USER_ACTION
    #####:11404:return '^';
        -:11405:	YY_BREAK
        -:11406:case 72:
        -:11407:YY_USER_ACTION
    #####:11408:BEGIN(CCL); RETURNCHAR;
        -:11409:	YY_BREAK
        -:11410:case 73:
    #####:11411:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
    #####:11412:yy_c_buf_p = yy_cp = yy_bp + 1;
    #####:11413:YY_DO_BEFORE_ACTION; /* set up yytext again */
        -:11414:YY_USER_ACTION
    #####:11415:return '-';
        -:11416:	YY_BREAK
        -:11417:case 74:
        -:11418:YY_USER_ACTION
    #####:11419:RETURNCHAR;
        -:11420:	YY_BREAK
        -:11421:case 75:
        -:11422:YY_USER_ACTION
    #####:11423:BEGIN(SECT2); return ']';
        -:11424:	YY_BREAK
        -:11425:case 76:
        -:11426:YY_USER_ACTION
        -:11427:{
    #####:11428:			synerr( "bad character class" );
    #####:11429:			BEGIN(SECT2);
    #####:11430:			return ']';
        -:11431:			}
        -:11432:	YY_BREAK
        -:11433:case 77:
        -:11434:YY_USER_ACTION
        -:11435:{
    #####:11436:			yylval = myctoi( yytext );
    #####:11437:			return NUMBER;
        -:11438:			}
        -:11439:	YY_BREAK
        -:11440:case 78:
        -:11441:YY_USER_ACTION
    #####:11442:return ',';
        -:11443:	YY_BREAK
        -:11444:case 79:
        -:11445:YY_USER_ACTION
    #####:11446:BEGIN(SECT2); return '}';
        -:11447:	YY_BREAK
        -:11448:case 80:
        -:11449:YY_USER_ACTION
        -:11450:{
    #####:11451:			synerr( "bad character inside {}'s" );
    #####:11452:			BEGIN(SECT2);
    #####:11453:			return '}';
        -:11454:			}
        -:11455:	YY_BREAK
        -:11456:case 81:
        -:11457:YY_USER_ACTION
        -:11458:{
    #####:11459:			synerr( "missing }" );
    #####:11460:			BEGIN(SECT2);
    #####:11461:			++linenum;
    #####:11462:			return '}';
        -:11463:			}
        -:11464:	YY_BREAK
        -:11465:case 82:
        -:11466:YY_USER_ACTION
    #####:11467:synerr( "bad name in {}'s" ); BEGIN(SECT2);
    #####:11468:	YY_BREAK
        -:11469:case 83:
        -:11470:YY_USER_ACTION
    #####:11471:synerr( "missing }" ); ++linenum; BEGIN(SECT2);
    #####:11472:	YY_BREAK
        -:11473:case 84:
        -:11474:YY_USER_ACTION
    #####:11475:ACTION_ECHO; BEGIN(ACTION_COMMENT);
    #####:11476:	YY_BREAK
        -:11477:case 85:
        -:11478:YY_USER_ACTION
    #####:11479:bracelevel = 0;
    #####:11480:	YY_BREAK
        -:11481:case 86:
        -:11482:YY_USER_ACTION
        -:11483:{
    #####:11484:			ACTION_ECHO;
    #####:11485:			CHECK_REJECT(yytext);
        -:11486:			}
    #####:11487:	YY_BREAK
        -:11488:case 87:
        -:11489:YY_USER_ACTION
        -:11490:{
    #####:11491:			ACTION_ECHO;
    #####:11492:			CHECK_YYMORE(yytext);
        -:11493:			}
    #####:11494:	YY_BREAK
        -:11495:case 88:
        -:11496:YY_USER_ACTION
    #####:11497:ACTION_ECHO;
    #####:11498:	YY_BREAK
        -:11499:case 89:
        -:11500:YY_USER_ACTION
        -:11501:{
    #####:11502:			++linenum;
    #####:11503:			ACTION_ECHO;
    #####:11504:			if ( bracelevel == 0 ||
    #####:11505:			     (doing_codeblock && indented_code) )
        -:11506:				{
    #####:11507:				if ( ! doing_codeblock )
    #####:11508:					add_action( "\tYY_BREAK\n" );
        -:11509:				
    #####:11510:				doing_codeblock = false;
    #####:11511:				BEGIN(SECT2);
        -:11512:				}
        -:11513:			}
    #####:11514:	YY_BREAK
        -:11515:	/* Reject and YYmore() are checked for above, in PERCENT_BRACE_ACTION */
        -:11516:case 90:
        -:11517:YY_USER_ACTION
        3:11518:ACTION_ECHO; ++bracelevel;
        3:11519:	YY_BREAK
        -:11520:case 91:
        -:11521:YY_USER_ACTION
        3:11522:ACTION_ECHO; --bracelevel;
        3:11523:	YY_BREAK
        -:11524:case 92:
        -:11525:YY_USER_ACTION
       24:11526:ACTION_ECHO;
       24:11527:	YY_BREAK
        -:11528:case 93:
        -:11529:YY_USER_ACTION
       11:11530:ACTION_ECHO;
       11:11531:	YY_BREAK
        -:11532:case 94:
        -:11533:YY_USER_ACTION
    #####:11534:ACTION_ECHO; BEGIN(ACTION_COMMENT);
    #####:11535:	YY_BREAK
        -:11536:case 95:
        -:11537:YY_USER_ACTION
    #####:11538:ACTION_ECHO; /* character constant */
    #####:11539:	YY_BREAK
        -:11540:case 96:
        -:11541:YY_USER_ACTION
        3:11542:ACTION_ECHO; BEGIN(ACTION_STRING);
        3:11543:	YY_BREAK
        -:11544:case 97:
        -:11545:YY_USER_ACTION
        -:11546:{
       14:11547:			++linenum;
       14:11548:			ACTION_ECHO;
       14:11549:			if ( bracelevel == 0 )
        -:11550:				{
        3:11551:				add_action( "\tYY_BREAK\n" );
        3:11552:				BEGIN(SECT2);
        -:11553:				}
        -:11554:			}
       14:11555:	YY_BREAK
        -:11556:case 98:
        -:11557:YY_USER_ACTION
    #####:11558:ACTION_ECHO;
    #####:11559:	YY_BREAK
        -:11560:case 99:
        -:11561:YY_USER_ACTION
        -:11562:{
    #####:11563:			ACTION_ECHO;
    #####:11564:			if ( doing_codeblock )
    #####:11565:				BEGIN(CODEBLOCK_2);
        -:11566:			else
    #####:11567:				BEGIN(ACTION);
        -:11568:			}
    #####:11569:	YY_BREAK
        -:11570:case 100:
        -:11571:YY_USER_ACTION
    #####:11572:ACTION_ECHO;
    #####:11573:	YY_BREAK
        -:11574:case 101:
        -:11575:YY_USER_ACTION
    #####:11576:ACTION_ECHO;
    #####:11577:	YY_BREAK
        -:11578:case 102:
        -:11579:YY_USER_ACTION
    #####:11580:++linenum; ACTION_ECHO;
    #####:11581:	YY_BREAK
        -:11582:case 103:
        -:11583:YY_USER_ACTION
        3:11584:ACTION_ECHO;
        3:11585:	YY_BREAK
        -:11586:case 104:
        -:11587:YY_USER_ACTION
        1:11588:ACTION_ECHO;
        1:11589:	YY_BREAK
        -:11590:case 105:
        -:11591:YY_USER_ACTION
    #####:11592:++linenum; ACTION_ECHO;
    #####:11593:	YY_BREAK
        -:11594:case 106:
        -:11595:YY_USER_ACTION
        3:11596:ACTION_ECHO; BEGIN(ACTION);
        3:11597:	YY_BREAK
        -:11598:case 107:
        -:11599:YY_USER_ACTION
    #####:11600:ACTION_ECHO;
    #####:11601:	YY_BREAK
        -:11602:case YY_STATE_EOF(ACTION):
        -:11603:case YY_STATE_EOF(ACTION_COMMENT):
        -:11604:case YY_STATE_EOF(ACTION_STRING):
        -:11605:{
    #####:11606:			synerr( "EOF encountered inside an action" );
    #####:11607:			yyterminate();
        -:11608:			}
        -:11609:	YY_BREAK
        -:11610:case 108:
        -:11611:YY_USER_ACTION
        -:11612:{
    #####:11613:			yylval = myesc( (Char *) yytext );
    #####:11614:			return CHAR;
        -:11615:			}
        -:11616:	YY_BREAK
        -:11617:case 109:
        -:11618:YY_USER_ACTION
        -:11619:{
    #####:11620:			yylval = myesc( (Char *) yytext );
    #####:11621:			BEGIN(CCL);
    #####:11622:			return CHAR;
        -:11623:			}
        -:11624:	YY_BREAK
        -:11625:case 110:
        -:11626:YY_USER_ACTION
    #####:11627:ECHO;
    #####:11628:	YY_BREAK
        -:11629:case YY_STATE_EOF(SECT3):
    #####:11630:sectnum = 0; yyterminate();
        -:11631:	YY_BREAK
        -:11632:case 111:
        -:11633:YY_USER_ACTION
    #####:11634:format_synerr( "bad character: %s", yytext );
    #####:11635:	YY_BREAK
        -:11636:case 112:
        -:11637:YY_USER_ACTION
    #####:11638:YY_FATAL_ERROR( "flex scanner jammed" );
    #####:11639:	YY_BREAK
        -:11640:case YY_STATE_EOF(INITIAL):
        -:11641:case YY_STATE_EOF(SECT2):
        -:11642:case YY_STATE_EOF(CODEBLOCK):
        -:11643:case YY_STATE_EOF(PICKUPDEF):
        -:11644:case YY_STATE_EOF(SC):
        -:11645:case YY_STATE_EOF(CARETISBOL):
        -:11646:case YY_STATE_EOF(NUM):
        -:11647:case YY_STATE_EOF(QUOTE):
        -:11648:case YY_STATE_EOF(FIRSTCCL):
        -:11649:case YY_STATE_EOF(CCL):
        -:11650:case YY_STATE_EOF(RECOVER):
        -:11651:case YY_STATE_EOF(BRACEERROR):
        -:11652:case YY_STATE_EOF(C_COMMENT):
        -:11653:case YY_STATE_EOF(PERCENT_BRACE_ACTION):
        -:11654:case YY_STATE_EOF(USED_LIST):
        -:11655:case YY_STATE_EOF(CODEBLOCK_2):
        1:11656:	yyterminate();
        -:11657:
        -:11658:	case YY_END_OF_BUFFER:
        -:11659:		{
        -:11660:		/* Amount of text matched not including the EOB char. */
        3:11661:		int yy_amount_of_matched_text = yy_cp - yytext_ptr - 1;
        -:11662:
        -:11663:		/* Undo the effects of YY_DO_BEFORE_ACTION. */
        3:11664:		*yy_cp = yy_hold_char;
        -:11665:
        3:11666:		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
        -:11667:			{
        -:11668:			/* We're scanning a new file or input source.  It's
        -:11669:			 * possible that this happened because the user
        -:11670:			 * just pointed yyin at a new source and called
        -:11671:			 * yylex().  If so, then we have to assure
        -:11672:			 * consistency between yy_current_buffer and our
        -:11673:			 * globals.  Here is the right place to do so, because
        -:11674:			 * this is the first action (other than possibly a
        -:11675:			 * back-up) that will match for the new input source.
        -:11676:			 */
        1:11677:			yy_n_chars = yy_current_buffer->yy_n_chars;
        1:11678:			yy_current_buffer->yy_input_file = yyin;
        1:11679:			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
        -:11680:			}
        -:11681:
        -:11682:		/* Note that here we test for yy_c_buf_p "<=" to the position
        -:11683:		 * of the first EOB in the buffer, since yy_c_buf_p will
        -:11684:		 * already have been incremented past the NUL character
        -:11685:		 * (since all states make transitions on EOB to the
        -:11686:		 * end-of-buffer state).  Contrast this with the test
        -:11687:		 * in input().
        -:11688:		 */
        3:11689:		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
        -:11690:			{ /* This was really a NUL. */
        -:11691:			yy_state_type yy_next_state;
        -:11692:
    #####:11693:			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
        -:11694:
    #####:11695:			yy_current_state = yy_get_previous_state();
        -:11696:
        -:11697:			/* Okay, we're now positioned to make the NUL
        -:11698:			 * transition.  We couldn't have
        -:11699:			 * yy_get_previous_state() go ahead and do it
        -:11700:			 * for us because it doesn't know how to deal
        -:11701:			 * with the possibility of jamming (and we don't
        -:11702:			 * want to build jamming into it because then it
        -:11703:			 * will run more slowly).
        -:11704:			 */
        -:11705:
    #####:11706:			yy_next_state = yy_try_NUL_trans( yy_current_state );
        -:11707:
    #####:11708:			yy_bp = yytext_ptr + YY_MORE_ADJ;
        -:11709:
    #####:11710:			if ( yy_next_state )
        -:11711:				{
        -:11712:				/* Consume the NUL. */
    #####:11713:				yy_cp = ++yy_c_buf_p;
    #####:11714:				yy_current_state = yy_next_state;
    #####:11715:				goto yy_match;
        -:11716:				}
        -:11717:
        -:11718:			else
        -:11719:				{
    #####:11720:							yy_cp = yy_c_buf_p;
    #####:11721:				goto yy_find_action;
        -:11722:				}
        -:11723:			}
        -:11724:
        3:11725:		else switch ( yy_get_next_buffer() )
        -:11726:			{
        -:11727:			case EOB_ACT_END_OF_FILE:
        -:11728:				{
        1:11729:				yy_did_buffer_switch_on_eof = 0;
        -:11730:
        1:11731:				if ( yywrap() )
        -:11732:					{
        -:11733:					/* Note: because we've taken care in
        -:11734:					 * yy_get_next_buffer() to have set up
        -:11735:					 * yytext, we can now set up
        -:11736:					 * yy_c_buf_p so that if some total
        -:11737:					 * hoser (like flex itself) wants to
        -:11738:					 * call the scanner after we return the
        -:11739:					 * YY_NULL, it'll still work - another
        -:11740:					 * YY_NULL will get returned.
        -:11741:					 */
        1:11742:					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
        -:11743:
        1:11744:					yy_act = YY_STATE_EOF(YY_START);
        1:11745:					goto do_action;
        -:11746:					}
        -:11747:
        -:11748:				else
        -:11749:					{
    #####:11750:					if ( ! yy_did_buffer_switch_on_eof )
    #####:11751:						YY_NEW_FILE;
        -:11752:					}
    #####:11753:				break;
        -:11754:				}
        -:11755:
        -:11756:			case EOB_ACT_CONTINUE_SCAN:
        1:11757:				yy_c_buf_p =
        1:11758:					yytext_ptr + yy_amount_of_matched_text;
        -:11759:
        1:11760:				yy_current_state = yy_get_previous_state();
        -:11761:
        1:11762:				yy_cp = yy_c_buf_p;
        1:11763:				yy_bp = yytext_ptr + YY_MORE_ADJ;
        1:11764:				goto yy_match;
        -:11765:
        -:11766:			case EOB_ACT_LAST_MATCH:
        1:11767:				yy_c_buf_p =
        1:11768:				&yy_current_buffer->yy_ch_buf[yy_n_chars];
        -:11769:
        1:11770:				yy_current_state = yy_get_previous_state();
        -:11771:
        1:11772:				yy_cp = yy_c_buf_p;
        1:11773:				yy_bp = yytext_ptr + YY_MORE_ADJ;
        1:11774:				goto yy_find_action;
        -:11775:			}
    #####:11776:		break;
        -:11777:		}
        -:11778:
        -:11779:	default:
    #####:11780:		YY_FATAL_ERROR(
        -:11781:			"fatal flex scanner internal error--no action found" );
        -:11782:	} /* end of action switch */
       68:11783:		} /* end of scanning one token */
        -:11784:	} /* end of yylex */
        -:11785:
        -:11786:
        -:11787:/* yy_get_next_buffer - try to read in a new buffer
        -:11788: *
        -:11789: * Returns a code representing an action:
        -:11790: *	EOB_ACT_LAST_MATCH -
        -:11791: *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
        -:11792: *	EOB_ACT_END_OF_FILE - end of file
        -:11793: */
        -:11794:
        3:11795:static int yy_get_next_buffer()
        -:11796:	{
        3:11797:	register char *dest = yy_current_buffer->yy_ch_buf;
        3:11798:	register char *source = yytext_ptr - 1; /* copy prev. char, too */
        -:11799:	register int number_to_move, i;
        -:11800:	int ret_val;
        -:11801:
        3:11802:	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
    #####:11803:		YY_FATAL_ERROR(
        -:11804:		"fatal flex scanner internal error--end of buffer missed" );
        -:11805:
        3:11806:	if ( yy_current_buffer->yy_fill_buffer == 0 )
        -:11807:		{ /* Don't try to fill the buffer, so this is an EOF. */
        -:11808:#ifndef F_AA_4
    #####:11809:		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
        -:11810:#else
        -:11811:		if ( yytext_ptr - yy_c_buf_p - YY_MORE_ADJ == 1 )
        -:11812:#endif
        -:11813:
        -:11814:			{
        -:11815:			/* We matched a singled characater, the EOB, so
        -:11816:			 * treat this as a final EOF.
        -:11817:			 */
    #####:11818:			return EOB_ACT_END_OF_FILE;
        -:11819:			}
        -:11820:
        -:11821:		else
        -:11822:			{
        -:11823:			/* We matched some text prior to the EOB, first
        -:11824:			 * process it.
        -:11825:			 */
    #####:11826:			return EOB_ACT_LAST_MATCH;
        -:11827:			}
        -:11828:		}
        -:11829:
        -:11830:	/* Try to read more data. */
        -:11831:
        -:11832:	/* First move last chars to start of buffer. */
        3:11833:	number_to_move = yy_c_buf_p - yytext_ptr;
        -:11834:
        7:11835:	for ( i = 0; i < number_to_move; ++i )
        4:11836:		*(dest++) = *(source++);
        -:11837:
        3:11838:	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
        -:11839:		/* don't do the read, it's not guaranteed to return an EOF,
        -:11840:		 * just force an EOF
        -:11841:		 */
        1:11842:		yy_n_chars = 0;
        -:11843:
        -:11844:	else
        -:11845:		{
        2:11846:		int num_to_read =
        2:11847:			yy_current_buffer->yy_buf_size - number_to_move - 1;
        -:11848:
        4:11849:		while ( num_to_read <= 0 )
        -:11850:			{ /* Not enough room in the buffer - grow it. */
        -:11851:#ifdef YY_USES_REJECT
        -:11852:			YY_FATAL_ERROR(
        -:11853:"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
        -:11854:#else
        -:11855:
        -:11856:			/* just a shorter name for the current buffer */
    #####:11857:			YY_BUFFER_STATE b = yy_current_buffer;
        -:11858:
    #####:11859:			int yy_c_buf_p_offset = yy_c_buf_p - b->yy_ch_buf;
        -:11860:
    #####:11861:			b->yy_buf_size *= 2;
    #####:11862:			b->yy_ch_buf = (char *)
    #####:11863:				yy_flex_realloc( (void *) b->yy_ch_buf,
        -:11864:						 b->yy_buf_size );
        -:11865:
    #####:11866:			if ( ! b->yy_ch_buf )
    #####:11867:				YY_FATAL_ERROR(
        -:11868:				"fatal error - scanner input buffer overflow" );
        -:11869:
    #####:11870:			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
        -:11871:
    #####:11872:			num_to_read = yy_current_buffer->yy_buf_size -
        -:11873:						number_to_move - 1;
        -:11874:#endif
        -:11875:			}
        -:11876:
        2:11877:		if ( num_to_read > YY_READ_BUF_SIZE )
        2:11878:			num_to_read = YY_READ_BUF_SIZE;
        -:11879:
        -:11880:		/* Read in more data. */
        2:11881:		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
        -:11882:			yy_n_chars, num_to_read );
        -:11883:		}
        -:11884:
        3:11885:	if ( yy_n_chars == 0 )
        -:11886:		{
        2:11887:		if ( number_to_move - YY_MORE_ADJ == 1 )
        -:11888:			{
        1:11889:			ret_val = EOB_ACT_END_OF_FILE;
        1:11890:			yyrestart( yyin );
        -:11891:			}
        -:11892:
        -:11893:		else
        -:11894:			{
        1:11895:			ret_val = EOB_ACT_LAST_MATCH;
        1:11896:			yy_current_buffer->yy_buffer_status =
        -:11897:				YY_BUFFER_EOF_PENDING;
        -:11898:			}
        -:11899:		}
        -:11900:
        -:11901:	else
        1:11902:		ret_val = EOB_ACT_CONTINUE_SCAN;
        -:11903:
        3:11904:	yy_n_chars += number_to_move;
        3:11905:	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        3:11906:	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
        -:11907:
        -:11908:	/* yytext begins at the second character in yy_ch_buf; the first
        -:11909:	 * character is the one which preceded it before reading in the latest
        -:11910:	 * buffer; it needs to be kept around in case it's a newline, so
        -:11911:	 * yy_get_previous_state() will have with '^' rules active.
        -:11912:	 */
        -:11913:
        3:11914:	yytext_ptr = &yy_current_buffer->yy_ch_buf[1];
        -:11915:
        3:11916:	return ret_val;
        -:11917:	}
        -:11918:
        -:11919:
        -:11920:/* yy_get_previous_state - get the state just before the EOB char was reached */
        -:11921:
        2:11922:static yy_state_type yy_get_previous_state()
        -:11923:	{
        -:11924:	register yy_state_type yy_current_state;
        -:11925:	register char *yy_cp;
        -:11926:
        2:11927:	register char *yy_bp = yytext_ptr;
        -:11928:
        2:11929:	yy_current_state = yy_start;
        2:11930:	if ( yy_bp[-1] == '\n' )
        1:11931:		++yy_current_state;
        -:11932:
        3:11933:	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
        -:11934:		{
        1:11935:		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
        1:11936:		if ( yy_accept[yy_current_state] )
        -:11937:			{
    #####:11938:			yy_last_accepting_state = yy_current_state;
    #####:11939:			yy_last_accepting_cpos = yy_cp;
        -:11940:			}
        2:11941:		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        -:11942:			{
    #####:11943:			yy_current_state = (int) yy_def[yy_current_state];
    #####:11944:			if ( yy_current_state >= 408 )
    #####:11945:				yy_c = yy_meta[(unsigned int) yy_c];
        -:11946:			}
        1:11947:		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        -:11948:		}
        -:11949:
        2:11950:	return yy_current_state;
        -:11951:	}
        -:11952:
        -:11953:
        -:11954:/* yy_try_NUL_trans - try to make a transition on the NUL character
        -:11955: *
        -:11956: * synopsis
        -:11957: *	next_state = yy_try_NUL_trans( current_state );
        -:11958: */
        -:11959:
        -:11960:#ifdef YY_USE_PROTOS
    #####:11961:static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
        -:11962:#else
        -:11963:static yy_state_type yy_try_NUL_trans( yy_current_state )
        -:11964:yy_state_type yy_current_state;
        -:11965:#endif
        -:11966:	{
        -:11967:	register int yy_is_jam;
    #####:11968:	register char *yy_cp = yy_c_buf_p;
        -:11969:
    #####:11970:	register YY_CHAR yy_c = 1;
    #####:11971:	if ( yy_accept[yy_current_state] )
        -:11972:		{
    #####:11973:		yy_last_accepting_state = yy_current_state;
    #####:11974:		yy_last_accepting_cpos = yy_cp;
        -:11975:		}
    #####:11976:	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        -:11977:		{
    #####:11978:		yy_current_state = (int) yy_def[yy_current_state];
    #####:11979:		if ( yy_current_state >= 408 )
    #####:11980:			yy_c = yy_meta[(unsigned int) yy_c];
        -:11981:		}
    #####:11982:	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
    #####:11983:	yy_is_jam = (yy_current_state == 407);
        -:11984:
    #####:11985:	return yy_is_jam ? 0 : yy_current_state;
        -:11986:	}
        -:11987:
        -:11988:
        -:11989:#ifdef YY_USE_PROTOS
    #####:11990:static void yyunput( int c, register char *yy_bp )
        -:11991:#else
        -:11992:static void yyunput( c, yy_bp )
        -:11993:int c;
        -:11994:register char *yy_bp;
        -:11995:#endif
        -:11996:	{
    #####:11997:	register char *yy_cp = yy_c_buf_p;
        -:11998:
        -:11999:	/* undo effects of setting up yytext */
    #####:12000:	*yy_cp = yy_hold_char;
        -:12001:
    #####:12002:	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
        -:12003:		{ /* need to shift things up to make room */
        -:12004:		/* +2 for EOB chars. */
    #####:12005:		register int number_to_move = yy_n_chars + 2;
    #####:12006:		register char *dest = &yy_current_buffer->yy_ch_buf[
    #####:12007:					yy_current_buffer->yy_buf_size + 2];
    #####:12008:		register char *source =
    #####:12009:				&yy_current_buffer->yy_ch_buf[number_to_move];
        -:12010:
    #####:12011:		while ( source > yy_current_buffer->yy_ch_buf )
    #####:12012:			*--dest = *--source;
        -:12013:
    #####:12014:		yy_cp += dest - source;
    #####:12015:		yy_bp += dest - source;
    #####:12016:		yy_n_chars = yy_current_buffer->yy_buf_size;
        -:12017:
    #####:12018:		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
    #####:12019:			YY_FATAL_ERROR( "flex scanner push-back overflow" );
        -:12020:		}
        -:12021:
    #####:12022:	if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
    #####:12023:		yy_cp[-2] = '\n';
        -:12024:
    #####:12025:	*--yy_cp = (char) c;
        -:12026:
        -:12027:
        -:12028:	/* Note: the formal parameter *must* be called "yy_bp" for this
        -:12029:	 * macro to now work correctly.
        -:12030:	 */
    #####:12031:	YY_DO_BEFORE_ACTION; /* set up yytext again */
    #####:12032:	}
        -:12033:
        -:12034:
        -:12035:#ifdef __cplusplus
        -:12036:static int yyinput()
        -:12037:#else
    #####:12038:static int input()
        -:12039:#endif
        -:12040:	{
        -:12041:	int c;
        -:12042:
    #####:12043:	*yy_c_buf_p = yy_hold_char;
        -:12044:
    #####:12045:	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
        -:12046:		{
        -:12047:		/* yy_c_buf_p now points to the character we want to return.
        -:12048:		 * If this occurs *before* the EOB characters, then it's a
        -:12049:		 * valid NUL; if not, then we've hit the end of the buffer.
        -:12050:		 */
    #####:12051:		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
        -:12052:			/* This was really a NUL. */
    #####:12053:			*yy_c_buf_p = '\0';
        -:12054:
        -:12055:		else
        -:12056:			{ /* need more input */
    #####:12057:			yytext_ptr = yy_c_buf_p;
    #####:12058:			++yy_c_buf_p;
        -:12059:
    #####:12060:			switch ( yy_get_next_buffer() )
        -:12061:				{
        -:12062:				case EOB_ACT_END_OF_FILE:
        -:12063:					{
    #####:12064:					if ( yywrap() )
        -:12065:						{
    #####:12066:						yy_c_buf_p =
        -:12067:						yytext_ptr + YY_MORE_ADJ;
    #####:12068:						return EOF;
        -:12069:						}
        -:12070:
    #####:12071:					YY_NEW_FILE;
        -:12072:#ifdef __cplusplus
        -:12073:					return yyinput();
        -:12074:#else
    #####:12075:					return input();
        -:12076:#endif
        -:12077:					}
        -:12078:
        -:12079:				case EOB_ACT_CONTINUE_SCAN:
    #####:12080:					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
    #####:12081:					break;
        -:12082:
        -:12083:				case EOB_ACT_LAST_MATCH:
        -:12084:#ifdef __cplusplus
        -:12085:					YY_FATAL_ERROR(
        -:12086:					"unexpected last match in yyinput()" );
        -:12087:#else
    #####:12088:					YY_FATAL_ERROR(
        -:12089:					"unexpected last match in input()" );
        -:12090:#endif
        -:12091:				}
        -:12092:			}
        -:12093:		}
        -:12094:
    #####:12095:	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
    #####:12096:	*yy_c_buf_p = '\0';	/* preserve yytext */
    #####:12097:	yy_hold_char = *++yy_c_buf_p;
        -:12098:
    #####:12099:	return c;
        -:12100:	}
        -:12101:
        -:12102:
        -:12103:#ifdef YY_USE_PROTOS
        1:12104:void yyrestart( FILE *input_file )
        -:12105:#else
        -:12106:void yyrestart( input_file )
        -:12107:FILE *input_file;
        -:12108:#endif
        -:12109:	{
        1:12110:	if ( ! yy_current_buffer )
    #####:12111:		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
        -:12112:
        1:12113:	yy_init_buffer( yy_current_buffer, input_file );
        1:12114:	yy_load_buffer_state();
        1:12115:	}
        -:12116:
        -:12117:
        -:12118:#ifdef YY_USE_PROTOS
    #####:12119:void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
        -:12120:#else
        -:12121:void yy_switch_to_buffer( new_buffer )
        -:12122:YY_BUFFER_STATE new_buffer;
        -:12123:#endif
        -:12124:	{
    #####:12125:	if ( yy_current_buffer == new_buffer )
    #####:12126:		return;
        -:12127:
    #####:12128:	if ( yy_current_buffer )
        -:12129:		{
        -:12130:		/* Flush out information for old buffer. */
    #####:12131:		*yy_c_buf_p = yy_hold_char;
    #####:12132:		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
    #####:12133:		yy_current_buffer->yy_n_chars = yy_n_chars;
        -:12134:		}
        -:12135:
    #####:12136:	yy_current_buffer = new_buffer;
    #####:12137:	yy_load_buffer_state();
        -:12138:
        -:12139:	/* We don't actually know whether we did this switch during
        -:12140:	 * EOF (yywrap()) processing, but the only time this flag
        -:12141:	 * is looked at is after yywrap() is called, so it's safe
        -:12142:	 * to go ahead and always set it.
        -:12143:	 */
    #####:12144:	yy_did_buffer_switch_on_eof = 1;
        -:12145:	}
        -:12146:
        -:12147:
        -:12148:#ifdef YY_USE_PROTOS
        2:12149:void yy_load_buffer_state( void )
        -:12150:#else
        -:12151:void yy_load_buffer_state()
        -:12152:#endif
        -:12153:	{
        2:12154:	yy_n_chars = yy_current_buffer->yy_n_chars;
        2:12155:	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
        2:12156:	yyin = yy_current_buffer->yy_input_file;
        2:12157:	yy_hold_char = *yy_c_buf_p;
        2:12158:	}
        -:12159:
        -:12160:
        -:12161:#ifdef YY_USE_PROTOS
        1:12162:YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
        -:12163:#else
        -:12164:YY_BUFFER_STATE yy_create_buffer( file, size )
        -:12165:FILE *file;
        -:12166:int size;
        -:12167:#endif
        -:12168:	{
        -:12169:	YY_BUFFER_STATE b;
        -:12170:
        1:12171:	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
        -:12172:
        1:12173:	if ( ! b )
    #####:12174:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
        -:12175:
        1:12176:	b->yy_buf_size = size;
        -:12177:
        -:12178:	/* yy_ch_buf has to be 2 characters longer than the size given because
        -:12179:	 * we need to put in 2 end-of-buffer characters.
        -:12180:	 */
        1:12181:	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
        -:12182:
        1:12183:	if ( ! b->yy_ch_buf )
    #####:12184:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
        -:12185:
        1:12186:	yy_init_buffer( b, file );
        -:12187:
        1:12188:	return b;
        -:12189:	}
        -:12190:
        -:12191:
        -:12192:#ifdef YY_USE_PROTOS
    #####:12193:void yy_delete_buffer( YY_BUFFER_STATE b )
        -:12194:#else
        -:12195:void yy_delete_buffer( b )
        -:12196:YY_BUFFER_STATE b;
        -:12197:#endif
        -:12198:	{
    #####:12199:	if ( b == yy_current_buffer )
    #####:12200:		yy_current_buffer = (YY_BUFFER_STATE) 0;
        -:12201:
    #####:12202:	yy_flex_free( (void *) b->yy_ch_buf );
    #####:12203:	yy_flex_free( (void *) b );
    #####:12204:	}
        -:12205:
        -:12206:
        -:12207:#ifdef YY_USE_PROTOS
        2:12208:void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
        -:12209:#else
        -:12210:void yy_init_buffer( b, file )
        -:12211:YY_BUFFER_STATE b;
        -:12212:FILE *file;
        -:12213:#endif
        -:12214:	{
        2:12215:	b->yy_input_file = file;
        -:12216:
        -:12217:	/* We put in the '\n' and start reading from [1] so that an
        -:12218:	 * initial match-at-newline will be true.
        -:12219:	 */
        -:12220:
        2:12221:	b->yy_ch_buf[0] = '\n';
        2:12222:	b->yy_n_chars = 1;
        -:12223:
        -:12224:	/* We always need two end-of-buffer characters.  The first causes
        -:12225:	 * a transition to the end-of-buffer state.  The second causes
        -:12226:	 * a jam in that state.
        -:12227:	 */
        2:12228:	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
        2:12229:	b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;
        -:12230:
        2:12231:	b->yy_buf_pos = &b->yy_ch_buf[1];
        -:12232:
        2:12233:	b->yy_is_interactive = file ? isatty( fileno(file) ) : 0;
        -:12234:
        2:12235:	b->yy_fill_buffer = 1;
        -:12236:
        2:12237:	b->yy_buffer_status = YY_BUFFER_NEW;
        2:12238:	}
        -:12239:
        -:12240:
        -:12241:#ifdef YY_USE_PROTOS
    #####:12242:static void yy_push_state( int new_state )
        -:12243:#else
        -:12244:static void yy_push_state( new_state )
        -:12245:int new_state;
        -:12246:#endif
        -:12247:	{
    #####:12248:	if ( yy_start_stack_ptr >= yy_start_stack_depth )
        -:12249:		{
        -:12250:		int new_size;
        -:12251:
    #####:12252:		yy_start_stack_depth += YY_START_STACK_INCR;
    #####:12253:		new_size = yy_start_stack_depth * sizeof( int );
        -:12254:
    #####:12255:		if ( ! yy_start_stack )
    #####:12256:			yy_start_stack = (int *) yy_flex_alloc( new_size );
        -:12257:
        -:12258:		else
    #####:12259:			yy_start_stack = (int *) yy_flex_realloc(
        -:12260:					(void *) yy_start_stack, new_size );
        -:12261:
    #####:12262:		if ( ! yy_start_stack )
    #####:12263:			YY_FATAL_ERROR(
        -:12264:			"out of memory expanding start-condition stack" );
        -:12265:		}
        -:12266:
    #####:12267:	yy_start_stack[yy_start_stack_ptr++] = YY_START;
        -:12268:
    #####:12269:	BEGIN(new_state);
    #####:12270:	}
        -:12271:
        -:12272:
    #####:12273:static void yy_pop_state()
        -:12274:	{
    #####:12275:	if ( --yy_start_stack_ptr < 0 )
    #####:12276:		YY_FATAL_ERROR( "start-condition stack underflow" );
        -:12277:
    #####:12278:	BEGIN(yy_start_stack[yy_start_stack_ptr]);
    #####:12279:	}
        -:12280:
        -:12281:
    #####:12282:static int yy_top_state()
        -:12283:	{
    #####:12284:	return yy_start_stack[yy_start_stack_ptr - 1];
        -:12285:	}
        -:12286:
        -:12287:
        -:12288:#ifdef YY_USE_PROTOS
    #####:12289:static void yy_fatal_error( const char msg[] )
        -:12290:#else
        -:12291:static void yy_fatal_error( msg )
        -:12292:char msg[];
        -:12293:#endif
        -:12294:	{
    #####:12295:	(void) fprintf( err, "%s\n", msg );
    #####:12296:	exit( 1 );
        -:12297:	}
        -:12298:
        -:12299:
        -:12300:
        -:12301:/* Redefine yyless() so it works in section 3 code. */
        -:12302:
        -:12303:#undef yyless
        -:12304:#define yyless(n) \
        -:12305:	do \
        -:12306:		{ \
        -:12307:		/* Undo effects of setting up yytext. */ \
        -:12308:		yytext[yyleng] = yy_hold_char; \
        -:12309:		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
        -:12310:		yy_hold_char = *yy_c_buf_p; \
        -:12311:		*yy_c_buf_p = '\0'; \
        -:12312:		yyleng = n; \
        -:12313:		} \
        -:12314:	while ( 0 )
        -:12315:
        -:12316:
        -:12317:/* Internal utility routines. */
        -:12318:
        -:12319:#ifndef yytext_ptr
        -:12320:#ifdef YY_USE_PROTOS
        -:12321:static void yy_flex_strncpy( char *s1, const char *s2, int n )
        -:12322:#else
        -:12323:static void yy_flex_strncpy( s1, s2, n )
        -:12324:char *s1;
        -:12325:const char *s2;
        -:12326:int n;
        -:12327:#endif
        -:12328:	{
        -:12329:	register int i;
        -:12330:	for ( i = 0; i < n; ++i )
        -:12331:		s1[i] = s2[i];
        -:12332:	}
        -:12333:#endif
        -:12334:
        -:12335:
        -:12336:#ifdef YY_USE_PROTOS
       50:12337:static void *yy_flex_alloc( unsigned int size )
        -:12338:#else
        -:12339:static void *yy_flex_alloc( size )
        -:12340:unsigned int size;
        -:12341:#endif
        -:12342:	{
       50:12343:	return (void *) malloc( size );
        -:12344:	}
        -:12345:
        -:12346:#ifdef YY_USE_PROTOS
    #####:12347:static void *yy_flex_realloc( void *ptr, unsigned int size )
        -:12348:#else
        -:12349:static void *yy_flex_realloc( ptr, size )
        -:12350:void *ptr;
        -:12351:unsigned int size;
        -:12352:#endif
        -:12353:	{
    #####:12354:	return (void *) realloc( ptr, size );
        -:12355:	}
        -:12356:
        -:12357:#ifdef YY_USE_PROTOS
        2:12358:static void yy_flex_free( void *ptr )
        -:12359:#else
        -:12360:static void yy_flex_free( ptr )
        -:12361:void *ptr;
        -:12362:#endif
        -:12363:	{
        2:12364:	free( ptr );
        2:12365:	}
        -:12366:
        -:12367:
        -:12368:
        1:12369:int yywrap()
        -:12370:	{
        1:12371:	if ( --num_input_files > 0 )
        -:12372:		{
    #####:12373:		set_input_file( *++input_files );
    #####:12374:		return 0;
        -:12375:		}
        -:12376:
        -:12377:	else
        1:12378:		return 1;
        -:12379:	}
        -:12380:
        -:12381:
        -:12382:/* set_input_file - open the given file (if NULL, stdin) for scanning */
        -:12383:
        1:12384:void set_input_file( file )
        -:12385:char *file;
        -:12386:	{
        1:12387:	if ( file )
        -:12388:		{
        1:12389:		infilename = file;
        1:12390:		yyin = fopen( infilename, "r" );
        -:12391:
        1:12392:		if ( yyin == NULL )
    #####:12393:			lerrsf( "can't open %s", file );
        -:12394:		}
        -:12395:
        -:12396:	else
        -:12397:		{
    #####:12398:		yyin = stdin;
    #####:12399:		infilename = "<stdin>";
        -:12400:		}
        1:12401:	}
        -:12402:
        -:12403:
        -:12404:/* Wrapper routines for accessing the scanner's malloc routines. */
        -:12405:
       48:12406:void *flex_alloc( size )
        -:12407:unsigned int size;
        -:12408:	{
       48:12409:	return yy_flex_alloc( size );
        -:12410:	}
        -:12411:
    #####:12412:void *flex_realloc( ptr, size )
        -:12413:void *ptr;
        -:12414:unsigned int size;
        -:12415:	{
    #####:12416:	return yy_flex_realloc( ptr, size );
        -:12417:	}
        -:12418:
        2:12419:void flex_free( ptr )
        -:12420:void *ptr;
        -:12421:	{
        2:12422:	yy_flex_free( ptr );
        2:12423:	}
