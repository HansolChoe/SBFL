        -:    0:Source:grammar.c
        -:    0:Graph:/home/workspace/libyara/grammar.gcno
        -:    0:Data:/home/workspace/libyara/grammar.gcda
        -:    0:Runs:6
        -:    0:Programs:6
        -:    1:/* A Bison parser, made by GNU Bison 3.0.4.  */
        -:    2:
        -:    3:/* Bison implementation for Yacc-like parsers in C
        -:    4:
        -:    5:   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
        -:    6:
        -:    7:   This program is free software: you can redistribute it and/or modify
        -:    8:   it under the terms of the GNU General Public License as published by
        -:    9:   the Free Software Foundation, either version 3 of the License, or
        -:   10:   (at your option) any later version.
        -:   11:
        -:   12:   This program is distributed in the hope that it will be useful,
        -:   13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   15:   GNU General Public License for more details.
        -:   16:
        -:   17:   You should have received a copy of the GNU General Public License
        -:   18:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   19:
        -:   20:/* As a special exception, you may create a larger work that contains
        -:   21:   part or all of the Bison parser skeleton and distribute that work
        -:   22:   under terms of your choice, so long as that work isn't itself a
        -:   23:   parser generator using the skeleton or a modified version thereof
        -:   24:   as a parser skeleton.  Alternatively, if you modify or redistribute
        -:   25:   the parser skeleton itself, you may (at your option) remove this
        -:   26:   special exception, which will cause the skeleton and the resulting
        -:   27:   Bison output files to be licensed under the GNU General Public
        -:   28:   License without this special exception.
        -:   29:
        -:   30:   This special exception was added by the Free Software Foundation in
        -:   31:   version 2.2 of Bison.  */
        -:   32:
        -:   33:/* C LALR(1) parser skeleton written by Richard Stallman, by
        -:   34:   simplifying the original so-called "semantic" parser.  */
        -:   35:
        -:   36:/* All symbols defined below should begin with yy or YY, to avoid
        -:   37:   infringing on user name space.  This should be done even for local
        -:   38:   variables, as they might otherwise be expanded by user macros.
        -:   39:   There are some unavoidable exceptions within include files to
        -:   40:   define necessary library symbols; they are noted "INFRINGES ON
        -:   41:   USER NAME SPACE" below.  */
        -:   42:
        -:   43:/* Identify Bison output.  */
        -:   44:#define YYBISON 1
        -:   45:
        -:   46:/* Bison version.  */
        -:   47:#define YYBISON_VERSION "3.0.4"
        -:   48:
        -:   49:/* Skeleton name.  */
        -:   50:#define YYSKELETON_NAME "yacc.c"
        -:   51:
        -:   52:/* Pure parsers.  */
        -:   53:#define YYPURE 1
        -:   54:
        -:   55:/* Push parsers.  */
        -:   56:#define YYPUSH 0
        -:   57:
        -:   58:/* Pull parsers.  */
        -:   59:#define YYPULL 1
        -:   60:
        -:   61:
        -:   62:/* Substitute the variable and function names.  */
        -:   63:#define yyparse         yara_yyparse
        -:   64:#define yylex           yara_yylex
        -:   65:#define yyerror         yara_yyerror
        -:   66:#define yydebug         yara_yydebug
        -:   67:#define yynerrs         yara_yynerrs
        -:   68:
        -:   69:
        -:   70:/* Copy the first part of user declarations.  */
        -:   71:#line 30 "grammar.y" /* yacc.c:339  */
        -:   72:
        -:   73:
        -:   74:
        -:   75:#include <assert.h>
        -:   76:#include <stdio.h>
        -:   77:#include <string.h>
        -:   78:#include <limits.h>
        -:   79:#include <stdbool.h>
        -:   80:#include <stdlib.h>
        -:   81:#include <stddef.h>
        -:   82:
        -:   83:#include <yara/integers.h>
        -:   84:#include <yara/utils.h>
        -:   85:#include <yara/strutils.h>
        -:   86:#include <yara/compiler.h>
        -:   87:#include <yara/object.h>
        -:   88:#include <yara/sizedstr.h>
        -:   89:#include <yara/exec.h>
        -:   90:#include <yara/error.h>
        -:   91:#include <yara/mem.h>
        -:   92:#include <yara/lexer.h>
        -:   93:#include <yara/parser.h>
        -:   94:
        -:   95:#if defined(_MSC_VER)
        -:   96:#define llabs _abs64
        -:   97:#endif
        -:   98:
        -:   99:#define YYERROR_VERBOSE
        -:  100:
        -:  101:#define YYMALLOC yr_malloc
        -:  102:#define YYFREE yr_free
        -:  103:
        -:  104:#define INTEGER_SET_ENUMERATION   1
        -:  105:#define INTEGER_SET_RANGE         2
        -:  106:
        -:  107:#define fail_if_error(e) \
        -:  108:    if (e != ERROR_SUCCESS) \
        -:  109:    { \
        -:  110:      compiler->last_error = e; \
        -:  111:      yyerror(yyscanner, compiler, NULL); \
        -:  112:      YYERROR; \
        -:  113:    } \
        -:  114:
        -:  115:
        -:  116:#define check_type_with_cleanup(expression, expected_type, op, cleanup) \
        -:  117:    if (((expression.type) & (expected_type)) == 0) \
        -:  118:    { \
        -:  119:      switch(expression.type) \
        -:  120:      { \
        -:  121:        case EXPRESSION_TYPE_INTEGER: \
        -:  122:          yr_compiler_set_error_extra_info( \
        -:  123:              compiler, "wrong type \"integer\" for " op " operator"); \
        -:  124:          break; \
        -:  125:        case EXPRESSION_TYPE_FLOAT: \
        -:  126:          yr_compiler_set_error_extra_info( \
        -:  127:              compiler, "wrong type \"float\" for " op " operator"); \
        -:  128:          break; \
        -:  129:        case EXPRESSION_TYPE_STRING: \
        -:  130:          yr_compiler_set_error_extra_info( \
        -:  131:              compiler, "wrong type \"string\" for " op " operator"); \
        -:  132:          break; \
        -:  133:        case EXPRESSION_TYPE_BOOLEAN: \
        -:  134:          yr_compiler_set_error_extra_info( \
        -:  135:              compiler, "wrong type \"boolean\" for " op " operator"); \
        -:  136:          break; \
        -:  137:      } \
        -:  138:      cleanup; \
        -:  139:      compiler->last_error = ERROR_WRONG_TYPE; \
        -:  140:      yyerror(yyscanner, compiler, NULL); \
        -:  141:      YYERROR; \
        -:  142:    }
        -:  143:
        -:  144:
        -:  145:#define check_type(expression, expected_type, op) \
        -:  146:    check_type_with_cleanup(expression, expected_type, op, )
        -:  147:
        -:  148:
        -:  149:#line 150 "grammar.c" /* yacc.c:339  */
        -:  150:
        -:  151:# ifndef YY_NULLPTR
        -:  152:#  if defined __cplusplus && 201103L <= __cplusplus
        -:  153:#   define YY_NULLPTR nullptr
        -:  154:#  else
        -:  155:#   define YY_NULLPTR 0
        -:  156:#  endif
        -:  157:# endif
        -:  158:
        -:  159:/* Enabling verbose error messages.  */
        -:  160:#ifdef YYERROR_VERBOSE
        -:  161:# undef YYERROR_VERBOSE
        -:  162:# define YYERROR_VERBOSE 1
        -:  163:#else
        -:  164:# define YYERROR_VERBOSE 0
        -:  165:#endif
        -:  166:
        -:  167:/* In a future release of Bison, this section will be replaced
        -:  168:   by #include "y.tab.h".  */
        -:  169:#ifndef YY_YARA_YY_GRAMMAR_H_INCLUDED
        -:  170:# define YY_YARA_YY_GRAMMAR_H_INCLUDED
        -:  171:/* Debug traces.  */
        -:  172:#ifndef YYDEBUG
        -:  173:# define YYDEBUG 0
        -:  174:#endif
        -:  175:#if YYDEBUG
        -:  176:extern int yara_yydebug;
        -:  177:#endif
        -:  178:
        -:  179:/* Token type.  */
        -:  180:#ifndef YYTOKENTYPE
        -:  181:# define YYTOKENTYPE
        -:  182:  enum yytokentype
        -:  183:  {
        -:  184:    _DOT_DOT_ = 258,
        -:  185:    _RULE_ = 259,
        -:  186:    _PRIVATE_ = 260,
        -:  187:    _GLOBAL_ = 261,
        -:  188:    _META_ = 262,
        -:  189:    _STRINGS_ = 263,
        -:  190:    _CONDITION_ = 264,
        -:  191:    _IDENTIFIER_ = 265,
        -:  192:    _STRING_IDENTIFIER_ = 266,
        -:  193:    _STRING_COUNT_ = 267,
        -:  194:    _STRING_OFFSET_ = 268,
        -:  195:    _STRING_LENGTH_ = 269,
        -:  196:    _STRING_IDENTIFIER_WITH_WILDCARD_ = 270,
        -:  197:    _NUMBER_ = 271,
        -:  198:    _DOUBLE_ = 272,
        -:  199:    _INTEGER_FUNCTION_ = 273,
        -:  200:    _TEXT_STRING_ = 274,
        -:  201:    _HEX_STRING_ = 275,
        -:  202:    _REGEXP_ = 276,
        -:  203:    _ASCII_ = 277,
        -:  204:    _WIDE_ = 278,
        -:  205:    _XOR_ = 279,
        -:  206:    _NOCASE_ = 280,
        -:  207:    _FULLWORD_ = 281,
        -:  208:    _AT_ = 282,
        -:  209:    _FILESIZE_ = 283,
        -:  210:    _ENTRYPOINT_ = 284,
        -:  211:    _ALL_ = 285,
        -:  212:    _ANY_ = 286,
        -:  213:    _IN_ = 287,
        -:  214:    _OF_ = 288,
        -:  215:    _FOR_ = 289,
        -:  216:    _THEM_ = 290,
        -:  217:    _MATCHES_ = 291,
        -:  218:    _CONTAINS_ = 292,
        -:  219:    _IMPORT_ = 293,
        -:  220:    _TRUE_ = 294,
        -:  221:    _FALSE_ = 295,
        -:  222:    _OR_ = 296,
        -:  223:    _AND_ = 297,
        -:  224:    _EQ_ = 298,
        -:  225:    _NEQ_ = 299,
        -:  226:    _LT_ = 300,
        -:  227:    _LE_ = 301,
        -:  228:    _GT_ = 302,
        -:  229:    _GE_ = 303,
        -:  230:    _SHIFT_LEFT_ = 304,
        -:  231:    _SHIFT_RIGHT_ = 305,
        -:  232:    _NOT_ = 306,
        -:  233:    UNARY_MINUS = 307
        -:  234:  };
        -:  235:#endif
        -:  236:/* Tokens.  */
        -:  237:#define _DOT_DOT_ 258
        -:  238:#define _RULE_ 259
        -:  239:#define _PRIVATE_ 260
        -:  240:#define _GLOBAL_ 261
        -:  241:#define _META_ 262
        -:  242:#define _STRINGS_ 263
        -:  243:#define _CONDITION_ 264
        -:  244:#define _IDENTIFIER_ 265
        -:  245:#define _STRING_IDENTIFIER_ 266
        -:  246:#define _STRING_COUNT_ 267
        -:  247:#define _STRING_OFFSET_ 268
        -:  248:#define _STRING_LENGTH_ 269
        -:  249:#define _STRING_IDENTIFIER_WITH_WILDCARD_ 270
        -:  250:#define _NUMBER_ 271
        -:  251:#define _DOUBLE_ 272
        -:  252:#define _INTEGER_FUNCTION_ 273
        -:  253:#define _TEXT_STRING_ 274
        -:  254:#define _HEX_STRING_ 275
        -:  255:#define _REGEXP_ 276
        -:  256:#define _ASCII_ 277
        -:  257:#define _WIDE_ 278
        -:  258:#define _XOR_ 279
        -:  259:#define _NOCASE_ 280
        -:  260:#define _FULLWORD_ 281
        -:  261:#define _AT_ 282
        -:  262:#define _FILESIZE_ 283
        -:  263:#define _ENTRYPOINT_ 284
        -:  264:#define _ALL_ 285
        -:  265:#define _ANY_ 286
        -:  266:#define _IN_ 287
        -:  267:#define _OF_ 288
        -:  268:#define _FOR_ 289
        -:  269:#define _THEM_ 290
        -:  270:#define _MATCHES_ 291
        -:  271:#define _CONTAINS_ 292
        -:  272:#define _IMPORT_ 293
        -:  273:#define _TRUE_ 294
        -:  274:#define _FALSE_ 295
        -:  275:#define _OR_ 296
        -:  276:#define _AND_ 297
        -:  277:#define _EQ_ 298
        -:  278:#define _NEQ_ 299
        -:  279:#define _LT_ 300
        -:  280:#define _LE_ 301
        -:  281:#define _GT_ 302
        -:  282:#define _GE_ 303
        -:  283:#define _SHIFT_LEFT_ 304
        -:  284:#define _SHIFT_RIGHT_ 305
        -:  285:#define _NOT_ 306
        -:  286:#define UNARY_MINUS 307
        -:  287:
        -:  288:/* Value type.  */
        -:  289:#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
        -:  290:
        -:  291:union YYSTYPE
        -:  292:{
        -:  293:#line 218 "grammar.y" /* yacc.c:355  */
        -:  294:
        -:  295:  EXPRESSION      expression;
        -:  296:  SIZED_STRING*   sized_string;
        -:  297:  char*           c_string;
        -:  298:  int64_t         integer;
        -:  299:  double          double_;
        -:  300:  YR_STRING*      string;
        -:  301:  YR_META*        meta;
        -:  302:  YR_RULE*        rule;
        -:  303:
        -:  304:#line 305 "grammar.c" /* yacc.c:355  */
        -:  305:};
        -:  306:
        -:  307:typedef union YYSTYPE YYSTYPE;
        -:  308:# define YYSTYPE_IS_TRIVIAL 1
        -:  309:# define YYSTYPE_IS_DECLARED 1
        -:  310:#endif
        -:  311:
        -:  312:
        -:  313:
        -:  314:int yara_yyparse (void *yyscanner, YR_COMPILER* compiler);
        -:  315:
        -:  316:#endif /* !YY_YARA_YY_GRAMMAR_H_INCLUDED  */
        -:  317:
        -:  318:/* Copy the second part of user declarations.  */
        -:  319:
        -:  320:#line 321 "grammar.c" /* yacc.c:358  */
        -:  321:
        -:  322:#ifdef short
        -:  323:# undef short
        -:  324:#endif
        -:  325:
        -:  326:#ifdef YYTYPE_UINT8
        -:  327:typedef YYTYPE_UINT8 yytype_uint8;
        -:  328:#else
        -:  329:typedef unsigned char yytype_uint8;
        -:  330:#endif
        -:  331:
        -:  332:#ifdef YYTYPE_INT8
        -:  333:typedef YYTYPE_INT8 yytype_int8;
        -:  334:#else
        -:  335:typedef signed char yytype_int8;
        -:  336:#endif
        -:  337:
        -:  338:#ifdef YYTYPE_UINT16
        -:  339:typedef YYTYPE_UINT16 yytype_uint16;
        -:  340:#else
        -:  341:typedef unsigned short int yytype_uint16;
        -:  342:#endif
        -:  343:
        -:  344:#ifdef YYTYPE_INT16
        -:  345:typedef YYTYPE_INT16 yytype_int16;
        -:  346:#else
        -:  347:typedef short int yytype_int16;
        -:  348:#endif
        -:  349:
        -:  350:#ifndef YYSIZE_T
        -:  351:# ifdef __SIZE_TYPE__
        -:  352:#  define YYSIZE_T __SIZE_TYPE__
        -:  353:# elif defined size_t
        -:  354:#  define YYSIZE_T size_t
        -:  355:# elif ! defined YYSIZE_T
        -:  356:#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  357:#  define YYSIZE_T size_t
        -:  358:# else
        -:  359:#  define YYSIZE_T unsigned int
        -:  360:# endif
        -:  361:#endif
        -:  362:
        -:  363:#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
        -:  364:
        -:  365:#ifndef YY_
        -:  366:# if defined YYENABLE_NLS && YYENABLE_NLS
        -:  367:#  if ENABLE_NLS
        -:  368:#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
        -:  369:#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
        -:  370:#  endif
        -:  371:# endif
        -:  372:# ifndef YY_
        -:  373:#  define YY_(Msgid) Msgid
        -:  374:# endif
        -:  375:#endif
        -:  376:
        -:  377:#ifndef YY_ATTRIBUTE
        -:  378:# if (defined __GNUC__                                               \
        -:  379:      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
        -:  380:     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
        -:  381:#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
        -:  382:# else
        -:  383:#  define YY_ATTRIBUTE(Spec) /* empty */
        -:  384:# endif
        -:  385:#endif
        -:  386:
        -:  387:#ifndef YY_ATTRIBUTE_PURE
        -:  388:# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
        -:  389:#endif
        -:  390:
        -:  391:#ifndef YY_ATTRIBUTE_UNUSED
        -:  392:# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
        -:  393:#endif
        -:  394:
        -:  395:#if !defined _Noreturn \
        -:  396:     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
        -:  397:# if defined _MSC_VER && 1200 <= _MSC_VER
        -:  398:#  define _Noreturn __declspec (noreturn)
        -:  399:# else
        -:  400:#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
        -:  401:# endif
        -:  402:#endif
        -:  403:
        -:  404:/* Suppress unused-variable warnings by "using" E.  */
        -:  405:#if ! defined lint || defined __GNUC__
        -:  406:# define YYUSE(E) ((void) (E))
        -:  407:#else
        -:  408:# define YYUSE(E) /* empty */
        -:  409:#endif
        -:  410:
        -:  411:#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
        -:  412:/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
        -:  413:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
        -:  414:    _Pragma ("GCC diagnostic push") \
        -:  415:    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
        -:  416:    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
        -:  417:# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
        -:  418:    _Pragma ("GCC diagnostic pop")
        -:  419:#else
        -:  420:# define YY_INITIAL_VALUE(Value) Value
        -:  421:#endif
        -:  422:#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  423:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  424:# define YY_IGNORE_MAYBE_UNINITIALIZED_END
        -:  425:#endif
        -:  426:#ifndef YY_INITIAL_VALUE
        -:  427:# define YY_INITIAL_VALUE(Value) /* Nothing. */
        -:  428:#endif
        -:  429:
        -:  430:
        -:  431:#if ! defined yyoverflow || YYERROR_VERBOSE
        -:  432:
        -:  433:/* The parser invokes alloca or malloc; define the necessary symbols.  */
        -:  434:
        -:  435:# ifdef YYSTACK_USE_ALLOCA
        -:  436:#  if YYSTACK_USE_ALLOCA
        -:  437:#   ifdef __GNUC__
        -:  438:#    define YYSTACK_ALLOC __builtin_alloca
        -:  439:#   elif defined __BUILTIN_VA_ARG_INCR
        -:  440:#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
        -:  441:#   elif defined _AIX
        -:  442:#    define YYSTACK_ALLOC __alloca
        -:  443:#   elif defined _MSC_VER
        -:  444:#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
        -:  445:#    define alloca _alloca
        -:  446:#   else
        -:  447:#    define YYSTACK_ALLOC alloca
        -:  448:#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
        -:  449:#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  450:      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
        -:  451:#     ifndef EXIT_SUCCESS
        -:  452:#      define EXIT_SUCCESS 0
        -:  453:#     endif
        -:  454:#    endif
        -:  455:#   endif
        -:  456:#  endif
        -:  457:# endif
        -:  458:
        -:  459:# ifdef YYSTACK_ALLOC
        -:  460:   /* Pacify GCC's 'empty if-body' warning.  */
        -:  461:#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
        -:  462:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  463:    /* The OS might guarantee only one guard page at the bottom of the stack,
        -:  464:       and a page size can be as small as 4096 bytes.  So we cannot safely
        -:  465:       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
        -:  466:       to allow for a few compiler-allocated temporary stack slots.  */
        -:  467:#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
        -:  468:#  endif
        -:  469:# else
        -:  470:#  define YYSTACK_ALLOC YYMALLOC
        -:  471:#  define YYSTACK_FREE YYFREE
        -:  472:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  473:#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
        -:  474:#  endif
        -:  475:#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
        -:  476:       && ! ((defined YYMALLOC || defined malloc) \
        -:  477:             && (defined YYFREE || defined free)))
        -:  478:#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  479:#   ifndef EXIT_SUCCESS
        -:  480:#    define EXIT_SUCCESS 0
        -:  481:#   endif
        -:  482:#  endif
        -:  483:#  ifndef YYMALLOC
        -:  484:#   define YYMALLOC malloc
        -:  485:#   if ! defined malloc && ! defined EXIT_SUCCESS
        -:  486:void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
        -:  487:#   endif
        -:  488:#  endif
        -:  489:#  ifndef YYFREE
        -:  490:#   define YYFREE free
        -:  491:#   if ! defined free && ! defined EXIT_SUCCESS
        -:  492:void free (void *); /* INFRINGES ON USER NAME SPACE */
        -:  493:#   endif
        -:  494:#  endif
        -:  495:# endif
        -:  496:#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
        -:  497:
        -:  498:
        -:  499:#if (! defined yyoverflow \
        -:  500:     && (! defined __cplusplus \
        -:  501:         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
        -:  502:
        -:  503:/* A type that is properly aligned for any stack member.  */
        -:  504:union yyalloc
        -:  505:{
        -:  506:  yytype_int16 yyss_alloc;
        -:  507:  YYSTYPE yyvs_alloc;
        -:  508:};
        -:  509:
        -:  510:/* The size of the maximum gap between one aligned stack and the next.  */
        -:  511:# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
        -:  512:
        -:  513:/* The size of an array large to enough to hold all stacks, each with
        -:  514:   N elements.  */
        -:  515:# define YYSTACK_BYTES(N) \
        -:  516:     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
        -:  517:      + YYSTACK_GAP_MAXIMUM)
        -:  518:
        -:  519:# define YYCOPY_NEEDED 1
        -:  520:
        -:  521:/* Relocate STACK from its old location to the new one.  The
        -:  522:   local variables YYSIZE and YYSTACKSIZE give the old and new number of
        -:  523:   elements in the stack, and YYPTR gives the new location of the
        -:  524:   stack.  Advance YYPTR to a properly aligned location for the next
        -:  525:   stack.  */
        -:  526:# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
        -:  527:    do                                                                  \
        -:  528:      {                                                                 \
        -:  529:        YYSIZE_T yynewbytes;                                            \
        -:  530:        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
        -:  531:        Stack = &yyptr->Stack_alloc;                                    \
        -:  532:        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
        -:  533:        yyptr += yynewbytes / sizeof (*yyptr);                          \
        -:  534:      }                                                                 \
        -:  535:    while (0)
        -:  536:
        -:  537:#endif
        -:  538:
        -:  539:#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
        -:  540:/* Copy COUNT objects from SRC to DST.  The source and destination do
        -:  541:   not overlap.  */
        -:  542:# ifndef YYCOPY
        -:  543:#  if defined __GNUC__ && 1 < __GNUC__
        -:  544:#   define YYCOPY(Dst, Src, Count) \
        -:  545:      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
        -:  546:#  else
        -:  547:#   define YYCOPY(Dst, Src, Count)              \
        -:  548:      do                                        \
        -:  549:        {                                       \
        -:  550:          YYSIZE_T yyi;                         \
        -:  551:          for (yyi = 0; yyi < (Count); yyi++)   \
        -:  552:            (Dst)[yyi] = (Src)[yyi];            \
        -:  553:        }                                       \
        -:  554:      while (0)
        -:  555:#  endif
        -:  556:# endif
        -:  557:#endif /* !YYCOPY_NEEDED */
        -:  558:
        -:  559:/* YYFINAL -- State number of the termination state.  */
        -:  560:#define YYFINAL  2
        -:  561:/* YYLAST -- Last index in YYTABLE.  */
        -:  562:#define YYLAST   396
        -:  563:
        -:  564:/* YYNTOKENS -- Number of terminals.  */
        -:  565:#define YYNTOKENS  73
        -:  566:/* YYNNTS -- Number of nonterminals.  */
        -:  567:#define YYNNTS  41
        -:  568:/* YYNRULES -- Number of rules.  */
        -:  569:#define YYNRULES  123
        -:  570:/* YYNSTATES -- Number of states.  */
        -:  571:#define YYNSTATES  211
        -:  572:
        -:  573:/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
        -:  574:   by yylex, with out-of-bounds checking.  */
        -:  575:#define YYUNDEFTOK  2
        -:  576:#define YYMAXUTOK   308
        -:  577:
        -:  578:#define YYTRANSLATE(YYX)                                                \
        -:  579:  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
        -:  580:
        -:  581:/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
        -:  582:   as returned by yylex, without out-of-bounds checking.  */
        -:  583:static const yytype_uint8 yytranslate[] =
        -:  584:{
        -:  585:       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  586:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  587:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  588:       2,     2,     2,     2,     2,     2,     2,    58,    45,     2,
        -:  589:      70,    71,    56,    54,    72,    55,    67,     2,     2,     2,
        -:  590:       2,     2,     2,     2,     2,     2,     2,     2,    65,     2,
        -:  591:       2,    66,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  592:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  593:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  594:       2,    68,    57,    69,    44,     2,     2,     2,     2,     2,
        -:  595:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  596:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  597:       2,     2,     2,    63,    43,    64,    60,     2,     2,     2,
        -:  598:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  599:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  600:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  601:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  602:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  603:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  604:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  605:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  606:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  607:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  608:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  609:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  610:       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
        -:  611:       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
        -:  612:      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
        -:  613:      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
        -:  614:      35,    36,    37,    38,    39,    40,    41,    42,    46,    47,
        -:  615:      48,    49,    50,    51,    52,    53,    59,    61,    62
        -:  616:};
        -:  617:
        -:  618:#if YYDEBUG
        -:  619:  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
        -:  620:static const yytype_uint16 yyrline[] =
        -:  621:{
        -:  622:       0,   232,   232,   234,   235,   236,   237,   238,   243,   256,
        -:  623:     261,   255,   282,   285,   313,   316,   341,   346,   347,   352,
        -:  624:     353,   359,   362,   380,   389,   428,   429,   434,   451,   465,
        -:  625:     479,   493,   511,   512,   518,   517,   533,   532,   548,   562,
        -:  626:     563,   568,   569,   570,   571,   572,   577,   663,   710,   769,
        -:  627:     815,   816,   820,   848,   888,   931,   951,   958,   965,   977,
        -:  628:     987,  1001,  1014,  1025,  1036,  1065,  1035,  1179,  1178,  1256,
        -:  629:    1262,  1269,  1268,  1314,  1313,  1357,  1364,  1371,  1378,  1385,
        -:  630:    1392,  1399,  1403,  1411,  1412,  1417,  1441,  1454,  1472,  1471,
        -:  631:    1477,  1489,  1490,  1495,  1502,  1513,  1514,  1518,  1526,  1530,
        -:  632:    1538,  1550,  1564,  1572,  1579,  1604,  1616,  1628,  1644,  1656,
        -:  633:    1672,  1719,  1740,  1775,  1810,  1844,  1869,  1886,  1896,  1906,
        -:  634:    1916,  1926,  1944,  1962
        -:  635:};
        -:  636:#endif
        -:  637:
        -:  638:#if YYDEBUG || YYERROR_VERBOSE || 0
        -:  639:/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
        -:  640:   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
        -:  641:static const char *const yytname[] =
        -:  642:{
        -:  643:  "$end", "error", "$undefined", "_DOT_DOT_", "_RULE_", "_PRIVATE_",
        -:  644:  "_GLOBAL_", "_META_", "_STRINGS_", "_CONDITION_", "_IDENTIFIER_",
        -:  645:  "_STRING_IDENTIFIER_", "_STRING_COUNT_", "_STRING_OFFSET_",
        -:  646:  "_STRING_LENGTH_", "_STRING_IDENTIFIER_WITH_WILDCARD_", "_NUMBER_",
        -:  647:  "_DOUBLE_", "_INTEGER_FUNCTION_", "_TEXT_STRING_", "_HEX_STRING_",
        -:  648:  "_REGEXP_", "_ASCII_", "_WIDE_", "_XOR_", "_NOCASE_", "_FULLWORD_",
        -:  649:  "_AT_", "_FILESIZE_", "_ENTRYPOINT_", "_ALL_", "_ANY_", "_IN_", "_OF_",
        -:  650:  "_FOR_", "_THEM_", "_MATCHES_", "_CONTAINS_", "_IMPORT_", "_TRUE_",
        -:  651:  "_FALSE_", "_OR_", "_AND_", "'|'", "'^'", "'&'", "_EQ_", "_NEQ_", "_LT_",
        -:  652:  "_LE_", "_GT_", "_GE_", "_SHIFT_LEFT_", "_SHIFT_RIGHT_", "'+'", "'-'",
        -:  653:  "'*'", "'\\\\'", "'%'", "_NOT_", "'~'", "UNARY_MINUS", "\"include\"",
        -:  654:  "'{'", "'}'", "':'", "'='", "'.'", "'['", "']'", "'('", "')'", "','",
        -:  655:  "$accept", "rules", "import", "rule", "@1", "$@2", "meta", "strings",
        -:  656:  "condition", "rule_modifiers", "rule_modifier", "tags", "tag_list",
        -:  657:  "meta_declarations", "meta_declaration", "string_declarations",
        -:  658:  "string_declaration", "$@3", "$@4", "string_modifiers",
        -:  659:  "string_modifier", "identifier", "arguments", "arguments_list", "regexp",
        -:  660:  "boolean_expression", "expression", "$@5", "$@6", "$@7", "$@8", "$@9",
        -:  661:  "integer_set", "range", "integer_enumeration", "string_set", "$@10",
        -:  662:  "string_enumeration", "string_enumeration_item", "for_expression",
        -:  663:  "primary_expression", YY_NULLPTR
        -:  664:};
        -:  665:#endif
        -:  666:
        -:  667:# ifdef YYPRINT
        -:  668:/* YYTOKNUM[NUM] -- (External) token number corresponding to the
        -:  669:   (internal) symbol number NUM (which must be that of a token).  */
        -:  670:static const yytype_uint16 yytoknum[] =
        -:  671:{
        -:  672:       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
        -:  673:     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
        -:  674:     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
        -:  675:     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
        -:  676:     295,   296,   297,   124,    94,    38,   298,   299,   300,   301,
        -:  677:     302,   303,   304,   305,    43,    45,    42,    92,    37,   306,
        -:  678:     126,   307,   308,   123,   125,    58,    61,    46,    91,    93,
        -:  679:      40,    41,    44
        -:  680:};
        -:  681:# endif
        -:  682:
        -:  683:#define YYPACT_NINF -73
        -:  684:
        -:  685:#define yypact_value_is_default(Yystate) \
        -:  686:  (!!((Yystate) == (-73)))
        -:  687:
        -:  688:#define YYTABLE_NINF -96
        -:  689:
        -:  690:#define yytable_value_is_error(Yytable_value) \
        -:  691:  0
        -:  692:
        -:  693:  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
        -:  694:     STATE-NUM.  */
        -:  695:static const yytype_int16 yypact[] =
        -:  696:{
        -:  697:     -73,    90,   -73,   -33,   -16,   -73,   -73,    69,   -73,   -73,
        -:  698:     -73,   -73,     5,   -73,   -73,   -73,   -73,   -42,    44,   -38,
        -:  699:     -73,    60,    61,   -73,    21,    72,    79,    41,   -73,    64,
        -:  700:      79,   -73,   129,   141,    16,   -73,    85,   129,   -73,    80,
        -:  701:      96,   -73,   -73,   -73,   -73,   145,    81,   -73,    48,   -73,
        -:  702:     -73,   -73,   143,   150,   -73,   -10,   -73,   104,   111,   -73,
        -:  703:     -73,   114,   -73,   -73,   -73,   -73,   -73,   -73,   103,   -73,
        -:  704:     -73,   125,    48,   125,    48,   -34,   -73,    68,   -73,   148,
        -:  705:     293,   -73,   -73,   125,   116,   125,   125,   125,   125,    71,
        -:  706:     309,   -73,   -73,   -73,    68,   133,   170,   172,   125,    48,
        -:  707:     -73,   -73,    -7,   184,   125,   125,   125,   125,   125,   125,
        -:  708:     125,   125,   125,   125,   125,   125,   125,   125,   125,   125,
        -:  709:     125,   152,   152,   309,   125,   -73,   230,   248,   112,   190,
        -:  710:     -73,   176,    -7,   -73,   -73,   -73,   266,   138,   139,    70,
        -:  711:      48,    48,   -73,   -73,   -73,   -73,   309,   324,   338,   -44,
        -:  712:     309,   309,   309,   309,   309,   309,   136,   136,    27,    27,
        -:  713:     -73,   -73,   -73,   -73,   -73,   -73,   -73,   -73,   -73,   144,
        -:  714:     -73,   -73,   -73,   -73,   147,   -73,   -73,    48,   168,   -73,
        -:  715:      15,   125,   159,   -73,    70,   -73,   -73,    54,   -73,   210,
        -:  716:     125,   165,   -73,   161,   -73,    15,   -73,    77,   144,   -73,
        -:  717:      48,   -73,   -73,   125,   162,    56,   309,    48,   -73,    58,
        -:  718:     -73
        -:  719:};
        -:  720:
        -:  721:  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
        -:  722:     Performed when YYTABLE does not specify something else to do.  Zero
        -:  723:     means the default is an error.  */
        -:  724:static const yytype_uint8 yydefact[] =
        -:  725:{
        -:  726:       2,     0,     1,    17,     0,     4,     3,     0,     7,     6,
        -:  727:       5,     8,     0,    19,    20,    18,     9,    21,     0,     0,
        -:  728:      23,    22,    12,    24,     0,    14,     0,     0,    10,     0,
        -:  729:      13,    25,     0,     0,     0,    26,     0,    15,    32,     0,
        -:  730:       0,    28,    27,    30,    31,     0,    34,    33,     0,    11,
        -:  731:      29,    38,     0,     0,    46,    60,   105,   107,   109,   102,
        -:  732:     103,     0,   104,    54,    99,   100,    96,    97,     0,    56,
        -:  733:      57,     0,     0,     0,     0,   110,   123,    16,    55,     0,
        -:  734:      81,    39,    39,     0,     0,     0,     0,     0,     0,     0,
        -:  735:      95,   111,    70,   120,     0,    55,    81,     0,     0,    50,
        -:  736:      73,    71,     0,     0,     0,     0,     0,     0,     0,     0,
        -:  737:       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        -:  738:       0,    35,    37,    61,     0,    62,     0,     0,     0,     0,
        -:  739:      63,     0,     0,    82,    98,    47,     0,     0,    51,    52,
        -:  740:       0,     0,    90,    88,    69,    58,    59,   119,   117,   118,
        -:  741:      79,    80,    75,    77,    76,    78,   121,   122,   112,   113,
        -:  742:     114,   115,   116,    42,    41,    45,    43,    44,    40,     0,
        -:  743:     106,   108,   101,    64,     0,    48,    49,     0,    74,    72,
        -:  744:       0,     0,     0,    67,    53,    93,    94,     0,    91,     0,
        -:  745:       0,     0,    84,     0,    89,     0,    85,     0,    86,    65,
        -:  746:       0,    92,    83,     0,     0,     0,    87,     0,    68,     0,
        -:  747:      66
        -:  748:};
        -:  749:
        -:  750:  /* YYPGOTO[NTERM-NUM].  */
        -:  751:static const yytype_int16 yypgoto[] =
        -:  752:{
        -:  753:     -73,   -73,   233,   234,   -73,   -73,   -73,   -73,   -73,   -73,
        -:  754:     -73,   -73,   -73,   -73,   208,   -73,   202,   -73,   -73,   158,
        -:  755:     -73,   -73,   -73,   -73,   146,   -48,   -72,   -73,   -73,   -73,
        -:  756:     -73,   -73,   -73,    74,   -73,   118,   -73,   -73,    57,   183,
        -:  757:     -67
        -:  758:};
        -:  759:
        -:  760:  /* YYDEFGOTO[NTERM-NUM].  */
        -:  761:static const yytype_int16 yydefgoto[] =
        -:  762:{
        -:  763:      -1,     1,     5,     6,    17,    33,    25,    28,    40,     7,
        -:  764:      15,    19,    21,    30,    31,    37,    38,    52,    53,   121,
        -:  765:     168,    75,   137,   138,    76,    94,    78,   182,   204,   193,
        -:  766:     141,   140,   191,   125,   197,   144,   180,   187,   188,    79,
        -:  767:      80
        -:  768:};
        -:  769:
        -:  770:  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
        -:  771:     positive, shift that token.  If negative, reduce the rule whose
        -:  772:     number is the opposite.  If YYTABLE_NINF, syntax error.  */
        -:  773:static const yytype_int16 yytable[] =
        -:  774:{
        -:  775:      77,    90,    95,    11,    91,     4,    93,    96,   114,   115,
        -:  776:     116,   117,   118,   119,   120,    16,   123,    83,   126,   127,
        -:  777:     128,   129,    84,    18,    92,    22,   185,   139,   142,     8,
        -:  778:     186,   136,    41,    97,    98,    42,    99,   146,   147,   148,
        -:  779:     149,   150,   151,   152,   153,   154,   155,   156,   157,   158,
        -:  780:     159,   160,   161,   162,    20,    43,    44,   169,    54,    55,
        -:  781:      56,    57,    58,   143,    59,    60,    61,    62,    24,    63,
        -:  782:      23,    45,   130,    12,    13,    14,    64,    65,    66,    67,
        -:  783:      27,   131,    68,   118,   119,   120,    26,    69,    70,    29,
        -:  784:       2,     3,   178,   179,   -17,   -17,   -17,   100,   101,   100,
        -:  785:     101,    51,   -36,    71,   132,   184,    32,    72,    73,   100,
        -:  786:     101,   -55,   -55,    54,   189,    56,    57,    58,    74,    59,
        -:  787:      60,    61,    62,   198,    63,   194,   195,   208,     4,   210,
        -:  788:      34,    64,    65,    66,    67,    54,   206,    56,    57,    58,
        -:  789:      36,    59,    60,    61,    62,    48,    63,   181,   202,   203,
        -:  790:      39,    46,   205,    64,    65,   105,   106,   107,    71,   209,
        -:  791:      49,    50,    81,    73,   114,   115,   116,   117,   118,   119,
        -:  792:     120,    82,    85,    88,   163,   164,   165,   166,   167,    86,
        -:  793:      71,   102,   135,   172,    87,    73,   124,   105,   106,   107,
        -:  794:     116,   117,   118,   119,   120,    88,   114,   115,   116,   117,
        -:  795:     118,   119,   120,   -95,   133,    63,   103,   104,   173,   176,
        -:  796:     101,   177,   183,   105,   106,   107,   108,   109,   110,   111,
        -:  797:     112,   113,   114,   115,   116,   117,   118,   119,   120,   190,
        -:  798:     199,   200,   207,   105,   106,   107,     9,    10,    35,    47,
        -:  799:     122,   134,   114,   115,   116,   117,   118,   119,   120,   145,
        -:  800:     174,    89,   201,   105,   106,   107,   192,     0,     0,     0,
        -:  801:       0,   134,   114,   115,   116,   117,   118,   119,   120,     0,
        -:  802:       0,     0,     0,   105,   106,   107,     0,     0,     0,     0,
        -:  803:       0,   196,   114,   115,   116,   117,   118,   119,   120,     0,
        -:  804:       0,   105,   106,   107,     0,     0,     0,     0,     0,   170,
        -:  805:     114,   115,   116,   117,   118,   119,   120,     0,     0,   105,
        -:  806:     106,   107,     0,     0,     0,     0,     0,   171,   114,   115,
        -:  807:     116,   117,   118,   119,   120,     0,   -95,     0,     0,   103,
        -:  808:     104,     0,     0,     0,     0,   175,   105,   106,   107,   108,
        -:  809:     109,   110,   111,   112,   113,   114,   115,   116,   117,   118,
        -:  810:     119,   120,   105,   106,   107,     0,     0,     0,     0,     0,
        -:  811:       0,   114,   115,   116,   117,   118,   119,   120,   106,   107,
        -:  812:       0,     0,     0,     0,     0,     0,   114,   115,   116,   117,
        -:  813:     118,   119,   120,   107,     0,     0,     0,     0,     0,     0,
        -:  814:     114,   115,   116,   117,   118,   119,   120
        -:  815:};
        -:  816:
        -:  817:static const yytype_int16 yycheck[] =
        -:  818:{
        -:  819:      48,    68,    74,    19,    71,    38,    73,    74,    52,    53,
        -:  820:      54,    55,    56,    57,    58,    10,    83,    27,    85,    86,
        -:  821:      87,    88,    32,    65,    72,    63,    11,    99,    35,    62,
        -:  822:      15,    98,    16,    67,    68,    19,    70,   104,   105,   106,
        -:  823:     107,   108,   109,   110,   111,   112,   113,   114,   115,   116,
        -:  824:     117,   118,   119,   120,    10,    39,    40,   124,    10,    11,
        -:  825:      12,    13,    14,    70,    16,    17,    18,    19,     7,    21,
        -:  826:      10,    55,     1,     4,     5,     6,    28,    29,    30,    31,
        -:  827:       8,    10,    34,    56,    57,    58,    65,    39,    40,    10,
        -:  828:       0,     1,   140,   141,     4,     5,     6,    41,    42,    41,
        -:  829:      42,    20,    21,    55,    33,   177,    65,    59,    60,    41,
        -:  830:      42,    41,    42,    10,   181,    12,    13,    14,    70,    16,
        -:  831:      17,    18,    19,   190,    21,    71,    72,    71,    38,    71,
        -:  832:      66,    28,    29,    30,    31,    10,   203,    12,    13,    14,
        -:  833:      11,    16,    17,    18,    19,    65,    21,     3,    71,    72,
        -:  834:       9,    66,   200,    28,    29,    43,    44,    45,    55,   207,
        -:  835:      64,    16,    19,    60,    52,    53,    54,    55,    56,    57,
        -:  836:      58,    21,    68,    70,    22,    23,    24,    25,    26,    68,
        -:  837:      55,    33,    10,    71,    70,    60,    70,    43,    44,    45,
        -:  838:      54,    55,    56,    57,    58,    70,    52,    53,    54,    55,
        -:  839:      56,    57,    58,    33,    71,    21,    36,    37,    32,    71,
        -:  840:      42,    72,    65,    43,    44,    45,    46,    47,    48,    49,
        -:  841:      50,    51,    52,    53,    54,    55,    56,    57,    58,    70,
        -:  842:      65,    70,    70,    43,    44,    45,     3,     3,    30,    37,
        -:  843:      82,    71,    52,    53,    54,    55,    56,    57,    58,   103,
        -:  844:     132,    68,   195,    43,    44,    45,   182,    -1,    -1,    -1,
        -:  845:      -1,    71,    52,    53,    54,    55,    56,    57,    58,    -1,
        -:  846:      -1,    -1,    -1,    43,    44,    45,    -1,    -1,    -1,    -1,
        -:  847:      -1,    71,    52,    53,    54,    55,    56,    57,    58,    -1,
        -:  848:      -1,    43,    44,    45,    -1,    -1,    -1,    -1,    -1,    69,
        -:  849:      52,    53,    54,    55,    56,    57,    58,    -1,    -1,    43,
        -:  850:      44,    45,    -1,    -1,    -1,    -1,    -1,    69,    52,    53,
        -:  851:      54,    55,    56,    57,    58,    -1,    33,    -1,    -1,    36,
        -:  852:      37,    -1,    -1,    -1,    -1,    69,    43,    44,    45,    46,
        -:  853:      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,
        -:  854:      57,    58,    43,    44,    45,    -1,    -1,    -1,    -1,    -1,
        -:  855:      -1,    52,    53,    54,    55,    56,    57,    58,    44,    45,
        -:  856:      -1,    -1,    -1,    -1,    -1,    -1,    52,    53,    54,    55,
        -:  857:      56,    57,    58,    45,    -1,    -1,    -1,    -1,    -1,    -1,
        -:  858:      52,    53,    54,    55,    56,    57,    58
        -:  859:};
        -:  860:
        -:  861:  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
        -:  862:     symbol of state STATE-NUM.  */
        -:  863:static const yytype_uint8 yystos[] =
        -:  864:{
        -:  865:       0,    74,     0,     1,    38,    75,    76,    82,    62,    75,
        -:  866:      76,    19,     4,     5,     6,    83,    10,    77,    65,    84,
        -:  867:      10,    85,    63,    10,     7,    79,    65,     8,    80,    10,
        -:  868:      86,    87,    65,    78,    66,    87,    11,    88,    89,     9,
        -:  869:      81,    16,    19,    39,    40,    55,    66,    89,    65,    64,
        -:  870:      16,    20,    90,    91,    10,    11,    12,    13,    14,    16,
        -:  871:      17,    18,    19,    21,    28,    29,    30,    31,    34,    39,
        -:  872:      40,    55,    59,    60,    70,    94,    97,    98,    99,   112,
        -:  873:     113,    19,    21,    27,    32,    68,    68,    70,    70,   112,
        -:  874:     113,   113,    98,   113,    98,    99,   113,    67,    68,    70,
        -:  875:      41,    42,    33,    36,    37,    43,    44,    45,    46,    47,
        -:  876:      48,    49,    50,    51,    52,    53,    54,    55,    56,    57,
        -:  877:      58,    92,    92,   113,    70,   106,   113,   113,   113,   113,
        -:  878:       1,    10,    33,    71,    71,    10,   113,    95,    96,    99,
        -:  879:     104,   103,    35,    70,   108,    97,   113,   113,   113,   113,
        -:  880:     113,   113,   113,   113,   113,   113,   113,   113,   113,   113,
        -:  881:     113,   113,   113,    22,    23,    24,    25,    26,    93,   113,
        -:  882:      69,    69,    71,    32,   108,    69,    71,    72,    98,    98,
        -:  883:     109,     3,   100,    65,    99,    11,    15,   110,   111,   113,
        -:  884:      70,   105,   106,   102,    71,    72,    71,   107,   113,    65,
        -:  885:      70,   111,    71,    72,   101,    98,   113,    70,    71,    98,
        -:  886:      71
        -:  887:};
        -:  888:
        -:  889:  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
        -:  890:static const yytype_uint8 yyr1[] =
        -:  891:{
        -:  892:       0,    73,    74,    74,    74,    74,    74,    74,    75,    77,
        -:  893:      78,    76,    79,    79,    80,    80,    81,    82,    82,    83,
        -:  894:      83,    84,    84,    85,    85,    86,    86,    87,    87,    87,
        -:  895:      87,    87,    88,    88,    90,    89,    91,    89,    89,    92,
        -:  896:      92,    93,    93,    93,    93,    93,    94,    94,    94,    94,
        -:  897:      95,    95,    96,    96,    97,    98,    99,    99,    99,    99,
        -:  898:      99,    99,    99,    99,   100,   101,    99,   102,    99,    99,
        -:  899:      99,   103,    99,   104,    99,    99,    99,    99,    99,    99,
        -:  900:      99,    99,    99,   105,   105,   106,   107,   107,   109,   108,
        -:  901:     108,   110,   110,   111,   111,   112,   112,   112,   113,   113,
        -:  902:     113,   113,   113,   113,   113,   113,   113,   113,   113,   113,
        -:  903:     113,   113,   113,   113,   113,   113,   113,   113,   113,   113,
        -:  904:     113,   113,   113,   113
        -:  905:};
        -:  906:
        -:  907:  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
        -:  908:static const yytype_uint8 yyr2[] =
        -:  909:{
        -:  910:       0,     2,     0,     2,     2,     3,     3,     3,     2,     0,
        -:  911:       0,    11,     0,     3,     0,     3,     3,     0,     2,     1,
        -:  912:       1,     0,     2,     1,     2,     1,     2,     3,     3,     4,
        -:  913:       3,     3,     1,     2,     0,     5,     0,     5,     3,     0,
        -:  914:       2,     1,     1,     1,     1,     1,     1,     3,     4,     4,
        -:  915:       0,     1,     1,     3,     1,     1,     1,     1,     3,     3,
        -:  916:       1,     3,     3,     3,     0,     0,    11,     0,     9,     3,
        -:  917:       2,     0,     4,     0,     4,     3,     3,     3,     3,     3,
        -:  918:       3,     1,     3,     3,     1,     5,     1,     3,     0,     4,
        -:  919:       1,     1,     3,     1,     1,     1,     1,     1,     3,     1,
        -:  920:       1,     4,     1,     1,     1,     1,     4,     1,     4,     1,
        -:  921:       1,     2,     3,     3,     3,     3,     3,     3,     3,     3,
        -:  922:       2,     3,     3,     1
        -:  923:};
        -:  924:
        -:  925:
        -:  926:#define yyerrok         (yyerrstatus = 0)
        -:  927:#define yyclearin       (yychar = YYEMPTY)
        -:  928:#define YYEMPTY         (-2)
        -:  929:#define YYEOF           0
        -:  930:
        -:  931:#define YYACCEPT        goto yyacceptlab
        -:  932:#define YYABORT         goto yyabortlab
        -:  933:#define YYERROR         goto yyerrorlab
        -:  934:
        -:  935:
        -:  936:#define YYRECOVERING()  (!!yyerrstatus)
        -:  937:
        -:  938:#define YYBACKUP(Token, Value)                                  \
        -:  939:do                                                              \
        -:  940:  if (yychar == YYEMPTY)                                        \
        -:  941:    {                                                           \
        -:  942:      yychar = (Token);                                         \
        -:  943:      yylval = (Value);                                         \
        -:  944:      YYPOPSTACK (yylen);                                       \
        -:  945:      yystate = *yyssp;                                         \
        -:  946:      goto yybackup;                                            \
        -:  947:    }                                                           \
        -:  948:  else                                                          \
        -:  949:    {                                                           \
        -:  950:      yyerror (yyscanner, compiler, YY_("syntax error: cannot back up")); \
        -:  951:      YYERROR;                                                  \
        -:  952:    }                                                           \
        -:  953:while (0)
        -:  954:
        -:  955:/* Error token number */
        -:  956:#define YYTERROR        1
        -:  957:#define YYERRCODE       256
        -:  958:
        -:  959:
        -:  960:
        -:  961:/* Enable debugging if requested.  */
        -:  962:#if YYDEBUG
        -:  963:
        -:  964:# ifndef YYFPRINTF
        -:  965:#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
        -:  966:#  define YYFPRINTF fprintf
        -:  967:# endif
        -:  968:
        -:  969:# define YYDPRINTF(Args)                        \
        -:  970:do {                                            \
        -:  971:  if (yydebug)                                  \
        -:  972:    YYFPRINTF Args;                             \
        -:  973:} while (0)
        -:  974:
        -:  975:/* This macro is provided for backward compatibility. */
        -:  976:#ifndef YY_LOCATION_PRINT
        -:  977:# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
        -:  978:#endif
        -:  979:
        -:  980:
        -:  981:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
        -:  982:do {                                                                      \
        -:  983:  if (yydebug)                                                            \
        -:  984:    {                                                                     \
        -:  985:      YYFPRINTF (stderr, "%s ", Title);                                   \
        -:  986:      yy_symbol_print (stderr,                                            \
        -:  987:                  Type, Value, yyscanner, compiler); \
        -:  988:      YYFPRINTF (stderr, "\n");                                           \
        -:  989:    }                                                                     \
        -:  990:} while (0)
        -:  991:
        -:  992:
        -:  993:/*----------------------------------------.
        -:  994:| Print this symbol's value on YYOUTPUT.  |
        -:  995:`----------------------------------------*/
        -:  996:
        -:  997:static void
        -:  998:yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -:  999:{
        -: 1000:  FILE *yyo = yyoutput;
        -: 1001:  YYUSE (yyo);
        -: 1002:  YYUSE (yyscanner);
        -: 1003:  YYUSE (compiler);
        -: 1004:  if (!yyvaluep)
        -: 1005:    return;
        -: 1006:# ifdef YYPRINT
        -: 1007:  if (yytype < YYNTOKENS)
        -: 1008:    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
        -: 1009:# endif
        -: 1010:  YYUSE (yytype);
        -: 1011:}
        -: 1012:
        -: 1013:
        -: 1014:/*--------------------------------.
        -: 1015:| Print this symbol on YYOUTPUT.  |
        -: 1016:`--------------------------------*/
        -: 1017:
        -: 1018:static void
        -: 1019:yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1020:{
        -: 1021:  YYFPRINTF (yyoutput, "%s %s (",
        -: 1022:             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
        -: 1023:
        -: 1024:  yy_symbol_value_print (yyoutput, yytype, yyvaluep, yyscanner, compiler);
        -: 1025:  YYFPRINTF (yyoutput, ")");
        -: 1026:}
        -: 1027:
        -: 1028:/*------------------------------------------------------------------.
        -: 1029:| yy_stack_print -- Print the state stack from its BOTTOM up to its |
        -: 1030:| TOP (included).                                                   |
        -: 1031:`------------------------------------------------------------------*/
        -: 1032:
        -: 1033:static void
        -: 1034:yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
        -: 1035:{
        -: 1036:  YYFPRINTF (stderr, "Stack now");
        -: 1037:  for (; yybottom <= yytop; yybottom++)
        -: 1038:    {
        -: 1039:      int yybot = *yybottom;
        -: 1040:      YYFPRINTF (stderr, " %d", yybot);
        -: 1041:    }
        -: 1042:  YYFPRINTF (stderr, "\n");
        -: 1043:}
        -: 1044:
        -: 1045:# define YY_STACK_PRINT(Bottom, Top)                            \
        -: 1046:do {                                                            \
        -: 1047:  if (yydebug)                                                  \
        -: 1048:    yy_stack_print ((Bottom), (Top));                           \
        -: 1049:} while (0)
        -: 1050:
        -: 1051:
        -: 1052:/*------------------------------------------------.
        -: 1053:| Report that the YYRULE is going to be reduced.  |
        -: 1054:`------------------------------------------------*/
        -: 1055:
        -: 1056:static void
        -: 1057:yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule, void *yyscanner, YR_COMPILER* compiler)
        -: 1058:{
        -: 1059:  unsigned long int yylno = yyrline[yyrule];
        -: 1060:  int yynrhs = yyr2[yyrule];
        -: 1061:  int yyi;
        -: 1062:  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
        -: 1063:             yyrule - 1, yylno);
        -: 1064:  /* The symbols being reduced.  */
        -: 1065:  for (yyi = 0; yyi < yynrhs; yyi++)
        -: 1066:    {
        -: 1067:      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
        -: 1068:      yy_symbol_print (stderr,
        -: 1069:                       yystos[yyssp[yyi + 1 - yynrhs]],
        -: 1070:                       &(yyvsp[(yyi + 1) - (yynrhs)])
        -: 1071:                                              , yyscanner, compiler);
        -: 1072:      YYFPRINTF (stderr, "\n");
        -: 1073:    }
        -: 1074:}
        -: 1075:
        -: 1076:# define YY_REDUCE_PRINT(Rule)          \
        -: 1077:do {                                    \
        -: 1078:  if (yydebug)                          \
        -: 1079:    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner, compiler); \
        -: 1080:} while (0)
        -: 1081:
        -: 1082:/* Nonzero means print parse trace.  It is left uninitialized so that
        -: 1083:   multiple parsers can coexist.  */
        -: 1084:int yydebug;
        -: 1085:#else /* !YYDEBUG */
        -: 1086:# define YYDPRINTF(Args)
        -: 1087:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
        -: 1088:# define YY_STACK_PRINT(Bottom, Top)
        -: 1089:# define YY_REDUCE_PRINT(Rule)
        -: 1090:#endif /* !YYDEBUG */
        -: 1091:
        -: 1092:
        -: 1093:/* YYINITDEPTH -- initial size of the parser's stacks.  */
        -: 1094:#ifndef YYINITDEPTH
        -: 1095:# define YYINITDEPTH 200
        -: 1096:#endif
        -: 1097:
        -: 1098:/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
        -: 1099:   if the built-in stack extension method is used).
        -: 1100:
        -: 1101:   Do not make this value too large; the results are undefined if
        -: 1102:   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
        -: 1103:   evaluated with infinite-precision integer arithmetic.  */
        -: 1104:
        -: 1105:#ifndef YYMAXDEPTH
        -: 1106:# define YYMAXDEPTH 10000
        -: 1107:#endif
        -: 1108:
        -: 1109:
        -: 1110:#if YYERROR_VERBOSE
        -: 1111:
        -: 1112:# ifndef yystrlen
        -: 1113:#  if defined __GLIBC__ && defined _STRING_H
        -: 1114:#   define yystrlen strlen
        -: 1115:#  else
        -: 1116:/* Return the length of YYSTR.  */
        -: 1117:static YYSIZE_T
        -: 1118:yystrlen (const char *yystr)
        -: 1119:{
        -: 1120:  YYSIZE_T yylen;
        -: 1121:  for (yylen = 0; yystr[yylen]; yylen++)
        -: 1122:    continue;
        -: 1123:  return yylen;
        -: 1124:}
        -: 1125:#  endif
        -: 1126:# endif
        -: 1127:
        -: 1128:# ifndef yystpcpy
        -: 1129:#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
        -: 1130:#   define yystpcpy stpcpy
        -: 1131:#  else
        -: 1132:/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
        -: 1133:   YYDEST.  */
        -: 1134:static char *
        -: 1135:yystpcpy (char *yydest, const char *yysrc)
        -: 1136:{
        -: 1137:  char *yyd = yydest;
        -: 1138:  const char *yys = yysrc;
        -: 1139:
    #####: 1140:  while ((*yyd++ = *yys++) != '\0')
branch  0 never executed
branch  1 never executed
    #####: 1141:    continue;
        -: 1142:
        -: 1143:  return yyd - 1;
        -: 1144:}
        -: 1145:#  endif
        -: 1146:# endif
        -: 1147:
        -: 1148:# ifndef yytnamerr
        -: 1149:/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
        -: 1150:   quotes and backslashes, so that it's suitable for yyerror.  The
        -: 1151:   heuristic is that double-quoting is unnecessary unless the string
        -: 1152:   contains an apostrophe, a comma, or backslash (other than
        -: 1153:   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
        -: 1154:   null, do not copy; instead, return the length of what the result
        -: 1155:   would have been.  */
        -: 1156:static YYSIZE_T
function yytnamerr called 0 returned 0% blocks executed 0%
    #####: 1157:yytnamerr (char *yyres, const char *yystr)
        -: 1158:{
    #####: 1159:  if (*yystr == '"')
branch  0 never executed
branch  1 never executed
        -: 1160:    {
        -: 1161:      YYSIZE_T yyn = 0;
        -: 1162:      char const *yyp = yystr;
        -: 1163:
        -: 1164:      for (;;)
    #####: 1165:        switch (*++yyp)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1166:          {
        -: 1167:          case '\'':
        -: 1168:          case ',':
        -: 1169:            goto do_not_strip_quotes;
        -: 1170:
    #####: 1171:          case '\\':
    #####: 1172:            if (*++yyp != '\\')
branch  0 never executed
branch  1 never executed
        -: 1173:              goto do_not_strip_quotes;
        -: 1174:            /* Fall through.  */
        -: 1175:          default:
    #####: 1176:            if (yyres)
branch  0 never executed
branch  1 never executed
    #####: 1177:              yyres[yyn] = *yyp;
    #####: 1178:            yyn++;
        -: 1179:            break;
        -: 1180:
    #####: 1181:          case '"':
    #####: 1182:            if (yyres)
branch  0 never executed
branch  1 never executed
    #####: 1183:              yyres[yyn] = '\0';
        -: 1184:            return yyn;
        -: 1185:          }
    #####: 1186:    do_not_strip_quotes: ;
        -: 1187:    }
        -: 1188:
    #####: 1189:  if (! yyres)
branch  0 never executed
branch  1 never executed
    #####: 1190:    return yystrlen (yystr);
        -: 1191:
    #####: 1192:  return yystpcpy (yyres, yystr) - yyres;
        -: 1193:}
        -: 1194:# endif
        -: 1195:
        -: 1196:/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
        -: 1197:   about the unexpected token YYTOKEN for the state stack whose top is
        -: 1198:   YYSSP.
        -: 1199:
        -: 1200:   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
        -: 1201:   not large enough to hold the message.  In that case, also set
        -: 1202:   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
        -: 1203:   required number of bytes is too large to store.  */
        -: 1204:static int
function yysyntax_error called 0 returned 0% blocks executed 0%
    #####: 1205:yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
        -: 1206:                yytype_int16 *yyssp, int yytoken)
        -: 1207:{
    #####: 1208:  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
call    0 never executed
        -: 1209:  YYSIZE_T yysize = yysize0;
        -: 1210:  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
        -: 1211:  /* Internationalized format string. */
        -: 1212:  const char *yyformat = YY_NULLPTR;
        -: 1213:  /* Arguments of yyformat. */
        -: 1214:  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
        -: 1215:  /* Number of reported tokens (one for the "unexpected", one per
        -: 1216:     "expected"). */
        -: 1217:  int yycount = 0;
        -: 1218:
        -: 1219:  /* There are many possibilities here to consider:
        -: 1220:     - If this state is a consistent state with a default action, then
        -: 1221:       the only way this function was invoked is if the default action
        -: 1222:       is an error action.  In that case, don't check for expected
        -: 1223:       tokens because there are none.
        -: 1224:     - The only way there can be no lookahead present (in yychar) is if
        -: 1225:       this state is a consistent state with a default action.  Thus,
        -: 1226:       detecting the absence of a lookahead is sufficient to determine
        -: 1227:       that there is no unexpected or expected token to report.  In that
        -: 1228:       case, just report a simple "syntax error".
        -: 1229:     - Don't assume there isn't a lookahead just because this state is a
        -: 1230:       consistent state with a default action.  There might have been a
        -: 1231:       previous inconsistent state, consistent state with a non-default
        -: 1232:       action, or user semantic action that manipulated yychar.
        -: 1233:     - Of course, the expected token list depends on states to have
        -: 1234:       correct lookahead information, and it depends on the parser not
        -: 1235:       to perform extra reductions after fetching a lookahead from the
        -: 1236:       scanner and before detecting a syntax error.  Thus, state merging
        -: 1237:       (from LALR or IELR) and default reductions corrupt the expected
        -: 1238:       token list.  However, the list is correct for canonical LR with
        -: 1239:       one exception: it will still contain any token that will not be
        -: 1240:       accepted due to an error action in a later state.
        -: 1241:  */
    #####: 1242:  if (yytoken != YYEMPTY)
branch  0 never executed
branch  1 never executed
        -: 1243:    {
    #####: 1244:      int yyn = yypact[*yyssp];
    #####: 1245:      yyarg[yycount++] = yytname[yytoken];
    #####: 1246:      if (!yypact_value_is_default (yyn))
branch  0 never executed
branch  1 never executed
        -: 1247:        {
        -: 1248:          /* Start YYX at -YYN if negative to avoid negative indexes in
        -: 1249:             YYCHECK.  In other words, skip the first -YYN actions for
        -: 1250:             this state because they are default actions.  */
    #####: 1251:          int yyxbegin = yyn < 0 ? -yyn : 0;
branch  0 never executed
branch  1 never executed
        -: 1252:          /* Stay within bounds of both yycheck and yytname.  */
    #####: 1253:          int yychecklim = YYLAST - yyn + 1;
    #####: 1254:          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
        -: 1255:          int yyx;
        -: 1256:
    #####: 1257:          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
branch  0 never executed
branch  1 never executed
    #####: 1258:            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
branch  0 never executed
branch  1 never executed
    #####: 1259:                && !yytable_value_is_error (yytable[yyx + yyn]))
branch  0 never executed
branch  1 never executed
        -: 1260:              {
    #####: 1261:                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
branch  0 never executed
branch  1 never executed
        -: 1262:                  {
        -: 1263:                    yycount = 1;
        -: 1264:                    yysize = yysize0;
        -: 1265:                    break;
        -: 1266:                  }
    #####: 1267:                yyarg[yycount++] = yytname[yyx];
        -: 1268:                {
    #####: 1269:                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
call    0 never executed
    #####: 1270:                  if (! (yysize <= yysize1
branch  0 never executed
branch  1 never executed
        -: 1271:                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
        -: 1272:                    return 2;
        -: 1273:                  yysize = yysize1;
        -: 1274:                }
        -: 1275:              }
        -: 1276:        }
        -: 1277:    }
        -: 1278:
    #####: 1279:  switch (yycount)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 1280:    {
        -: 1281:# define YYCASE_(N, S)                      \
        -: 1282:      case N:                               \
        -: 1283:        yyformat = S;                       \
        -: 1284:      break
        -: 1285:      YYCASE_(0, YY_("syntax error"));
        -: 1286:      YYCASE_(1, YY_("syntax error, unexpected %s"));
    #####: 1287:      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
    #####: 1288:      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
    #####: 1289:      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
    #####: 1290:      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
        -: 1291:# undef YYCASE_
        -: 1292:    }
        -: 1293:
        -: 1294:  {
    #####: 1295:    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
    #####: 1296:    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
branch  0 never executed
branch  1 never executed
        -: 1297:      return 2;
        -: 1298:    yysize = yysize1;
        -: 1299:  }
        -: 1300:
    #####: 1301:  if (*yymsg_alloc < yysize)
branch  0 never executed
branch  1 never executed
        -: 1302:    {
    #####: 1303:      *yymsg_alloc = 2 * yysize;
    #####: 1304:      if (! (yysize <= *yymsg_alloc
branch  0 never executed
branch  1 never executed
        -: 1305:             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
    #####: 1306:        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
        -: 1307:      return 1;
        -: 1308:    }
        -: 1309:
        -: 1310:  /* Avoid sprintf, as that infringes on the user's name space.
        -: 1311:     Don't have undefined behavior even if the translation
        -: 1312:     produced a string with the wrong number of "%s"s.  */
        -: 1313:  {
    #####: 1314:    char *yyp = *yymsg;
        -: 1315:    int yyi = 0;
    #####: 1316:    while ((*yyp = *yyformat) != '\0')
branch  0 never executed
branch  1 never executed
    #####: 1317:      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1318:        {
    #####: 1319:          yyp += yytnamerr (yyp, yyarg[yyi++]);
call    0 never executed
    #####: 1320:          yyformat += 2;
        -: 1321:        }
        -: 1322:      else
        -: 1323:        {
    #####: 1324:          yyp++;
    #####: 1325:          yyformat++;
        -: 1326:        }
        -: 1327:  }
        -: 1328:  return 0;
        -: 1329:}
        -: 1330:#endif /* YYERROR_VERBOSE */
        -: 1331:
        -: 1332:/*-----------------------------------------------.
        -: 1333:| Release the memory associated to this symbol.  |
        -: 1334:`-----------------------------------------------*/
        -: 1335:
        -: 1336:static void
function yydestruct.isra.0 called 8 returned 100% blocks executed 12%
        8: 1337:yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1338:{
        -: 1339:  YYUSE (yyvaluep);
        -: 1340:  YYUSE (yyscanner);
        -: 1341:  YYUSE (compiler);
        -: 1342:  if (!yymsg)
        -: 1343:    yymsg = "Deleting";
        -: 1344:  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
        -: 1345:
        -: 1346:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        8: 1347:  switch (yytype)
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
branch 11 taken 8
        -: 1348:    {
    #####: 1349:          case 10: /* _IDENTIFIER_  */
        -: 1350:#line 205 "grammar.y" /* yacc.c:1257  */
        -: 1351:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1352:#line 1353 "grammar.c" /* yacc.c:1257  */
        -: 1353:        break;
        -: 1354:
    #####: 1355:    case 11: /* _STRING_IDENTIFIER_  */
        -: 1356:#line 209 "grammar.y" /* yacc.c:1257  */
        -: 1357:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1358:#line 1359 "grammar.c" /* yacc.c:1257  */
        -: 1359:        break;
        -: 1360:
    #####: 1361:    case 12: /* _STRING_COUNT_  */
        -: 1362:#line 206 "grammar.y" /* yacc.c:1257  */
        -: 1363:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1364:#line 1365 "grammar.c" /* yacc.c:1257  */
        -: 1365:        break;
        -: 1366:
    #####: 1367:    case 13: /* _STRING_OFFSET_  */
        -: 1368:#line 207 "grammar.y" /* yacc.c:1257  */
        -: 1369:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1370:#line 1371 "grammar.c" /* yacc.c:1257  */
        -: 1371:        break;
        -: 1372:
    #####: 1373:    case 14: /* _STRING_LENGTH_  */
        -: 1374:#line 208 "grammar.y" /* yacc.c:1257  */
        -: 1375:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1376:#line 1377 "grammar.c" /* yacc.c:1257  */
        -: 1377:        break;
        -: 1378:
    #####: 1379:    case 15: /* _STRING_IDENTIFIER_WITH_WILDCARD_  */
        -: 1380:#line 210 "grammar.y" /* yacc.c:1257  */
        -: 1381:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1382:#line 1383 "grammar.c" /* yacc.c:1257  */
        -: 1383:        break;
        -: 1384:
    #####: 1385:    case 19: /* _TEXT_STRING_  */
        -: 1386:#line 211 "grammar.y" /* yacc.c:1257  */
        -: 1387:      { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1388:#line 1389 "grammar.c" /* yacc.c:1257  */
        -: 1389:        break;
        -: 1390:
    #####: 1391:    case 20: /* _HEX_STRING_  */
        -: 1392:#line 212 "grammar.y" /* yacc.c:1257  */
        -: 1393:      { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1394:#line 1395 "grammar.c" /* yacc.c:1257  */
        -: 1395:        break;
        -: 1396:
    #####: 1397:    case 21: /* _REGEXP_  */
        -: 1398:#line 213 "grammar.y" /* yacc.c:1257  */
        -: 1399:      { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1400:#line 1401 "grammar.c" /* yacc.c:1257  */
        -: 1401:        break;
        -: 1402:
    #####: 1403:    case 95: /* arguments  */
        -: 1404:#line 215 "grammar.y" /* yacc.c:1257  */
        -: 1405:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1406:#line 1407 "grammar.c" /* yacc.c:1257  */
        -: 1407:        break;
        -: 1408:
    #####: 1409:    case 96: /* arguments_list  */
        -: 1410:#line 216 "grammar.y" /* yacc.c:1257  */
        -: 1411:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1412:#line 1413 "grammar.c" /* yacc.c:1257  */
        -: 1413:        break;
        -: 1414:
        -: 1415:
        -: 1416:      default:
        -: 1417:        break;
        -: 1418:    }
        -: 1419:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        8: 1420:}
        -: 1421:
        -: 1422:
        -: 1423:
        -: 1424:
        -: 1425:/*----------.
        -: 1426:| yyparse.  |
        -: 1427:`----------*/
        -: 1428:
        -: 1429:int
function yara_yyparse called 4 returned 100% blocks executed 8%
        4: 1430:yyparse (void *yyscanner, YR_COMPILER* compiler)
        -: 1431:{
        -: 1432:/* The lookahead symbol.  */
        -: 1433:int yychar;
        -: 1434:
        -: 1435:
        -: 1436:/* The semantic value of the lookahead symbol.  */
        -: 1437:/* Default value used for initialization, for pacifying older GCCs
        -: 1438:   or non-GCC compilers.  */
        -: 1439:YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
        -: 1440:YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
        -: 1441:
        -: 1442:    /* Number of syntax errors so far.  */
        -: 1443:    int yynerrs;
        -: 1444:
        -: 1445:    int yystate;
        -: 1446:    /* Number of tokens to shift before error messages enabled.  */
        -: 1447:    int yyerrstatus;
        -: 1448:
        -: 1449:    /* The stacks and their tools:
        -: 1450:       'yyss': related to states.
        -: 1451:       'yyvs': related to semantic values.
        -: 1452:
        -: 1453:       Refer to the stacks through separate pointers, to allow yyoverflow
        -: 1454:       to reallocate them elsewhere.  */
        -: 1455:
        -: 1456:    /* The state stack.  */
        -: 1457:    yytype_int16 yyssa[YYINITDEPTH];
        -: 1458:    yytype_int16 *yyss;
        -: 1459:    yytype_int16 *yyssp;
        -: 1460:
        -: 1461:    /* The semantic value stack.  */
        -: 1462:    YYSTYPE yyvsa[YYINITDEPTH];
        -: 1463:    YYSTYPE *yyvs;
        -: 1464:    YYSTYPE *yyvsp;
        -: 1465:
        -: 1466:    YYSIZE_T yystacksize;
        -: 1467:
        -: 1468:  int yyn;
        -: 1469:  int yyresult;
        -: 1470:  /* Lookahead token as an internal (translated) token number.  */
        -: 1471:  int yytoken = 0;
        -: 1472:  /* The variables used to return semantic value and location from the
        -: 1473:     action routines.  */
        -: 1474:  YYSTYPE yyval;
        -: 1475:
        -: 1476:#if YYERROR_VERBOSE
        -: 1477:  /* Buffer for error messages, and its allocated size.  */
        -: 1478:  char yymsgbuf[128];
        4: 1479:  char *yymsg = yymsgbuf;
        4: 1480:  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
        -: 1481:#endif
        -: 1482:
        -: 1483:#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
        -: 1484:
        -: 1485:  /* The number of symbols on the RHS of the reduced rule.
        -: 1486:     Keep to zero when no symbol should be popped.  */
        -: 1487:  int yylen = 0;
        -: 1488:
        -: 1489:  yyssp = yyss = yyssa;
        -: 1490:  yyvsp = yyvs = yyvsa;
        -: 1491:  yystacksize = YYINITDEPTH;
        -: 1492:
        -: 1493:  YYDPRINTF ((stderr, "Starting parse\n"));
        -: 1494:
        -: 1495:  yystate = 0;
        -: 1496:  yyerrstatus = 0;
        -: 1497:  yynerrs = 0;
        -: 1498:  yychar = YYEMPTY; /* Cause a token to be read.  */
        4: 1499:  goto yysetstate;
        -: 1500:
        -: 1501:/*------------------------------------------------------------.
        -: 1502:| yynewstate -- Push a new state, which is found in yystate.  |
        -: 1503:`------------------------------------------------------------*/
      216: 1504: yynewstate:
        -: 1505:  /* In all cases, when you get here, the value and location stacks
        -: 1506:     have just been pushed.  So pushing a state here evens the stacks.  */
      216: 1507:  yyssp++;
        -: 1508:
      220: 1509: yysetstate:
      220: 1510:  *yyssp = yystate;
        -: 1511:
      220: 1512:  if (yyss + yystacksize - 1 <= yyssp)
branch  0 taken 0 (fallthrough)
branch  1 taken 220
        -: 1513:    {
        -: 1514:      /* Get the current used size of the three stacks, in elements.  */
    #####: 1515:      YYSIZE_T yysize = yyssp - yyss + 1;
        -: 1516:
        -: 1517:#ifdef yyoverflow
        -: 1518:      {
        -: 1519:        /* Give user a chance to reallocate the stack.  Use copies of
        -: 1520:           these so that the &'s don't force the real ones into
        -: 1521:           memory.  */
        -: 1522:        YYSTYPE *yyvs1 = yyvs;
        -: 1523:        yytype_int16 *yyss1 = yyss;
        -: 1524:
        -: 1525:        /* Each stack pointer address is followed by the size of the
        -: 1526:           data in use in that stack, in bytes.  This used to be a
        -: 1527:           conditional around just the two extra args, but that might
        -: 1528:           be undefined if yyoverflow is a macro.  */
        -: 1529:        yyoverflow (YY_("memory exhausted"),
        -: 1530:                    &yyss1, yysize * sizeof (*yyssp),
        -: 1531:                    &yyvs1, yysize * sizeof (*yyvsp),
        -: 1532:                    &yystacksize);
        -: 1533:
        -: 1534:        yyss = yyss1;
        -: 1535:        yyvs = yyvs1;
        -: 1536:      }
        -: 1537:#else /* no yyoverflow */
        -: 1538:# ifndef YYSTACK_RELOCATE
        -: 1539:      goto yyexhaustedlab;
        -: 1540:# else
        -: 1541:      /* Extend the stack our own way.  */
    #####: 1542:      if (YYMAXDEPTH <= yystacksize)
branch  0 never executed
branch  1 never executed
        -: 1543:        goto yyexhaustedlab;
        -: 1544:      yystacksize *= 2;
    #####: 1545:      if (YYMAXDEPTH < yystacksize)
branch  0 never executed
branch  1 never executed
        -: 1546:        yystacksize = YYMAXDEPTH;
        -: 1547:
        -: 1548:      {
        -: 1549:        yytype_int16 *yyss1 = yyss;
    #####: 1550:        union yyalloc *yyptr =
call    0 never executed
    #####: 1551:          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
    #####: 1552:        if (! yyptr)
branch  0 never executed
branch  1 never executed
        -: 1553:          goto yyexhaustedlab;
    #####: 1554:        YYSTACK_RELOCATE (yyss_alloc, yyss);
    #####: 1555:        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
        -: 1556:#  undef YYSTACK_RELOCATE
    #####: 1557:        if (yyss1 != yyssa)
branch  0 never executed
branch  1 never executed
    #####: 1558:          YYSTACK_FREE (yyss1);
call    0 never executed
        -: 1559:      }
        -: 1560:# endif
        -: 1561:#endif /* no yyoverflow */
        -: 1562:
    #####: 1563:      yyssp = yyss + yysize - 1;
    #####: 1564:      yyvsp = yyvs + yysize - 1;
        -: 1565:
        -: 1566:      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
        -: 1567:                  (unsigned long int) yystacksize));
        -: 1568:
    #####: 1569:      if (yyss + yystacksize - 1 <= yyssp)
branch  0 never executed
branch  1 never executed
        -: 1570:        YYABORT;
        -: 1571:    }
        -: 1572:
        -: 1573:  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
        -: 1574:
      220: 1575:  if (yystate == YYFINAL)
branch  0 taken 4 (fallthrough)
branch  1 taken 216
        -: 1576:    YYACCEPT;
        -: 1577:
        -: 1578:  goto yybackup;
        -: 1579:
        -: 1580:/*-----------.
        -: 1581:| yybackup.  |
        -: 1582:`-----------*/
      216: 1583:yybackup:
        -: 1584:
        -: 1585:  /* Do appropriate processing given the current state.  Read a
        -: 1586:     lookahead token if we need one and don't already have one.  */
        -: 1587:
        -: 1588:  /* First try to decide what to do without reference to lookahead token.  */
      216: 1589:  yyn = yypact[yystate];
      216: 1590:  if (yypact_value_is_default (yyn))
branch  0 taken 148 (fallthrough)
branch  1 taken 68
        -: 1591:    goto yydefault;
        -: 1592:
        -: 1593:  /* Not known => get a lookahead token if don't already have one.  */
        -: 1594:
        -: 1595:  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
      148: 1596:  if (yychar == YYEMPTY)
branch  0 taken 96 (fallthrough)
branch  1 taken 52
        -: 1597:    {
        -: 1598:      YYDPRINTF ((stderr, "Reading a token: "));
       96: 1599:      yychar = yylex (&yylval, yyscanner, compiler);
call    0 returned 96
        -: 1600:    }
        -: 1601:
      148: 1602:  if (yychar <= YYEOF)
branch  0 taken 144 (fallthrough)
branch  1 taken 4
        -: 1603:    {
        -: 1604:      yychar = yytoken = YYEOF;
        -: 1605:      YYDPRINTF ((stderr, "Now at end of input.\n"));
        -: 1606:    }
        -: 1607:  else
        -: 1608:    {
      144: 1609:      yytoken = YYTRANSLATE (yychar);
branch  0 taken 144 (fallthrough)
branch  1 taken 0
        -: 1610:      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
        -: 1611:    }
        -: 1612:
        -: 1613:  /* If the proper action on seeing token YYTOKEN is to reduce or to
        -: 1614:     detect an error, take that action.  */
      148: 1615:  yyn += yytoken;
      296: 1616:  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
branch  0 taken 0 (fallthrough)
branch  1 taken 148
branch  2 taken 47 (fallthrough)
branch  3 taken 101
        -: 1617:    goto yydefault;
      101: 1618:  yyn = yytable[yyn];
      101: 1619:  if (yyn <= 0)
branch  0 taken 5 (fallthrough)
branch  1 taken 96
        -: 1620:    {
        -: 1621:      if (yytable_value_is_error (yyn))
        -: 1622:        goto yyerrlab;
        5: 1623:      yyn = -yyn;
        5: 1624:      goto yyreduce;
        -: 1625:    }
        -: 1626:
        -: 1627:  /* Count tokens shifted since error; after three, turn off error
        -: 1628:     status.  */
       96: 1629:  if (yyerrstatus)
branch  0 taken 0 (fallthrough)
branch  1 taken 96
    #####: 1630:    yyerrstatus--;
        -: 1631:
        -: 1632:  /* Shift the lookahead token.  */
        -: 1633:  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
        -: 1634:
        -: 1635:  /* Discard the shifted token.  */
        -: 1636:  yychar = YYEMPTY;
        -: 1637:
        -: 1638:  yystate = yyn;
        -: 1639:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
       96: 1640:  *++yyvsp = yylval;
        -: 1641:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1642:
       96: 1643:  goto yynewstate;
        -: 1644:
        -: 1645:
        -: 1646:/*-----------------------------------------------------------.
        -: 1647:| yydefault -- do the default action for the current state.  |
        -: 1648:`-----------------------------------------------------------*/
      115: 1649:yydefault:
      115: 1650:  yyn = yydefact[yystate];
      115: 1651:  if (yyn == 0)
branch  0 taken 115 (fallthrough)
branch  1 taken 0
        -: 1652:    goto yyerrlab;
        -: 1653:  goto yyreduce;
        -: 1654:
        -: 1655:
        -: 1656:/*-----------------------------.
        -: 1657:| yyreduce -- Do a reduction.  |
        -: 1658:`-----------------------------*/
      120: 1659:yyreduce:
        -: 1660:  /* yyn is the number of a rule to reduce with.  */
      120: 1661:  yylen = yyr2[yyn];
        -: 1662:
        -: 1663:  /* If YYLEN is nonzero, implement the default value of the action:
        -: 1664:     '$$ = $1'.
        -: 1665:
        -: 1666:     Otherwise, the following line sets YYVAL to garbage.
        -: 1667:     This behavior is undocumented and Bison
        -: 1668:     users should not rely upon it.  Assigning to YYVAL
        -: 1669:     unconditionally makes the parser a bit smaller, and it avoids a
        -: 1670:     GCC warning that YYVAL may be used uninitialized.  */
      120: 1671:  yyval = yyvsp[1-yylen];
        -: 1672:
        -: 1673:
        -: 1674:  YY_REDUCE_PRINT (yyn);
      120: 1675:  switch (yyn)
branch  0 taken 0
branch  1 taken 4
branch  2 taken 4
branch  3 taken 4
branch  4 taken 4
branch  5 taken 0
branch  6 taken 0
branch  7 taken 4
branch  8 taken 4
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
branch 12 taken 4
branch 13 taken 0
branch 14 taken 0
branch 15 taken 0
branch 16 taken 0
branch 17 taken 0
branch 18 taken 0
branch 19 taken 0
branch 20 taken 0
branch 21 taken 0
branch 22 taken 0
branch 23 taken 4
branch 24 taken 12
branch 25 taken 15
branch 26 taken 15
branch 27 taken 1
branch 28 taken 1
branch 29 taken 0
branch 30 taken 16
branch 31 taken 0
branch 32 taken 0
branch 33 taken 0
branch 34 taken 0
branch 35 taken 0
branch 36 taken 0
branch 37 taken 0
branch 38 taken 0
branch 39 taken 0
branch 40 taken 0
branch 41 taken 0
branch 42 taken 0
branch 43 taken 0
branch 44 taken 0
branch 45 taken 0
branch 46 taken 4
branch 47 taken 0
branch 48 taken 0
branch 49 taken 0
branch 50 taken 0
branch 51 taken 0
branch 52 taken 0
branch 53 taken 0
branch 54 taken 0
branch 55 taken 0
branch 56 taken 0
branch 57 taken 0
branch 58 taken 0
branch 59 taken 0
branch 60 taken 4
branch 61 taken 0
branch 62 taken 0
branch 63 taken 0
branch 64 taken 0
branch 65 taken 0
branch 66 taken 0
branch 67 taken 0
branch 68 taken 0
branch 69 taken 0
branch 70 taken 0
branch 71 taken 0
branch 72 taken 0
branch 73 taken 0
branch 74 taken 0
branch 75 taken 0
branch 76 taken 0
branch 77 taken 0
branch 78 taken 0
branch 79 taken 0
branch 80 taken 4
branch 81 taken 0
branch 82 taken 0
branch 83 taken 4
branch 84 taken 0
branch 85 taken 0
branch 86 taken 0
branch 87 taken 0
branch 88 taken 0
branch 89 taken 0
branch 90 taken 0
branch 91 taken 0
branch 92 taken 0
branch 93 taken 0
branch 94 taken 0
branch 95 taken 0
branch 96 taken 0
branch 97 taken 0
branch 98 taken 0
branch 99 taken 0
branch 100 taken 0
branch 101 taken 0
branch 102 taken 0
branch 103 taken 0
branch 104 taken 0
branch 105 taken 0
branch 106 taken 0
branch 107 taken 0
branch 108 taken 0
branch 109 taken 0
branch 110 taken 0
branch 111 taken 12
        -: 1676:    {
    #####: 1677:        case 8:
        -: 1678:#line 244 "grammar.y" /* yacc.c:1646  */
        -: 1679:    {
        -: 1680:        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));
        -: 1681:
        -: 1682:        yr_free((yyvsp[0].sized_string));
        -: 1683:
        -: 1684:        fail_if_error(result);
        -: 1685:      }
        -: 1686:#line 1687 "grammar.c" /* yacc.c:1646  */
        -: 1687:    break;
        -: 1688:
        4: 1689:  case 9:
        -: 1690:#line 256 "grammar.y" /* yacc.c:1646  */
        -: 1691:    {
        -: 1692:        fail_if_error(yr_parser_reduce_rule_declaration_phase_1(
        -: 1693:            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string), &(yyval.rule)));
        -: 1694:      }
        -: 1695:#line 1696 "grammar.c" /* yacc.c:1646  */
        -: 1696:    break;
        -: 1697:
        4: 1698:  case 10:
        -: 1699:#line 261 "grammar.y" /* yacc.c:1646  */
        -: 1700:    {
        -: 1701:        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1
        -: 1702:
        -: 1703:        rule->tags = (yyvsp[-3].c_string);
        -: 1704:        rule->metas = (yyvsp[-1].meta);
        -: 1705:        rule->strings = (yyvsp[0].string);
        -: 1706:      }
        -: 1707:#line 1708 "grammar.c" /* yacc.c:1646  */
        4: 1708:    break;
        -: 1709:
        4: 1710:  case 11:
        -: 1711:#line 269 "grammar.y" /* yacc.c:1646  */
        -: 1712:    {
        -: 1713:        int result = yr_parser_reduce_rule_declaration_phase_2(
        -: 1714:            yyscanner, (yyvsp[-7].rule)); // rule created in phase 1
        -: 1715:
        -: 1716:        yr_free((yyvsp[-8].c_string));
        -: 1717:
        -: 1718:        fail_if_error(result);
        -: 1719:      }
        -: 1720:#line 1721 "grammar.c" /* yacc.c:1646  */
        -: 1721:    break;
        -: 1722:
        4: 1723:  case 12:
        -: 1724:#line 282 "grammar.y" /* yacc.c:1646  */
        -: 1725:    {
        -: 1726:        (yyval.meta) = NULL;
        -: 1727:      }
        -: 1728:#line 1729 "grammar.c" /* yacc.c:1646  */
        4: 1729:    break;
        -: 1730:
        -: 1731:  case 13:
        -: 1732:#line 286 "grammar.y" /* yacc.c:1646  */
        -: 1733:    {
        -: 1734:        // Each rule have a list of meta-data info, consisting in a
        -: 1735:        // sequence of YR_META structures. The last YR_META structure does
        -: 1736:        // not represent a real meta-data, it's just a end-of-list marker
        -: 1737:        // identified by a specific type (META_TYPE_NULL). Here we
        -: 1738:        // write the end-of-list marker.
        -: 1739:
        -: 1740:        YR_META null_meta;
        -: 1741:
        -: 1742:        memset(&null_meta, 0xFF, sizeof(YR_META));
        -: 1743:        null_meta.type = META_TYPE_NULL;
        -: 1744:
        -: 1745:        int result = yr_arena_write_data(
        -: 1746:            compiler->metas_arena,
        -: 1747:            &null_meta,
        -: 1748:            sizeof(YR_META),
        -: 1749:            NULL);
        -: 1750:
        -: 1751:        (yyval.meta) = (yyvsp[0].meta);
        -: 1752:
        -: 1753:        fail_if_error(result);
        -: 1754:      }
        -: 1755:#line 1756 "grammar.c" /* yacc.c:1646  */
    #####: 1756:    break;
        -: 1757:
    #####: 1758:  case 14:
        -: 1759:#line 313 "grammar.y" /* yacc.c:1646  */
        -: 1760:    {
        -: 1761:        (yyval.string) = NULL;
        -: 1762:      }
        -: 1763:#line 1764 "grammar.c" /* yacc.c:1646  */
    #####: 1764:    break;
        -: 1765:
        -: 1766:  case 15:
        -: 1767:#line 317 "grammar.y" /* yacc.c:1646  */
        -: 1768:    {
        -: 1769:        // Each rule have a list of strings, consisting in a sequence
        -: 1770:        // of YR_STRING structures. The last YR_STRING structure does not
        -: 1771:        // represent a real string, it's just a end-of-list marker
        -: 1772:        // identified by a specific flag (STRING_FLAGS_NULL). Here we
        -: 1773:        // write the end-of-list marker.
        -: 1774:
        -: 1775:        YR_STRING null_string;
        -: 1776:
        -: 1777:        memset(&null_string, 0xFF, sizeof(YR_STRING));
        -: 1778:        null_string.g_flags = STRING_GFLAGS_NULL;
        -: 1779:
        -: 1780:        fail_if_error(yr_arena_write_data(
        -: 1781:            compiler->strings_arena,
        -: 1782:            &null_string,
        -: 1783:            sizeof(YR_STRING),
        -: 1784:            NULL));
        -: 1785:
        -: 1786:        (yyval.string) = (yyvsp[0].string);
        -: 1787:      }
        -: 1788:#line 1789 "grammar.c" /* yacc.c:1646  */
        4: 1789:    break;
        -: 1790:
        4: 1791:  case 17:
        -: 1792:#line 346 "grammar.y" /* yacc.c:1646  */
        -: 1793:    { (yyval.integer) = 0;  }
        -: 1794:#line 1795 "grammar.c" /* yacc.c:1646  */
        4: 1795:    break;
        -: 1796:
    #####: 1797:  case 18:
        -: 1798:#line 347 "grammar.y" /* yacc.c:1646  */
        -: 1799:    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
        -: 1800:#line 1801 "grammar.c" /* yacc.c:1646  */
    #####: 1801:    break;
        -: 1802:
    #####: 1803:  case 19:
        -: 1804:#line 352 "grammar.y" /* yacc.c:1646  */
        -: 1805:    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
        -: 1806:#line 1807 "grammar.c" /* yacc.c:1646  */
    #####: 1807:    break;
        -: 1808:
    #####: 1809:  case 20:
        -: 1810:#line 353 "grammar.y" /* yacc.c:1646  */
        -: 1811:    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
        -: 1812:#line 1813 "grammar.c" /* yacc.c:1646  */
    #####: 1813:    break;
        -: 1814:
        4: 1815:  case 21:
        -: 1816:#line 359 "grammar.y" /* yacc.c:1646  */
        -: 1817:    {
        -: 1818:        (yyval.c_string) = NULL;
        -: 1819:      }
        -: 1820:#line 1821 "grammar.c" /* yacc.c:1646  */
        4: 1821:    break;
        -: 1822:
    #####: 1823:  case 22:
        -: 1824:#line 363 "grammar.y" /* yacc.c:1646  */
        -: 1825:    {
        -: 1826:        // Tags list is represented in the arena as a sequence
        -: 1827:        // of null-terminated strings, the sequence ends with an
        -: 1828:        // additional null character. Here we write the ending null
        -: 1829:        //character. Example: tag1\0tag2\0tag3\0\0
        -: 1830:
        -: 1831:        int result = yr_arena_write_string(
        -: 1832:            yyget_extra(yyscanner)->sz_arena, "", NULL);
        -: 1833:
        -: 1834:        fail_if_error(result);
        -: 1835:
        -: 1836:        (yyval.c_string) = (yyvsp[0].c_string);
        -: 1837:      }
        -: 1838:#line 1839 "grammar.c" /* yacc.c:1646  */
    #####: 1839:    break;
        -: 1840:
    #####: 1841:  case 23:
        -: 1842:#line 381 "grammar.y" /* yacc.c:1646  */
        -: 1843:    {
        -: 1844:        int result = yr_arena_write_string(
        -: 1845:            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &(yyval.c_string));
        -: 1846:
        -: 1847:        yr_free((yyvsp[0].c_string));
        -: 1848:
        -: 1849:        fail_if_error(result);
        -: 1850:      }
        -: 1851:#line 1852 "grammar.c" /* yacc.c:1646  */
        -: 1852:    break;
        -: 1853:
    #####: 1854:  case 24:
        -: 1855:#line 390 "grammar.y" /* yacc.c:1646  */
        -: 1856:    {
        -: 1857:        int result = ERROR_SUCCESS;
        -: 1858:
        -: 1859:        char* tag_name = (yyvsp[-1].c_string);
        -: 1860:        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -: 1861:
        -: 1862:        while (tag_length > 0)
        -: 1863:        {
        -: 1864:          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
        -: 1865:          {
        -: 1866:            yr_compiler_set_error_extra_info(compiler, tag_name);
        -: 1867:            result = ERROR_DUPLICATED_TAG_IDENTIFIER;
        -: 1868:            break;
        -: 1869:          }
        -: 1870:
        -: 1871:          tag_name = (char*) yr_arena_next_address(
        -: 1872:              yyget_extra(yyscanner)->sz_arena,
        -: 1873:              tag_name,
        -: 1874:              tag_length + 1);
        -: 1875:
        -: 1876:          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -: 1877:        }
        -: 1878:
        -: 1879:        if (result == ERROR_SUCCESS)
        -: 1880:          result = yr_arena_write_string(
        -: 1881:              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);
        -: 1882:
        -: 1883:        yr_free((yyvsp[0].c_string));
        -: 1884:
        -: 1885:        fail_if_error(result);
        -: 1886:
        -: 1887:        (yyval.c_string) = (yyvsp[-1].c_string);
        -: 1888:      }
        -: 1889:#line 1890 "grammar.c" /* yacc.c:1646  */
    #####: 1890:    break;
        -: 1891:
    #####: 1892:  case 25:
        -: 1893:#line 428 "grammar.y" /* yacc.c:1646  */
        -: 1894:    {  (yyval.meta) = (yyvsp[0].meta); }
        -: 1895:#line 1896 "grammar.c" /* yacc.c:1646  */
    #####: 1896:    break;
        -: 1897:
    #####: 1898:  case 26:
        -: 1899:#line 429 "grammar.y" /* yacc.c:1646  */
        -: 1900:    {  (yyval.meta) = (yyvsp[-1].meta); }
        -: 1901:#line 1902 "grammar.c" /* yacc.c:1646  */
    #####: 1902:    break;
        -: 1903:
    #####: 1904:  case 27:
        -: 1905:#line 435 "grammar.y" /* yacc.c:1646  */
        -: 1906:    {
        -: 1907:        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        -: 1908:
        -: 1909:        int result = yr_parser_reduce_meta_declaration(
        -: 1910:            yyscanner,
        -: 1911:            META_TYPE_STRING,
        -: 1912:            (yyvsp[-2].c_string),
        -: 1913:            sized_string->c_string,
        -: 1914:            0,
        -: 1915:            &(yyval.meta));
        -: 1916:
        -: 1917:        yr_free((yyvsp[-2].c_string));
        -: 1918:        yr_free((yyvsp[0].sized_string));
        -: 1919:
        -: 1920:        fail_if_error(result);
        -: 1921:      }
        -: 1922:#line 1923 "grammar.c" /* yacc.c:1646  */
        -: 1923:    break;
        -: 1924:
    #####: 1925:  case 28:
        -: 1926:#line 452 "grammar.y" /* yacc.c:1646  */
        -: 1927:    {
        -: 1928:        int result = yr_parser_reduce_meta_declaration(
        -: 1929:            yyscanner,
        -: 1930:            META_TYPE_INTEGER,
        -: 1931:            (yyvsp[-2].c_string),
        -: 1932:            NULL,
        -: 1933:            (yyvsp[0].integer),
        -: 1934:            &(yyval.meta));
        -: 1935:
        -: 1936:        yr_free((yyvsp[-2].c_string));
        -: 1937:
        -: 1938:        fail_if_error(result);
        -: 1939:      }
        -: 1940:#line 1941 "grammar.c" /* yacc.c:1646  */
        -: 1941:    break;
        -: 1942:
    #####: 1943:  case 29:
        -: 1944:#line 466 "grammar.y" /* yacc.c:1646  */
        -: 1945:    {
        -: 1946:        int result = yr_parser_reduce_meta_declaration(
        -: 1947:            yyscanner,
        -: 1948:            META_TYPE_INTEGER,
        -: 1949:            (yyvsp[-3].c_string),
        -: 1950:            NULL,
        -: 1951:            -(yyvsp[0].integer),
        -: 1952:            &(yyval.meta));
        -: 1953:
        -: 1954:        yr_free((yyvsp[-3].c_string));
        -: 1955:
        -: 1956:        fail_if_error(result);
        -: 1957:      }
        -: 1958:#line 1959 "grammar.c" /* yacc.c:1646  */
        -: 1959:    break;
        -: 1960:
    #####: 1961:  case 30:
        -: 1962:#line 480 "grammar.y" /* yacc.c:1646  */
        -: 1963:    {
        -: 1964:        int result = yr_parser_reduce_meta_declaration(
        -: 1965:            yyscanner,
        -: 1966:            META_TYPE_BOOLEAN,
        -: 1967:            (yyvsp[-2].c_string),
        -: 1968:            NULL,
        -: 1969:            true,
        -: 1970:            &(yyval.meta));
        -: 1971:
        -: 1972:        yr_free((yyvsp[-2].c_string));
        -: 1973:
        -: 1974:        fail_if_error(result);
        -: 1975:      }
        -: 1976:#line 1977 "grammar.c" /* yacc.c:1646  */
        -: 1977:    break;
        -: 1978:
    #####: 1979:  case 31:
        -: 1980:#line 494 "grammar.y" /* yacc.c:1646  */
        -: 1981:    {
        -: 1982:        int result = yr_parser_reduce_meta_declaration(
        -: 1983:            yyscanner,
        -: 1984:            META_TYPE_BOOLEAN,
        -: 1985:            (yyvsp[-2].c_string),
        -: 1986:            NULL,
        -: 1987:            false,
        -: 1988:            &(yyval.meta));
        -: 1989:
        -: 1990:        yr_free((yyvsp[-2].c_string));
        -: 1991:
        -: 1992:        fail_if_error(result);
        -: 1993:      }
        -: 1994:#line 1995 "grammar.c" /* yacc.c:1646  */
        -: 1995:    break;
        -: 1996:
        4: 1997:  case 32:
        -: 1998:#line 511 "grammar.y" /* yacc.c:1646  */
        -: 1999:    { (yyval.string) = (yyvsp[0].string); }
        -: 2000:#line 2001 "grammar.c" /* yacc.c:1646  */
        4: 2001:    break;
        -: 2002:
       12: 2003:  case 33:
        -: 2004:#line 512 "grammar.y" /* yacc.c:1646  */
        -: 2005:    { (yyval.string) = (yyvsp[-1].string); }
        -: 2006:#line 2007 "grammar.c" /* yacc.c:1646  */
       12: 2007:    break;
        -: 2008:
       15: 2009:  case 34:
        -: 2010:#line 518 "grammar.y" /* yacc.c:1646  */
        -: 2011:    {
        -: 2012:        compiler->current_line = yyget_lineno(yyscanner);
        -: 2013:      }
        -: 2014:#line 2015 "grammar.c" /* yacc.c:1646  */
       15: 2015:    break;
        -: 2016:
       15: 2017:  case 35:
        -: 2018:#line 522 "grammar.y" /* yacc.c:1646  */
        -: 2019:    {
        -: 2020:        int result = yr_parser_reduce_string_declaration(
        -: 2021:            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));
        -: 2022:
        -: 2023:        yr_free((yyvsp[-4].c_string));
        -: 2024:        yr_free((yyvsp[-1].sized_string));
        -: 2025:
        -: 2026:        fail_if_error(result);
        -: 2027:        compiler->current_line = 0;
        -: 2028:      }
        -: 2029:#line 2030 "grammar.c" /* yacc.c:1646  */
       15: 2030:    break;
        -: 2031:
        1: 2032:  case 36:
        -: 2033:#line 533 "grammar.y" /* yacc.c:1646  */
        -: 2034:    {
        -: 2035:        compiler->current_line = yyget_lineno(yyscanner);
        -: 2036:      }
        -: 2037:#line 2038 "grammar.c" /* yacc.c:1646  */
        1: 2038:    break;
        -: 2039:
        1: 2040:  case 37:
        -: 2041:#line 537 "grammar.y" /* yacc.c:1646  */
        -: 2042:    {
        -: 2043:        int result = yr_parser_reduce_string_declaration(
        -: 2044:            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));
        -: 2045:
        -: 2046:        yr_free((yyvsp[-4].c_string));
        -: 2047:        yr_free((yyvsp[-1].sized_string));
        -: 2048:
        -: 2049:        fail_if_error(result);
        -: 2050:
        -: 2051:        compiler->current_line = 0;
        -: 2052:      }
        -: 2053:#line 2054 "grammar.c" /* yacc.c:1646  */
        1: 2054:    break;
        -: 2055:
    #####: 2056:  case 38:
        -: 2057:#line 549 "grammar.y" /* yacc.c:1646  */
        -: 2058:    {
        -: 2059:        int result = yr_parser_reduce_string_declaration(
        -: 2060:            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string), &(yyval.string));
        -: 2061:
        -: 2062:        yr_free((yyvsp[-2].c_string));
        -: 2063:        yr_free((yyvsp[0].sized_string));
        -: 2064:
        -: 2065:        fail_if_error(result);
        -: 2066:      }
        -: 2067:#line 2068 "grammar.c" /* yacc.c:1646  */
        -: 2068:    break;
        -: 2069:
       16: 2070:  case 39:
        -: 2071:#line 562 "grammar.y" /* yacc.c:1646  */
        -: 2072:    { (yyval.integer) = 0; }
        -: 2073:#line 2074 "grammar.c" /* yacc.c:1646  */
       16: 2074:    break;
        -: 2075:
    #####: 2076:  case 40:
        -: 2077:#line 563 "grammar.y" /* yacc.c:1646  */
        -: 2078:    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
        -: 2079:#line 2080 "grammar.c" /* yacc.c:1646  */
    #####: 2080:    break;
        -: 2081:
    #####: 2082:  case 41:
        -: 2083:#line 568 "grammar.y" /* yacc.c:1646  */
        -: 2084:    { (yyval.integer) = STRING_GFLAGS_WIDE; }
        -: 2085:#line 2086 "grammar.c" /* yacc.c:1646  */
    #####: 2086:    break;
        -: 2087:
    #####: 2088:  case 42:
        -: 2089:#line 569 "grammar.y" /* yacc.c:1646  */
        -: 2090:    { (yyval.integer) = STRING_GFLAGS_ASCII; }
        -: 2091:#line 2092 "grammar.c" /* yacc.c:1646  */
    #####: 2092:    break;
        -: 2093:
    #####: 2094:  case 43:
        -: 2095:#line 570 "grammar.y" /* yacc.c:1646  */
        -: 2096:    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
        -: 2097:#line 2098 "grammar.c" /* yacc.c:1646  */
    #####: 2098:    break;
        -: 2099:
    #####: 2100:  case 44:
        -: 2101:#line 571 "grammar.y" /* yacc.c:1646  */
        -: 2102:    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
        -: 2103:#line 2104 "grammar.c" /* yacc.c:1646  */
    #####: 2104:    break;
        -: 2105:
    #####: 2106:  case 45:
        -: 2107:#line 572 "grammar.y" /* yacc.c:1646  */
        -: 2108:    { (yyval.integer) = STRING_GFLAGS_XOR; }
        -: 2109:#line 2110 "grammar.c" /* yacc.c:1646  */
    #####: 2110:    break;
        -: 2111:
    #####: 2112:  case 46:
        -: 2113:#line 578 "grammar.y" /* yacc.c:1646  */
        -: 2114:    {
        -: 2115:        int result = ERROR_SUCCESS;
        -: 2116:        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));
        -: 2117:
        -: 2118:        if (var_index >= 0)
        -: 2119:        {
        -: 2120:          result = yr_parser_emit_with_arg(
        -: 2121:              yyscanner,
        -: 2122:              OP_PUSH_M,
        -: 2123:              LOOP_LOCAL_VARS * var_index,
        -: 2124:              NULL,
        -: 2125:              NULL);
        -: 2126:
        -: 2127:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 2128:          (yyval.expression).value.integer = UNDEFINED;
        -: 2129:          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        -: 2130:        }
        -: 2131:        else
        -: 2132:        {
        -: 2133:          // Search for identifier within the global namespace, where the
        -: 2134:          // externals variables reside.
        -: 2135:
        -: 2136:          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
        -: 2137:              compiler->objects_table, (yyvsp[0].c_string), NULL);
        -: 2138:
        -: 2139:          if (object == NULL)
        -: 2140:          {
        -: 2141:            // If not found, search within the current namespace.
        -: 2142:            char* ns = compiler->current_namespace->name;
        -: 2143:
        -: 2144:            object = (YR_OBJECT*) yr_hash_table_lookup(
        -: 2145:                compiler->objects_table, (yyvsp[0].c_string), ns);
        -: 2146:          }
        -: 2147:
        -: 2148:          if (object != NULL)
        -: 2149:          {
        -: 2150:            char* id;
        -: 2151:
        -: 2152:            result = yr_arena_write_string(
        -: 2153:                compiler->sz_arena, (yyvsp[0].c_string), &id);
        -: 2154:
        -: 2155:            if (result == ERROR_SUCCESS)
        -: 2156:              result = yr_parser_emit_with_arg_reloc(
        -: 2157:                  yyscanner,
        -: 2158:                  OP_OBJ_LOAD,
        -: 2159:                  id,
        -: 2160:                  NULL,
        -: 2161:                  NULL);
        -: 2162:
        -: 2163:            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2164:            (yyval.expression).value.object = object;
        -: 2165:            (yyval.expression).identifier = object->identifier;
        -: 2166:          }
        -: 2167:          else
        -: 2168:          {
        -: 2169:            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
        -: 2170:                compiler->rules_table,
        -: 2171:                (yyvsp[0].c_string),
        -: 2172:                compiler->current_namespace->name);
        -: 2173:
        -: 2174:            if (rule != NULL)
        -: 2175:            {
        -: 2176:              result = yr_parser_emit_with_arg_reloc(
        -: 2177:                  yyscanner,
        -: 2178:                  OP_PUSH_RULE,
        -: 2179:                  rule,
        -: 2180:                  NULL,
        -: 2181:                  NULL);
        -: 2182:
        -: 2183:              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2184:              (yyval.expression).value.integer = UNDEFINED;
        -: 2185:              (yyval.expression).identifier = rule->identifier;
        -: 2186:            }
        -: 2187:            else
        -: 2188:            {
        -: 2189:              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
        -: 2190:              result = ERROR_UNDEFINED_IDENTIFIER;
        -: 2191:            }
        -: 2192:          }
        -: 2193:        }
        -: 2194:
        -: 2195:        yr_free((yyvsp[0].c_string));
        -: 2196:
        -: 2197:        fail_if_error(result);
        -: 2198:      }
        -: 2199:#line 2200 "grammar.c" /* yacc.c:1646  */
        -: 2200:    break;
        -: 2201:
    #####: 2202:  case 47:
        -: 2203:#line 664 "grammar.y" /* yacc.c:1646  */
        -: 2204:    {
        -: 2205:        int result = ERROR_SUCCESS;
        -: 2206:        YR_OBJECT* field = NULL;
        -: 2207:
        -: 2208:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2209:            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        -: 2210:        {
        -: 2211:          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));
        -: 2212:
        -: 2213:          if (field != NULL)
        -: 2214:          {
        -: 2215:            char* ident;
        -: 2216:
        -: 2217:            result = yr_arena_write_string(
        -: 2218:                compiler->sz_arena, (yyvsp[0].c_string), &ident);
        -: 2219:
        -: 2220:            if (result == ERROR_SUCCESS)
        -: 2221:              result = yr_parser_emit_with_arg_reloc(
        -: 2222:                  yyscanner,
        -: 2223:                  OP_OBJ_FIELD,
        -: 2224:                  ident,
        -: 2225:                  NULL,
        -: 2226:                  NULL);
        -: 2227:
        -: 2228:            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2229:            (yyval.expression).value.object = field;
        -: 2230:            (yyval.expression).identifier = field->identifier;
        -: 2231:          }
        -: 2232:          else
        -: 2233:          {
        -: 2234:            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
        -: 2235:            result = ERROR_INVALID_FIELD_NAME;
        -: 2236:          }
        -: 2237:        }
        -: 2238:        else
        -: 2239:        {
        -: 2240:          yr_compiler_set_error_extra_info(
        -: 2241:              compiler, (yyvsp[-2].expression).identifier);
        -: 2242:
        -: 2243:          result = ERROR_NOT_A_STRUCTURE;
        -: 2244:        }
        -: 2245:
        -: 2246:        yr_free((yyvsp[0].c_string));
        -: 2247:
        -: 2248:        fail_if_error(result);
        -: 2249:      }
        -: 2250:#line 2251 "grammar.c" /* yacc.c:1646  */
        -: 2251:    break;
        -: 2252:
    #####: 2253:  case 48:
        -: 2254:#line 711 "grammar.y" /* yacc.c:1646  */
        -: 2255:    {
        -: 2256:        int result = ERROR_SUCCESS;
        -: 2257:        YR_OBJECT_ARRAY* array;
        -: 2258:        YR_OBJECT_DICTIONARY* dict;
        -: 2259:
        -: 2260:        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2261:            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        -: 2262:        {
        -: 2263:          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 2264:          {
        -: 2265:            yr_compiler_set_error_extra_info(
        -: 2266:                compiler, "array indexes must be of integer type");
        -: 2267:            result = ERROR_WRONG_TYPE;
        -: 2268:          }
        -: 2269:
        -: 2270:          fail_if_error(result);
        -: 2271:
        -: 2272:          result = yr_parser_emit(
        -: 2273:              yyscanner, OP_INDEX_ARRAY, NULL);
        -: 2274:
        -: 2275:          array = object_as_array((yyvsp[-3].expression).value.object);
        -: 2276:
        -: 2277:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2278:          (yyval.expression).value.object = array->prototype_item;
        -: 2279:          (yyval.expression).identifier = array->identifier;
        -: 2280:        }
        -: 2281:        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2282:                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        -: 2283:        {
        -: 2284:          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
        -: 2285:          {
        -: 2286:            yr_compiler_set_error_extra_info(
        -: 2287:                compiler, "dictionary keys must be of string type");
        -: 2288:            result = ERROR_WRONG_TYPE;
        -: 2289:          }
        -: 2290:
        -: 2291:          fail_if_error(result);
        -: 2292:
        -: 2293:          result = yr_parser_emit(
        -: 2294:              yyscanner, OP_LOOKUP_DICT, NULL);
        -: 2295:
        -: 2296:          dict = object_as_dictionary((yyvsp[-3].expression).value.object);
        -: 2297:
        -: 2298:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2299:          (yyval.expression).value.object = dict->prototype_item;
        -: 2300:          (yyval.expression).identifier = dict->identifier;
        -: 2301:        }
        -: 2302:        else
        -: 2303:        {
        -: 2304:          yr_compiler_set_error_extra_info(
        -: 2305:              compiler, (yyvsp[-3].expression).identifier);
        -: 2306:
        -: 2307:          result = ERROR_NOT_INDEXABLE;
        -: 2308:        }
        -: 2309:
        -: 2310:        fail_if_error(result);
        -: 2311:      }
        -: 2312:#line 2313 "grammar.c" /* yacc.c:1646  */
        -: 2313:    break;
        -: 2314:
    #####: 2315:  case 49:
        -: 2316:#line 770 "grammar.y" /* yacc.c:1646  */
        -: 2317:    {
        -: 2318:        int result = ERROR_SUCCESS;
        -: 2319:        YR_OBJECT_FUNCTION* function;
        -: 2320:        char* args_fmt;
        -: 2321:
        -: 2322:        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2323:            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        -: 2324:        {
        -: 2325:          result = yr_parser_check_types(
        -: 2326:              compiler, object_as_function((yyvsp[-3].expression).value.object), (yyvsp[-1].c_string));
        -: 2327:
        -: 2328:          if (result == ERROR_SUCCESS)
        -: 2329:            result = yr_arena_write_string(
        -: 2330:                compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);
        -: 2331:
        -: 2332:          if (result == ERROR_SUCCESS)
        -: 2333:            result = yr_parser_emit_with_arg_reloc(
        -: 2334:                yyscanner,
        -: 2335:                OP_CALL,
        -: 2336:                args_fmt,
        -: 2337:                NULL,
        -: 2338:                NULL);
        -: 2339:
        -: 2340:          function = object_as_function((yyvsp[-3].expression).value.object);
        -: 2341:
        -: 2342:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2343:          (yyval.expression).value.object = function->return_obj;
        -: 2344:          (yyval.expression).identifier = function->identifier;
        -: 2345:        }
        -: 2346:        else
        -: 2347:        {
        -: 2348:          yr_compiler_set_error_extra_info(
        -: 2349:              compiler, (yyvsp[-3].expression).identifier);
        -: 2350:
        -: 2351:          result = ERROR_NOT_A_FUNCTION;
        -: 2352:        }
        -: 2353:
        -: 2354:        yr_free((yyvsp[-1].c_string));
        -: 2355:
        -: 2356:        fail_if_error(result);
        -: 2357:      }
        -: 2358:#line 2359 "grammar.c" /* yacc.c:1646  */
    #####: 2359:    break;
        -: 2360:
    #####: 2361:  case 50:
        -: 2362:#line 815 "grammar.y" /* yacc.c:1646  */
        -: 2363:    { (yyval.c_string) = yr_strdup(""); }
        -: 2364:#line 2365 "grammar.c" /* yacc.c:1646  */
    #####: 2365:    break;
        -: 2366:
    #####: 2367:  case 51:
        -: 2368:#line 816 "grammar.y" /* yacc.c:1646  */
        -: 2369:    { (yyval.c_string) = (yyvsp[0].c_string); }
        -: 2370:#line 2371 "grammar.c" /* yacc.c:1646  */
    #####: 2371:    break;
        -: 2372:
    #####: 2373:  case 52:
        -: 2374:#line 821 "grammar.y" /* yacc.c:1646  */
        -: 2375:    {
        -: 2376:        (yyval.c_string) = (char*) yr_malloc(YR_MAX_FUNCTION_ARGS + 1);
        -: 2377:
        -: 2378:        if ((yyval.c_string) == NULL)
        -: 2379:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 2380:
        -: 2381:        switch((yyvsp[0].expression).type)
        -: 2382:        {
        -: 2383:          case EXPRESSION_TYPE_INTEGER:
        -: 2384:            strlcpy((yyval.c_string), "i", YR_MAX_FUNCTION_ARGS);
        -: 2385:            break;
        -: 2386:          case EXPRESSION_TYPE_FLOAT:
        -: 2387:            strlcpy((yyval.c_string), "f", YR_MAX_FUNCTION_ARGS);
        -: 2388:            break;
        -: 2389:          case EXPRESSION_TYPE_BOOLEAN:
        -: 2390:            strlcpy((yyval.c_string), "b", YR_MAX_FUNCTION_ARGS);
        -: 2391:            break;
        -: 2392:          case EXPRESSION_TYPE_STRING:
        -: 2393:            strlcpy((yyval.c_string), "s", YR_MAX_FUNCTION_ARGS);
        -: 2394:            break;
        -: 2395:          case EXPRESSION_TYPE_REGEXP:
        -: 2396:            strlcpy((yyval.c_string), "r", YR_MAX_FUNCTION_ARGS);
        -: 2397:            break;
        -: 2398:          default:
        -: 2399:            assert(false);
        -: 2400:        }
        -: 2401:      }
        -: 2402:#line 2403 "grammar.c" /* yacc.c:1646  */
        -: 2403:    break;
        -: 2404:
    #####: 2405:  case 53:
        -: 2406:#line 849 "grammar.y" /* yacc.c:1646  */
        -: 2407:    {
        -: 2408:        int result = ERROR_SUCCESS;
        -: 2409:
        -: 2410:        if (strlen((yyvsp[-2].c_string)) == YR_MAX_FUNCTION_ARGS)
        -: 2411:        {
        -: 2412:          result = ERROR_TOO_MANY_ARGUMENTS;
        -: 2413:        }
        -: 2414:        else
        -: 2415:        {
        -: 2416:          switch((yyvsp[0].expression).type)
        -: 2417:          {
        -: 2418:            case EXPRESSION_TYPE_INTEGER:
        -: 2419:              strlcat((yyvsp[-2].c_string), "i", YR_MAX_FUNCTION_ARGS);
        -: 2420:              break;
        -: 2421:            case EXPRESSION_TYPE_FLOAT:
        -: 2422:              strlcat((yyvsp[-2].c_string), "f", YR_MAX_FUNCTION_ARGS);
        -: 2423:              break;
        -: 2424:            case EXPRESSION_TYPE_BOOLEAN:
        -: 2425:              strlcat((yyvsp[-2].c_string), "b", YR_MAX_FUNCTION_ARGS);
        -: 2426:              break;
        -: 2427:            case EXPRESSION_TYPE_STRING:
        -: 2428:              strlcat((yyvsp[-2].c_string), "s", YR_MAX_FUNCTION_ARGS);
        -: 2429:              break;
        -: 2430:            case EXPRESSION_TYPE_REGEXP:
        -: 2431:              strlcat((yyvsp[-2].c_string), "r", YR_MAX_FUNCTION_ARGS);
        -: 2432:              break;
        -: 2433:            default:
        -: 2434:              assert(false);
        -: 2435:          }
        -: 2436:        }
        -: 2437:
        -: 2438:        fail_if_error(result);
        -: 2439:
        -: 2440:        (yyval.c_string) = (yyvsp[-2].c_string);
        -: 2441:      }
        -: 2442:#line 2443 "grammar.c" /* yacc.c:1646  */
    #####: 2443:    break;
        -: 2444:
    #####: 2445:  case 54:
        -: 2446:#line 889 "grammar.y" /* yacc.c:1646  */
        -: 2447:    {
        -: 2448:        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        -: 2449:        RE* re;
        -: 2450:        RE_ERROR error;
        -: 2451:
        -: 2452:        int result = ERROR_SUCCESS;
        -: 2453:        int re_flags = 0;
        -: 2454:
        -: 2455:        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
        -: 2456:          re_flags |= RE_FLAGS_NO_CASE;
        -: 2457:
        -: 2458:        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
        -: 2459:          re_flags |= RE_FLAGS_DOT_ALL;
        -: 2460:
        -: 2461:        result = yr_re_compile(
        -: 2462:            sized_string->c_string,
        -: 2463:            re_flags,
        -: 2464:            compiler->re_code_arena,
        -: 2465:            &re,
        -: 2466:            &error);
        -: 2467:
        -: 2468:        yr_free((yyvsp[0].sized_string));
        -: 2469:
        -: 2470:        if (result == ERROR_INVALID_REGULAR_EXPRESSION)
        -: 2471:          yr_compiler_set_error_extra_info(compiler, error.message);
        -: 2472:
        -: 2473:        if (result == ERROR_SUCCESS)
        -: 2474:          result = yr_parser_emit_with_arg_reloc(
        -: 2475:              yyscanner,
        -: 2476:              OP_PUSH,
        -: 2477:              re,
        -: 2478:              NULL,
        -: 2479:              NULL);
        -: 2480:
        -: 2481:        fail_if_error(result);
        -: 2482:
        -: 2483:        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
        -: 2484:      }
        -: 2485:#line 2486 "grammar.c" /* yacc.c:1646  */
    #####: 2486:    break;
        -: 2487:
        4: 2488:  case 55:
        -: 2489:#line 932 "grammar.y" /* yacc.c:1646  */
        -: 2490:    {
        -: 2491:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        -: 2492:        {
        -: 2493:          if ((yyvsp[0].expression).value.sized_string != NULL)
        -: 2494:          {
        -: 2495:            yywarning(yyscanner,
        -: 2496:              "Using literal string \"%s\" in a boolean operation.",
        -: 2497:              (yyvsp[0].expression).value.sized_string->c_string);
        -: 2498:          }
        -: 2499:
        -: 2500:          fail_if_error(yr_parser_emit(
        -: 2501:              yyscanner, OP_STR_TO_BOOL, NULL));
        -: 2502:        }
        -: 2503:
        -: 2504:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2505:      }
        -: 2506:#line 2507 "grammar.c" /* yacc.c:1646  */
        4: 2507:    break;
        -: 2508:
    #####: 2509:  case 56:
        -: 2510:#line 952 "grammar.y" /* yacc.c:1646  */
        -: 2511:    {
        -: 2512:        fail_if_error(yr_parser_emit_with_arg(
        -: 2513:            yyscanner, OP_PUSH, 1, NULL, NULL));
        -: 2514:
        -: 2515:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2516:      }
        -: 2517:#line 2518 "grammar.c" /* yacc.c:1646  */
    #####: 2518:    break;
        -: 2519:
    #####: 2520:  case 57:
        -: 2521:#line 959 "grammar.y" /* yacc.c:1646  */
        -: 2522:    {
        -: 2523:        fail_if_error(yr_parser_emit_with_arg(
        -: 2524:            yyscanner, OP_PUSH, 0, NULL, NULL));
        -: 2525:
        -: 2526:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2527:      }
        -: 2528:#line 2529 "grammar.c" /* yacc.c:1646  */
    #####: 2529:    break;
        -: 2530:
    #####: 2531:  case 58:
        -: 2532:#line 966 "grammar.y" /* yacc.c:1646  */
        -: 2533:    {
        -: 2534:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, "matches");
        -: 2535:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, "matches");
        -: 2536:
        -: 2537:        fail_if_error(yr_parser_emit(
        -: 2538:            yyscanner,
        -: 2539:            OP_MATCHES,
        -: 2540:            NULL));
        -: 2541:
        -: 2542:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2543:      }
        -: 2544:#line 2545 "grammar.c" /* yacc.c:1646  */
    #####: 2545:    break;
        -: 2546:
    #####: 2547:  case 59:
        -: 2548:#line 978 "grammar.y" /* yacc.c:1646  */
        -: 2549:    {
        -: 2550:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, "contains");
        -: 2551:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_STRING, "contains");
        -: 2552:
        -: 2553:        fail_if_error(yr_parser_emit(
        -: 2554:            yyscanner, OP_CONTAINS, NULL));
        -: 2555:
        -: 2556:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2557:      }
        -: 2558:#line 2559 "grammar.c" /* yacc.c:1646  */
    #####: 2559:    break;
        -: 2560:
    #####: 2561:  case 60:
        -: 2562:#line 988 "grammar.y" /* yacc.c:1646  */
        -: 2563:    {
        -: 2564:        int result = yr_parser_reduce_string_identifier(
        -: 2565:            yyscanner,
        -: 2566:            (yyvsp[0].c_string),
        -: 2567:            OP_FOUND,
        -: 2568:            UNDEFINED);
        -: 2569:
        -: 2570:        yr_free((yyvsp[0].c_string));
        -: 2571:
        -: 2572:        fail_if_error(result);
        -: 2573:
        -: 2574:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2575:      }
        -: 2576:#line 2577 "grammar.c" /* yacc.c:1646  */
    #####: 2577:    break;
        -: 2578:
    #####: 2579:  case 61:
        -: 2580:#line 1002 "grammar.y" /* yacc.c:1646  */
        -: 2581:    {
        -: 2582:        check_type_with_cleanup((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "at", yr_free((yyvsp[-2].c_string)));
        -: 2583:
        -: 2584:        int result = yr_parser_reduce_string_identifier(
        -: 2585:            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);
        -: 2586:
        -: 2587:        yr_free((yyvsp[-2].c_string));
        -: 2588:
        -: 2589:        fail_if_error(result);
        -: 2590:
        -: 2591:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2592:      }
        -: 2593:#line 2594 "grammar.c" /* yacc.c:1646  */
    #####: 2594:    break;
        -: 2595:
    #####: 2596:  case 62:
        -: 2597:#line 1015 "grammar.y" /* yacc.c:1646  */
        -: 2598:    {
        -: 2599:        int result = yr_parser_reduce_string_identifier(
        -: 2600:            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);
        -: 2601:
        -: 2602:        yr_free((yyvsp[-2].c_string));
        -: 2603:
        -: 2604:        fail_if_error(result);
        -: 2605:
        -: 2606:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2607:      }
        -: 2608:#line 2609 "grammar.c" /* yacc.c:1646  */
    #####: 2609:    break;
        -: 2610:
    #####: 2611:  case 63:
        -: 2612:#line 1026 "grammar.y" /* yacc.c:1646  */
        -: 2613:    {
        -: 2614:        if (compiler->loop_depth > 0)
        -: 2615:        {
        -: 2616:          compiler->loop_depth--;
        -: 2617:          compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 2618:        }
        -: 2619:
        -: 2620:        YYERROR;
        -: 2621:      }
        -: 2622:#line 2623 "grammar.c" /* yacc.c:1646  */
        -: 2623:    break;
        -: 2624:
    #####: 2625:  case 64:
        -: 2626:#line 1036 "grammar.y" /* yacc.c:1646  */
        -: 2627:    {
        -: 2628:        int result = ERROR_SUCCESS;
        -: 2629:        int var_index;
        -: 2630:
        -: 2631:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
        -: 2632:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 2633:
        -: 2634:        fail_if_error(result);
        -: 2635:
        -: 2636:        var_index = yr_parser_lookup_loop_variable(
        -: 2637:            yyscanner, (yyvsp[-1].c_string));
        -: 2638:
        -: 2639:        if (var_index >= 0)
        -: 2640:        {
        -: 2641:          yr_compiler_set_error_extra_info(
        -: 2642:              compiler, (yyvsp[-1].c_string));
        -: 2643:
        -: 2644:          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;
        -: 2645:        }
        -: 2646:
        -: 2647:        fail_if_error(result);
        -: 2648:
        -: 2649:        // Push end-of-list marker
        -: 2650:        result = yr_parser_emit_with_arg(
        -: 2651:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 2652:
        -: 2653:        fail_if_error(result);
        -: 2654:      }
        -: 2655:#line 2656 "grammar.c" /* yacc.c:1646  */
        -: 2656:    break;
        -: 2657:
    #####: 2658:  case 65:
        -: 2659:#line 1065 "grammar.y" /* yacc.c:1646  */
        -: 2660:    {
        -: 2661:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2662:        uint8_t* addr;
        -: 2663:
        -: 2664:        // Clear counter for number of expressions evaluating
        -: 2665:        // to true.
        -: 2666:        yr_parser_emit_with_arg(
        -: 2667:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 2668:
        -: 2669:        // Clear iterations counter
        -: 2670:        yr_parser_emit_with_arg(
        -: 2671:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 2672:
        -: 2673:        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        -: 2674:        {
        -: 2675:          // Pop the first integer
        -: 2676:          yr_parser_emit_with_arg(
        -: 2677:              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        -: 2678:        }
        -: 2679:        else // INTEGER_SET_RANGE
        -: 2680:        {
        -: 2681:          // Pop higher bound of set range
        -: 2682:          yr_parser_emit_with_arg(
        -: 2683:              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);
        -: 2684:
        -: 2685:          // Pop lower bound of set range
        -: 2686:          yr_parser_emit_with_arg(
        -: 2687:              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        -: 2688:        }
        -: 2689:
        -: 2690:        compiler->loop_address[compiler->loop_depth] = addr;
        -: 2691:        compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
        -: 2692:        compiler->loop_depth++;
        -: 2693:      }
        -: 2694:#line 2695 "grammar.c" /* yacc.c:1646  */
    #####: 2695:    break;
        -: 2696:
    #####: 2697:  case 66:
        -: 2698:#line 1100 "grammar.y" /* yacc.c:1646  */
        -: 2699:    {
        -: 2700:        int mem_offset;
        -: 2701:
        -: 2702:        compiler->loop_depth--;
        -: 2703:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2704:
        -: 2705:        // The value at the top of the stack is the result of
        -: 2706:        // evaluating the boolean expression, so it could be
        -: 2707:        // 0, 1 or UNDEFINED. Add this value to a counter
        -: 2708:        // keeping the number of expressions evaluating to true.
        -: 2709:        // If the value is UNDEFINED instruction OP_ADD_M
        -: 2710:        // does nothing.
        -: 2711:
        -: 2712:        yr_parser_emit_with_arg(
        -: 2713:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 2714:
        -: 2715:        // Increment iterations counter
        -: 2716:        yr_parser_emit_with_arg(
        -: 2717:            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
        -: 2718:
        -: 2719:        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        -: 2720:        {
        -: 2721:          yr_parser_emit_with_arg_reloc(
        -: 2722:              yyscanner,
        -: 2723:              OP_JNUNDEF,
        -: 2724:              compiler->loop_address[compiler->loop_depth],
        -: 2725:              NULL,
        -: 2726:              NULL);
        -: 2727:        }
        -: 2728:        else // INTEGER_SET_RANGE
        -: 2729:        {
        -: 2730:          // Increment lower bound of integer set
        -: 2731:          yr_parser_emit_with_arg(
        -: 2732:              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);
        -: 2733:
        -: 2734:          // Push lower bound of integer set
        -: 2735:          yr_parser_emit_with_arg(
        -: 2736:              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);
        -: 2737:
        -: 2738:          // Push higher bound of integer set
        -: 2739:          yr_parser_emit_with_arg(
        -: 2740:              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);
        -: 2741:
        -: 2742:          // Compare higher bound with lower bound, do loop again
        -: 2743:          // if lower bound is still lower or equal than higher bound
        -: 2744:          yr_parser_emit_with_arg_reloc(
        -: 2745:              yyscanner,
        -: 2746:              OP_JLE,
        -: 2747:              compiler->loop_address[compiler->loop_depth],
        -: 2748:              NULL,
        -: 2749:              NULL);
        -: 2750:
        -: 2751:          yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 2752:          yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 2753:        }
        -: 2754:
        -: 2755:        // Pop end-of-list marker.
        -: 2756:        yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 2757:
        -: 2758:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 2759:        // is at the top of the stack. Check if the quantifier
        -: 2760:        // is undefined (meaning "all") and replace it with the
        -: 2761:        // iterations counter in that case.
        -: 2762:        yr_parser_emit_with_arg(
        -: 2763:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 2764:
        -: 2765:        // Compare the loop quantifier with the number of
        -: 2766:        // expressions evaluating to true.
        -: 2767:        yr_parser_emit_with_arg(
        -: 2768:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 2769:
        -: 2770:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 2771:
        -: 2772:        compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 2773:        yr_free((yyvsp[-8].c_string));
        -: 2774:
        -: 2775:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2776:      }
        -: 2777:#line 2778 "grammar.c" /* yacc.c:1646  */
    #####: 2778:    break;
        -: 2779:
    #####: 2780:  case 67:
        -: 2781:#line 1179 "grammar.y" /* yacc.c:1646  */
        -: 2782:    {
        -: 2783:        int result = ERROR_SUCCESS;
        -: 2784:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2785:        uint8_t* addr;
        -: 2786:
        -: 2787:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
        -: 2788:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 2789:
        -: 2790:        if (compiler->loop_for_of_mem_offset != -1)
        -: 2791:          result = ERROR_NESTED_FOR_OF_LOOP;
        -: 2792:
        -: 2793:        fail_if_error(result);
        -: 2794:
        -: 2795:        yr_parser_emit_with_arg(
        -: 2796:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 2797:
        -: 2798:        yr_parser_emit_with_arg(
        -: 2799:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 2800:
        -: 2801:        // Pop the first string.
        -: 2802:        yr_parser_emit_with_arg(
        -: 2803:            yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        -: 2804:
        -: 2805:        compiler->loop_for_of_mem_offset = mem_offset;
        -: 2806:        compiler->loop_address[compiler->loop_depth] = addr;
        -: 2807:        compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 2808:        compiler->loop_depth++;
        -: 2809:      }
        -: 2810:#line 2811 "grammar.c" /* yacc.c:1646  */
    #####: 2811:    break;
        -: 2812:
    #####: 2813:  case 68:
        -: 2814:#line 1208 "grammar.y" /* yacc.c:1646  */
        -: 2815:    {
        -: 2816:        int mem_offset;
        -: 2817:
        -: 2818:        compiler->loop_depth--;
        -: 2819:        compiler->loop_for_of_mem_offset = -1;
        -: 2820:
        -: 2821:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2822:
        -: 2823:        // Increment counter by the value returned by the
        -: 2824:        // boolean expression (0 or 1). If the boolean expression
        -: 2825:        // returned UNDEFINED the OP_ADD_M won't do anything.
        -: 2826:
        -: 2827:        yr_parser_emit_with_arg(
        -: 2828:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 2829:
        -: 2830:        // Increment iterations counter.
        -: 2831:        yr_parser_emit_with_arg(
        -: 2832:            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
        -: 2833:
        -: 2834:        // If next string is not undefined, go back to the
        -: 2835:        // beginning of the loop.
        -: 2836:        yr_parser_emit_with_arg_reloc(
        -: 2837:            yyscanner,
        -: 2838:            OP_JNUNDEF,
        -: 2839:            compiler->loop_address[compiler->loop_depth],
        -: 2840:            NULL,
        -: 2841:            NULL);
        -: 2842:
        -: 2843:        // Pop end-of-list marker.
        -: 2844:        yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 2845:
        -: 2846:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 2847:        // is at top of the stack. Check if the quantifier is
        -: 2848:        // undefined (meaning "all") and replace it with the
        -: 2849:        // iterations counter in that case.
        -: 2850:        yr_parser_emit_with_arg(
        -: 2851:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 2852:
        -: 2853:        // Compare the loop quantifier with the number of
        -: 2854:        // expressions evaluating to true.
        -: 2855:        yr_parser_emit_with_arg(
        -: 2856:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 2857:
        -: 2858:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 2859:
        -: 2860:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2861:
        -: 2862:      }
        -: 2863:#line 2864 "grammar.c" /* yacc.c:1646  */
    #####: 2864:    break;
        -: 2865:
        4: 2866:  case 69:
        -: 2867:#line 1257 "grammar.y" /* yacc.c:1646  */
        -: 2868:    {
        -: 2869:        yr_parser_emit(yyscanner, OP_OF, NULL);
        -: 2870:
        -: 2871:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2872:      }
        -: 2873:#line 2874 "grammar.c" /* yacc.c:1646  */
        4: 2874:    break;
        -: 2875:
    #####: 2876:  case 70:
        -: 2877:#line 1263 "grammar.y" /* yacc.c:1646  */
        -: 2878:    {
        -: 2879:        yr_parser_emit(yyscanner, OP_NOT, NULL);
        -: 2880:
        -: 2881:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2882:      }
        -: 2883:#line 2884 "grammar.c" /* yacc.c:1646  */
    #####: 2884:    break;
        -: 2885:
    #####: 2886:  case 71:
        -: 2887:#line 1269 "grammar.y" /* yacc.c:1646  */
        -: 2888:    {
        -: 2889:        YR_FIXUP* fixup;
        -: 2890:        void* jmp_destination_addr;
        -: 2891:
        -: 2892:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 2893:            yyscanner,
        -: 2894:            OP_JFALSE,
        -: 2895:            0,          // still don't know the jump destination
        -: 2896:            NULL,
        -: 2897:            &jmp_destination_addr));
        -: 2898:
        -: 2899:        // create a fixup entry for the jump and push it in the stack
        -: 2900:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 2901:
        -: 2902:        if (fixup == NULL)
        -: 2903:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 2904:
        -: 2905:        fixup->address = jmp_destination_addr;
        -: 2906:        fixup->next = compiler->fixup_stack_head;
        -: 2907:        compiler->fixup_stack_head = fixup;
        -: 2908:      }
        -: 2909:#line 2910 "grammar.c" /* yacc.c:1646  */
    #####: 2910:    break;
        -: 2911:
    #####: 2912:  case 72:
        -: 2913:#line 1291 "grammar.y" /* yacc.c:1646  */
        -: 2914:    {
        -: 2915:        YR_FIXUP* fixup;
        -: 2916:        uint8_t* nop_addr;
        -: 2917:
        -: 2918:        fail_if_error(yr_parser_emit(yyscanner, OP_AND, NULL));
        -: 2919:
        -: 2920:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 2921:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 2922:        // use the address of the OP_AND instruction +1 because we can't be
        -: 2923:        // sure that the instruction following the OP_AND is going to be in
        -: 2924:        // the same arena page. As we don't have a reliable way of getting the
        -: 2925:        // address of the next instruction we generate the OP_NOP.
        -: 2926:
        -: 2927:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 2928:
        -: 2929:        fixup = compiler->fixup_stack_head;
        -: 2930:        *(void**)(fixup->address) = (void*) nop_addr;
        -: 2931:        compiler->fixup_stack_head = fixup->next;
        -: 2932:        yr_free(fixup);
        -: 2933:
        -: 2934:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2935:      }
        -: 2936:#line 2937 "grammar.c" /* yacc.c:1646  */
    #####: 2937:    break;
        -: 2938:
    #####: 2939:  case 73:
        -: 2940:#line 1314 "grammar.y" /* yacc.c:1646  */
        -: 2941:    {
        -: 2942:        YR_FIXUP* fixup;
        -: 2943:        void* jmp_destination_addr;
        -: 2944:
        -: 2945:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 2946:            yyscanner,
        -: 2947:            OP_JTRUE,
        -: 2948:            0,         // still don't know the jump destination
        -: 2949:            NULL,
        -: 2950:            &jmp_destination_addr));
        -: 2951:
        -: 2952:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 2953:
        -: 2954:        if (fixup == NULL)
        -: 2955:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 2956:
        -: 2957:        fixup->address = jmp_destination_addr;
        -: 2958:        fixup->next = compiler->fixup_stack_head;
        -: 2959:        compiler->fixup_stack_head = fixup;
        -: 2960:      }
        -: 2961:#line 2962 "grammar.c" /* yacc.c:1646  */
    #####: 2962:    break;
        -: 2963:
    #####: 2964:  case 74:
        -: 2965:#line 1335 "grammar.y" /* yacc.c:1646  */
        -: 2966:    {
        -: 2967:        YR_FIXUP* fixup;
        -: 2968:        uint8_t* nop_addr;
        -: 2969:
        -: 2970:        fail_if_error(yr_parser_emit(yyscanner, OP_OR, NULL));
        -: 2971:
        -: 2972:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 2973:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 2974:        // use the address of the OP_OR instruction +1 because we can't be
        -: 2975:        // sure that the instruction following the OP_AND is going to be in
        -: 2976:        // the same arena page. As we don't have a reliable way of getting the
        -: 2977:        // address of the next instruction we generate the OP_NOP.
        -: 2978:
        -: 2979:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 2980:
        -: 2981:        fixup = compiler->fixup_stack_head;
        -: 2982:        *(void**)(fixup->address) = (void*)(nop_addr);
        -: 2983:        compiler->fixup_stack_head = fixup->next;
        -: 2984:        yr_free(fixup);
        -: 2985:
        -: 2986:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2987:      }
        -: 2988:#line 2989 "grammar.c" /* yacc.c:1646  */
    #####: 2989:    break;
        -: 2990:
    #####: 2991:  case 75:
        -: 2992:#line 1358 "grammar.y" /* yacc.c:1646  */
        -: 2993:    {
        -: 2994:        fail_if_error(yr_parser_reduce_operation(
        -: 2995:            yyscanner, "<", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 2996:
        -: 2997:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2998:      }
        -: 2999:#line 3000 "grammar.c" /* yacc.c:1646  */
    #####: 3000:    break;
        -: 3001:
    #####: 3002:  case 76:
        -: 3003:#line 1365 "grammar.y" /* yacc.c:1646  */
        -: 3004:    {
        -: 3005:        fail_if_error(yr_parser_reduce_operation(
        -: 3006:            yyscanner, ">", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3007:
        -: 3008:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3009:      }
        -: 3010:#line 3011 "grammar.c" /* yacc.c:1646  */
    #####: 3011:    break;
        -: 3012:
    #####: 3013:  case 77:
        -: 3014:#line 1372 "grammar.y" /* yacc.c:1646  */
        -: 3015:    {
        -: 3016:        fail_if_error(yr_parser_reduce_operation(
        -: 3017:            yyscanner, "<=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3018:
        -: 3019:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3020:      }
        -: 3021:#line 3022 "grammar.c" /* yacc.c:1646  */
    #####: 3022:    break;
        -: 3023:
    #####: 3024:  case 78:
        -: 3025:#line 1379 "grammar.y" /* yacc.c:1646  */
        -: 3026:    {
        -: 3027:        fail_if_error(yr_parser_reduce_operation(
        -: 3028:            yyscanner, ">=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3029:
        -: 3030:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3031:      }
        -: 3032:#line 3033 "grammar.c" /* yacc.c:1646  */
    #####: 3033:    break;
        -: 3034:
    #####: 3035:  case 79:
        -: 3036:#line 1386 "grammar.y" /* yacc.c:1646  */
        -: 3037:    {
        -: 3038:        fail_if_error(yr_parser_reduce_operation(
        -: 3039:            yyscanner, "==", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3040:
        -: 3041:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3042:      }
        -: 3043:#line 3044 "grammar.c" /* yacc.c:1646  */
    #####: 3044:    break;
        -: 3045:
    #####: 3046:  case 80:
        -: 3047:#line 1393 "grammar.y" /* yacc.c:1646  */
        -: 3048:    {
        -: 3049:        fail_if_error(yr_parser_reduce_operation(
        -: 3050:            yyscanner, "!=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3051:
        -: 3052:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3053:      }
        -: 3054:#line 3055 "grammar.c" /* yacc.c:1646  */
    #####: 3055:    break;
        -: 3056:
    #####: 3057:  case 81:
        -: 3058:#line 1400 "grammar.y" /* yacc.c:1646  */
        -: 3059:    {
        -: 3060:        (yyval.expression) = (yyvsp[0].expression);
        -: 3061:      }
        -: 3062:#line 3063 "grammar.c" /* yacc.c:1646  */
    #####: 3063:    break;
        -: 3064:
    #####: 3065:  case 82:
        -: 3066:#line 1404 "grammar.y" /* yacc.c:1646  */
        -: 3067:    {
        -: 3068:        (yyval.expression) = (yyvsp[-1].expression);
        -: 3069:      }
        -: 3070:#line 3071 "grammar.c" /* yacc.c:1646  */
    #####: 3071:    break;
        -: 3072:
    #####: 3073:  case 83:
        -: 3074:#line 1411 "grammar.y" /* yacc.c:1646  */
        -: 3075:    { (yyval.integer) = INTEGER_SET_ENUMERATION; }
        -: 3076:#line 3077 "grammar.c" /* yacc.c:1646  */
    #####: 3077:    break;
        -: 3078:
    #####: 3079:  case 84:
        -: 3080:#line 1412 "grammar.y" /* yacc.c:1646  */
        -: 3081:    { (yyval.integer) = INTEGER_SET_RANGE; }
        -: 3082:#line 3083 "grammar.c" /* yacc.c:1646  */
    #####: 3083:    break;
        -: 3084:
    #####: 3085:  case 85:
        -: 3086:#line 1418 "grammar.y" /* yacc.c:1646  */
        -: 3087:    {
        -: 3088:        int result = ERROR_SUCCESS;
        -: 3089:
        -: 3090:        if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3091:        {
        -: 3092:          yr_compiler_set_error_extra_info(
        -: 3093:              compiler, "wrong type for range's lower bound");
        -: 3094:          result = ERROR_WRONG_TYPE;
        -: 3095:        }
        -: 3096:
        -: 3097:        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3098:        {
        -: 3099:          yr_compiler_set_error_extra_info(
        -: 3100:              compiler, "wrong type for range's upper bound");
        -: 3101:          result = ERROR_WRONG_TYPE;
        -: 3102:        }
        -: 3103:
        -: 3104:        fail_if_error(result);
        -: 3105:      }
        -: 3106:#line 3107 "grammar.c" /* yacc.c:1646  */
        -: 3107:    break;
        -: 3108:
    #####: 3109:  case 86:
        -: 3110:#line 1442 "grammar.y" /* yacc.c:1646  */
        -: 3111:    {
        -: 3112:        int result = ERROR_SUCCESS;
        -: 3113:
        -: 3114:        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3115:        {
        -: 3116:          yr_compiler_set_error_extra_info(
        -: 3117:              compiler, "wrong type for enumeration item");
        -: 3118:          result = ERROR_WRONG_TYPE;
        -: 3119:        }
        -: 3120:
        -: 3121:        fail_if_error(result);
        -: 3122:      }
        -: 3123:#line 3124 "grammar.c" /* yacc.c:1646  */
        -: 3124:    break;
        -: 3125:
    #####: 3126:  case 87:
        -: 3127:#line 1455 "grammar.y" /* yacc.c:1646  */
        -: 3128:    {
        -: 3129:        int result = ERROR_SUCCESS;
        -: 3130:
        -: 3131:        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3132:        {
        -: 3133:          yr_compiler_set_error_extra_info(
        -: 3134:              compiler, "wrong type for enumeration item");
        -: 3135:          result = ERROR_WRONG_TYPE;
        -: 3136:        }
        -: 3137:
        -: 3138:        fail_if_error(result);
        -: 3139:      }
        -: 3140:#line 3141 "grammar.c" /* yacc.c:1646  */
        -: 3141:    break;
        -: 3142:
    #####: 3143:  case 88:
        -: 3144:#line 1472 "grammar.y" /* yacc.c:1646  */
        -: 3145:    {
        -: 3146:        // Push end-of-list marker
        -: 3147:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 3148:      }
        -: 3149:#line 3150 "grammar.c" /* yacc.c:1646  */
    #####: 3150:    break;
        -: 3151:
        4: 3152:  case 90:
        -: 3153:#line 1478 "grammar.y" /* yacc.c:1646  */
        -: 3154:    {
        -: 3155:        fail_if_error(yr_parser_emit_with_arg(
        -: 3156:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL));
        -: 3157:
        -: 3158:        fail_if_error(yr_parser_emit_pushes_for_strings(
        -: 3159:            yyscanner, "$*"));
        -: 3160:      }
        -: 3161:#line 3162 "grammar.c" /* yacc.c:1646  */
        -: 3162:    break;
        -: 3163:
    #####: 3164:  case 93:
        -: 3165:#line 1496 "grammar.y" /* yacc.c:1646  */
        -: 3166:    {
        -: 3167:        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        -: 3168:        yr_free((yyvsp[0].c_string));
        -: 3169:
        -: 3170:        fail_if_error(result);
        -: 3171:      }
        -: 3172:#line 3173 "grammar.c" /* yacc.c:1646  */
        -: 3173:    break;
        -: 3174:
    #####: 3175:  case 94:
        -: 3176:#line 1503 "grammar.y" /* yacc.c:1646  */
        -: 3177:    {
        -: 3178:        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        -: 3179:        yr_free((yyvsp[0].c_string));
        -: 3180:
        -: 3181:        fail_if_error(result);
        -: 3182:      }
        -: 3183:#line 3184 "grammar.c" /* yacc.c:1646  */
        -: 3184:    break;
        -: 3185:
        4: 3186:  case 96:
        -: 3187:#line 1515 "grammar.y" /* yacc.c:1646  */
        -: 3188:    {
        -: 3189:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 3190:      }
        -: 3191:#line 3192 "grammar.c" /* yacc.c:1646  */
        4: 3192:    break;
        -: 3193:
    #####: 3194:  case 97:
        -: 3195:#line 1519 "grammar.y" /* yacc.c:1646  */
        -: 3196:    {
        -: 3197:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3198:      }
        -: 3199:#line 3200 "grammar.c" /* yacc.c:1646  */
    #####: 3200:    break;
        -: 3201:
    #####: 3202:  case 98:
        -: 3203:#line 1527 "grammar.y" /* yacc.c:1646  */
        -: 3204:    {
        -: 3205:        (yyval.expression) = (yyvsp[-1].expression);
        -: 3206:      }
        -: 3207:#line 3208 "grammar.c" /* yacc.c:1646  */
    #####: 3208:    break;
        -: 3209:
    #####: 3210:  case 99:
        -: 3211:#line 1531 "grammar.y" /* yacc.c:1646  */
        -: 3212:    {
        -: 3213:        fail_if_error(yr_parser_emit(
        -: 3214:            yyscanner, OP_FILESIZE, NULL));
        -: 3215:
        -: 3216:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3217:        (yyval.expression).value.integer = UNDEFINED;
        -: 3218:      }
        -: 3219:#line 3220 "grammar.c" /* yacc.c:1646  */
    #####: 3220:    break;
        -: 3221:
    #####: 3222:  case 100:
        -: 3223:#line 1539 "grammar.y" /* yacc.c:1646  */
        -: 3224:    {
        -: 3225:        yywarning(yyscanner,
        -: 3226:            "Using deprecated \"entrypoint\" keyword. Use the \"entry_point\" "
        -: 3227:            "function from PE module instead.");
        -: 3228:
        -: 3229:        fail_if_error(yr_parser_emit(
        -: 3230:            yyscanner, OP_ENTRYPOINT, NULL));
        -: 3231:
        -: 3232:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3233:        (yyval.expression).value.integer = UNDEFINED;
        -: 3234:      }
        -: 3235:#line 3236 "grammar.c" /* yacc.c:1646  */
    #####: 3236:    break;
        -: 3237:
    #####: 3238:  case 101:
        -: 3239:#line 1551 "grammar.y" /* yacc.c:1646  */
        -: 3240:    {
        -: 3241:        check_type((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, "intXXXX or uintXXXX");
        -: 3242:
        -: 3243:        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,
        -: 3244:        // uint32, etc. $1 contains an index that added to OP_READ_INT results
        -: 3245:        // in the proper OP_INTXX opcode.
        -: 3246:
        -: 3247:        fail_if_error(yr_parser_emit(
        -: 3248:            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL));
        -: 3249:
        -: 3250:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3251:        (yyval.expression).value.integer = UNDEFINED;
        -: 3252:      }
        -: 3253:#line 3254 "grammar.c" /* yacc.c:1646  */
    #####: 3254:    break;
        -: 3255:
    #####: 3256:  case 102:
        -: 3257:#line 1565 "grammar.y" /* yacc.c:1646  */
        -: 3258:    {
        -: 3259:        fail_if_error(yr_parser_emit_with_arg(
        -: 3260:            yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL));
        -: 3261:
        -: 3262:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3263:        (yyval.expression).value.integer = (yyvsp[0].integer);
        -: 3264:      }
        -: 3265:#line 3266 "grammar.c" /* yacc.c:1646  */
    #####: 3266:    break;
        -: 3267:
    #####: 3268:  case 103:
        -: 3269:#line 1573 "grammar.y" /* yacc.c:1646  */
        -: 3270:    {
        -: 3271:        fail_if_error(yr_parser_emit_with_arg_double(
        -: 3272:            yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL));
        -: 3273:
        -: 3274:        (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3275:      }
        -: 3276:#line 3277 "grammar.c" /* yacc.c:1646  */
    #####: 3277:    break;
        -: 3278:
    #####: 3279:  case 104:
        -: 3280:#line 1580 "grammar.y" /* yacc.c:1646  */
        -: 3281:    {
        -: 3282:        SIZED_STRING* sized_string;
        -: 3283:
        -: 3284:        int result = yr_arena_write_data(
        -: 3285:            compiler->sz_arena,
        -: 3286:            (yyvsp[0].sized_string),
        -: 3287:            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
        -: 3288:            (void**) &sized_string);
        -: 3289:
        -: 3290:        yr_free((yyvsp[0].sized_string));
        -: 3291:
        -: 3292:        if (result == ERROR_SUCCESS)
        -: 3293:          result = yr_parser_emit_with_arg_reloc(
        -: 3294:              yyscanner,
        -: 3295:              OP_PUSH,
        -: 3296:              sized_string,
        -: 3297:              NULL,
        -: 3298:              NULL);
        -: 3299:
        -: 3300:        fail_if_error(result);
        -: 3301:
        -: 3302:        (yyval.expression).type = EXPRESSION_TYPE_STRING;
        -: 3303:        (yyval.expression).value.sized_string = sized_string;
        -: 3304:      }
        -: 3305:#line 3306 "grammar.c" /* yacc.c:1646  */
    #####: 3306:    break;
        -: 3307:
    #####: 3308:  case 105:
        -: 3309:#line 1605 "grammar.y" /* yacc.c:1646  */
        -: 3310:    {
        -: 3311:        int result = yr_parser_reduce_string_identifier(
        -: 3312:            yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);
        -: 3313:
        -: 3314:        yr_free((yyvsp[0].c_string));
        -: 3315:
        -: 3316:        fail_if_error(result);
        -: 3317:
        -: 3318:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3319:        (yyval.expression).value.integer = UNDEFINED;
        -: 3320:      }
        -: 3321:#line 3322 "grammar.c" /* yacc.c:1646  */
    #####: 3322:    break;
        -: 3323:
    #####: 3324:  case 106:
        -: 3325:#line 1617 "grammar.y" /* yacc.c:1646  */
        -: 3326:    {
        -: 3327:        int result = yr_parser_reduce_string_identifier(
        -: 3328:            yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);
        -: 3329:
        -: 3330:        yr_free((yyvsp[-3].c_string));
        -: 3331:
        -: 3332:        fail_if_error(result);
        -: 3333:
        -: 3334:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3335:        (yyval.expression).value.integer = UNDEFINED;
        -: 3336:      }
        -: 3337:#line 3338 "grammar.c" /* yacc.c:1646  */
    #####: 3338:    break;
        -: 3339:
    #####: 3340:  case 107:
        -: 3341:#line 1629 "grammar.y" /* yacc.c:1646  */
        -: 3342:    {
        -: 3343:        int result = yr_parser_emit_with_arg(
        -: 3344:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3345:
        -: 3346:        if (result == ERROR_SUCCESS)
        -: 3347:          result = yr_parser_reduce_string_identifier(
        -: 3348:              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);
        -: 3349:
        -: 3350:        yr_free((yyvsp[0].c_string));
        -: 3351:
        -: 3352:        fail_if_error(result);
        -: 3353:
        -: 3354:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3355:        (yyval.expression).value.integer = UNDEFINED;
        -: 3356:      }
        -: 3357:#line 3358 "grammar.c" /* yacc.c:1646  */
    #####: 3358:    break;
        -: 3359:
    #####: 3360:  case 108:
        -: 3361:#line 1645 "grammar.y" /* yacc.c:1646  */
        -: 3362:    {
        -: 3363:        int result = yr_parser_reduce_string_identifier(
        -: 3364:            yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);
        -: 3365:
        -: 3366:        yr_free((yyvsp[-3].c_string));
        -: 3367:
        -: 3368:        fail_if_error(result);
        -: 3369:
        -: 3370:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3371:        (yyval.expression).value.integer = UNDEFINED;
        -: 3372:      }
        -: 3373:#line 3374 "grammar.c" /* yacc.c:1646  */
    #####: 3374:    break;
        -: 3375:
    #####: 3376:  case 109:
        -: 3377:#line 1657 "grammar.y" /* yacc.c:1646  */
        -: 3378:    {
        -: 3379:        int result = yr_parser_emit_with_arg(
        -: 3380:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3381:
        -: 3382:        if (result == ERROR_SUCCESS)
        -: 3383:          result = yr_parser_reduce_string_identifier(
        -: 3384:              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);
        -: 3385:
        -: 3386:        yr_free((yyvsp[0].c_string));
        -: 3387:
        -: 3388:        fail_if_error(result);
        -: 3389:
        -: 3390:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3391:        (yyval.expression).value.integer = UNDEFINED;
        -: 3392:      }
        -: 3393:#line 3394 "grammar.c" /* yacc.c:1646  */
    #####: 3394:    break;
        -: 3395:
    #####: 3396:  case 110:
        -: 3397:#line 1673 "grammar.y" /* yacc.c:1646  */
        -: 3398:    {
        -: 3399:        int result = ERROR_SUCCESS;
        -: 3400:
        -: 3401:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
        -: 3402:        {
        -: 3403:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3404:          (yyval.expression).value.integer = UNDEFINED;
        -: 3405:        }
        -: 3406:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        -: 3407:        {
        -: 3408:          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3409:          (yyval.expression).value.integer = UNDEFINED;
        -: 3410:        }
        -: 3411:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        -: 3412:        {
        -: 3413:          result = yr_parser_emit(
        -: 3414:              yyscanner, OP_OBJ_VALUE, NULL);
        -: 3415:
        -: 3416:          switch((yyvsp[0].expression).value.object->type)
        -: 3417:          {
        -: 3418:            case OBJECT_TYPE_INTEGER:
        -: 3419:              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3420:              (yyval.expression).value.integer = UNDEFINED;
        -: 3421:              break;
        -: 3422:            case OBJECT_TYPE_FLOAT:
        -: 3423:              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3424:              break;
        -: 3425:            case OBJECT_TYPE_STRING:
        -: 3426:              (yyval.expression).type = EXPRESSION_TYPE_STRING;
        -: 3427:              (yyval.expression).value.sized_string = NULL;
        -: 3428:              break;
        -: 3429:            default:
        -: 3430:              yr_compiler_set_error_extra_info_fmt(
        -: 3431:                  compiler,
        -: 3432:                  "wrong usage of identifier \"%s\"",
        -: 3433:                  (yyvsp[0].expression).identifier);
        -: 3434:              result = ERROR_WRONG_TYPE;
        -: 3435:          }
        -: 3436:        }
        -: 3437:        else
        -: 3438:        {
        -: 3439:          assert(false);
        -: 3440:        }
        -: 3441:
        -: 3442:        fail_if_error(result);
        -: 3443:      }
        -: 3444:#line 3445 "grammar.c" /* yacc.c:1646  */
        -: 3445:    break;
        -: 3446:
    #####: 3447:  case 111:
        -: 3448:#line 1720 "grammar.y" /* yacc.c:1646  */
        -: 3449:    {
        -: 3450:        int result = ERROR_SUCCESS;
        -: 3451:
        -: 3452:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, "-");
        -: 3453:
        -: 3454:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3455:        {
        -: 3456:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3457:          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
        -: 3458:              UNDEFINED : -((yyvsp[0].expression).value.integer);
        -: 3459:          result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        -: 3460:        }
        -: 3461:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        -: 3462:        {
        -: 3463:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3464:          result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        -: 3465:        }
        -: 3466:
        -: 3467:        fail_if_error(result);
        -: 3468:      }
        -: 3469:#line 3470 "grammar.c" /* yacc.c:1646  */
        -: 3470:    break;
        -: 3471:
    #####: 3472:  case 112:
        -: 3473:#line 1741 "grammar.y" /* yacc.c:1646  */
        -: 3474:    {
        -: 3475:        int result = yr_parser_reduce_operation(
        -: 3476:            yyscanner, "+", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3477:
        -: 3478:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3479:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3480:        {
        -: 3481:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 3482:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 3483:
        -: 3484:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 3485:              (
        -: 3486:                (i2 > 0 && i1 > INT64_MAX - i2) ||
        -: 3487:                (i2 < 0 && i1 < INT64_MIN - i2)
        -: 3488:              ))
        -: 3489:          {
        -: 3490:            yr_compiler_set_error_extra_info_fmt(
        -: 3491:                compiler, "%" PRId64 " + %" PRId64, i1, i2);
        -: 3492:
        -: 3493:            result = ERROR_INTEGER_OVERFLOW;
        -: 3494:          }
        -: 3495:          else
        -: 3496:          {
        -: 3497:            (yyval.expression).value.integer = OPERATION(+, i1, i2);
        -: 3498:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3499:          }
        -: 3500:        }
        -: 3501:        else
        -: 3502:        {
        -: 3503:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3504:        }
        -: 3505:
        -: 3506:        fail_if_error(result);
        -: 3507:      }
        -: 3508:#line 3509 "grammar.c" /* yacc.c:1646  */
        -: 3509:    break;
        -: 3510:
    #####: 3511:  case 113:
        -: 3512:#line 1776 "grammar.y" /* yacc.c:1646  */
        -: 3513:    {
        -: 3514:        int result = yr_parser_reduce_operation(
        -: 3515:            yyscanner, "-", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3516:
        -: 3517:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3518:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3519:        {
        -: 3520:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 3521:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 3522:
        -: 3523:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 3524:              (
        -: 3525:                (i2 < 0 && i1 > INT64_MAX + i2) ||
        -: 3526:                (i2 > 0 && i1 < INT64_MIN + i2)
        -: 3527:              ))
        -: 3528:          {
        -: 3529:            yr_compiler_set_error_extra_info_fmt(
        -: 3530:                compiler, "%" PRId64 " - %" PRId64, i1, i2);
        -: 3531:
        -: 3532:            result = ERROR_INTEGER_OVERFLOW;
        -: 3533:          }
        -: 3534:          else
        -: 3535:          {
        -: 3536:            (yyval.expression).value.integer = OPERATION(-, i1, i2);
        -: 3537:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3538:          }
        -: 3539:        }
        -: 3540:        else
        -: 3541:        {
        -: 3542:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3543:        }
        -: 3544:
        -: 3545:        fail_if_error(result);
        -: 3546:      }
        -: 3547:#line 3548 "grammar.c" /* yacc.c:1646  */
        -: 3548:    break;
        -: 3549:
    #####: 3550:  case 114:
        -: 3551:#line 1811 "grammar.y" /* yacc.c:1646  */
        -: 3552:    {
        -: 3553:        int result = yr_parser_reduce_operation(
        -: 3554:            yyscanner, "*", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3555:
        -: 3556:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3557:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3558:        {
        -: 3559:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 3560:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 3561:
        -: 3562:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 3563:              (
        -: 3564:                i2 != 0 && llabs(i1) > INT64_MAX / llabs(i2)
        -: 3565:              ))
        -: 3566:          {
        -: 3567:            yr_compiler_set_error_extra_info_fmt(
        -: 3568:                compiler, "%" PRId64 " * %" PRId64, i1, i2);
        -: 3569:
        -: 3570:            result = ERROR_INTEGER_OVERFLOW;
        -: 3571:          }
        -: 3572:          else
        -: 3573:          {
        -: 3574:            (yyval.expression).value.integer = OPERATION(*, i1, i2);
        -: 3575:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3576:          }
        -: 3577:        }
        -: 3578:        else
        -: 3579:        {
        -: 3580:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3581:        }
        -: 3582:
        -: 3583:        fail_if_error(result);
        -: 3584:      }
        -: 3585:#line 3586 "grammar.c" /* yacc.c:1646  */
        -: 3586:    break;
        -: 3587:
    #####: 3588:  case 115:
        -: 3589:#line 1845 "grammar.y" /* yacc.c:1646  */
        -: 3590:    {
        -: 3591:        int result = yr_parser_reduce_operation(
        -: 3592:            yyscanner, "\\", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3593:
        -: 3594:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3595:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3596:        {
        -: 3597:          if ((yyvsp[0].expression).value.integer != 0)
        -: 3598:          {
        -: 3599:            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3600:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3601:          }
        -: 3602:          else
        -: 3603:          {
        -: 3604:            result = ERROR_DIVISION_BY_ZERO;
        -: 3605:          }
        -: 3606:        }
        -: 3607:        else
        -: 3608:        {
        -: 3609:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3610:        }
        -: 3611:
        -: 3612:        fail_if_error(result);
        -: 3613:      }
        -: 3614:#line 3615 "grammar.c" /* yacc.c:1646  */
        -: 3615:    break;
        -: 3616:
    #####: 3617:  case 116:
        -: 3618:#line 1870 "grammar.y" /* yacc.c:1646  */
        -: 3619:    {
        -: 3620:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "%");
        -: 3621:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "%");
        -: 3622:
        -: 3623:        fail_if_error(yr_parser_emit(yyscanner, OP_MOD, NULL));
        -: 3624:
        -: 3625:        if ((yyvsp[0].expression).value.integer != 0)
        -: 3626:        {
        -: 3627:          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3628:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3629:        }
        -: 3630:        else
        -: 3631:        {
        -: 3632:          fail_if_error(ERROR_DIVISION_BY_ZERO);
        -: 3633:        }
        -: 3634:      }
        -: 3635:#line 3636 "grammar.c" /* yacc.c:1646  */
    #####: 3636:    break;
        -: 3637:
    #####: 3638:  case 117:
        -: 3639:#line 1887 "grammar.y" /* yacc.c:1646  */
        -: 3640:    {
        -: 3641:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3642:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3643:
        -: 3644:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL));
        -: 3645:
        -: 3646:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3647:        (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3648:      }
        -: 3649:#line 3650 "grammar.c" /* yacc.c:1646  */
    #####: 3650:    break;
        -: 3651:
    #####: 3652:  case 118:
        -: 3653:#line 1897 "grammar.y" /* yacc.c:1646  */
        -: 3654:    {
        -: 3655:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3656:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3657:
        -: 3658:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL));
        -: 3659:
        -: 3660:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3661:        (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3662:      }
        -: 3663:#line 3664 "grammar.c" /* yacc.c:1646  */
    #####: 3664:    break;
        -: 3665:
    #####: 3666:  case 119:
        -: 3667:#line 1907 "grammar.y" /* yacc.c:1646  */
        -: 3668:    {
        -: 3669:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "|");
        -: 3670:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "|");
        -: 3671:
        -: 3672:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL));
        -: 3673:
        -: 3674:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3675:        (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3676:      }
        -: 3677:#line 3678 "grammar.c" /* yacc.c:1646  */
    #####: 3678:    break;
        -: 3679:
    #####: 3680:  case 120:
        -: 3681:#line 1917 "grammar.y" /* yacc.c:1646  */
        -: 3682:    {
        -: 3683:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "~");
        -: 3684:
        -: 3685:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL));
        -: 3686:
        -: 3687:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3688:        (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
        -: 3689:            UNDEFINED : ~((yyvsp[0].expression).value.integer);
        -: 3690:      }
        -: 3691:#line 3692 "grammar.c" /* yacc.c:1646  */
    #####: 3692:    break;
        -: 3693:
    #####: 3694:  case 121:
        -: 3695:#line 1927 "grammar.y" /* yacc.c:1646  */
        -: 3696:    {
        -: 3697:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "<<");
        -: 3698:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "<<");
        -: 3699:
        -: 3700:        int result = yr_parser_emit(yyscanner, OP_SHL, NULL);
        -: 3701:
        -: 3702:        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)
        -: 3703:          result = ERROR_INVALID_OPERAND;
        -: 3704:        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)
        -: 3705:          (yyval.expression).value.integer = 0;
        -: 3706:        else
        -: 3707:          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3708:
        -: 3709:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3710:
        -: 3711:        fail_if_error(result);
        -: 3712:      }
        -: 3713:#line 3714 "grammar.c" /* yacc.c:1646  */
        -: 3714:    break;
        -: 3715:
    #####: 3716:  case 122:
        -: 3717:#line 1945 "grammar.y" /* yacc.c:1646  */
        -: 3718:    {
        -: 3719:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ">>");
        -: 3720:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ">>");
        -: 3721:
        -: 3722:        int result = yr_parser_emit(yyscanner, OP_SHR, NULL);
        -: 3723:
        -: 3724:        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)
        -: 3725:          result = ERROR_INVALID_OPERAND;
        -: 3726:        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)
        -: 3727:          (yyval.expression).value.integer = 0;
        -: 3728:        else
        -: 3729:          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3730:
        -: 3731:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3732:
        -: 3733:        fail_if_error(result);
        -: 3734:      }
        -: 3735:#line 3736 "grammar.c" /* yacc.c:1646  */
        -: 3736:    break;
        -: 3737:
    #####: 3738:  case 123:
        -: 3739:#line 1963 "grammar.y" /* yacc.c:1646  */
        -: 3740:    {
        -: 3741:        (yyval.expression) = (yyvsp[0].expression);
        -: 3742:      }
        -: 3743:#line 3744 "grammar.c" /* yacc.c:1646  */
    #####: 3744:    break;
        -: 3745:
        -: 3746:
        -: 3747:#line 3748 "grammar.c" /* yacc.c:1646  */
        -: 3748:      default: break;
        -: 3749:    }
        -: 3750:  /* User semantic actions sometimes alter yychar, and that requires
        -: 3751:     that yytoken be updated with the new translation.  We take the
        -: 3752:     approach of translating immediately before every use of yytoken.
        -: 3753:     One alternative is translating here after every semantic action,
        -: 3754:     but that translation would be missed if the semantic action invokes
        -: 3755:     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
        -: 3756:     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
        -: 3757:     incorrect destructor might then be invoked immediately.  In the
        -: 3758:     case of YYERROR or YYBACKUP, subsequent parser actions might lead
        -: 3759:     to an incorrect destructor call or verbose syntax error message
        -: 3760:     before the lookahead is translated.  */
        -: 3761:  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
        -: 3762:
      120: 3763:  YYPOPSTACK (yylen);
        -: 3764:  yylen = 0;
        -: 3765:  YY_STACK_PRINT (yyss, yyssp);
        -: 3766:
      120: 3767:  *++yyvsp = yyval;
        -: 3768:
        -: 3769:  /* Now 'shift' the result of the reduction.  Determine what state
        -: 3770:     that goes to, based on the state we popped back to and the rule
        -: 3771:     number reduced by.  */
        -: 3772:
      120: 3773:  yyn = yyr1[yyn];
        -: 3774:
      120: 3775:  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
      120: 3776:  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
branch  0 taken 48 (fallthrough)
branch  1 taken 72
branch  2 taken 17 (fallthrough)
branch  3 taken 31
       17: 3777:    yystate = yytable[yystate];
        -: 3778:  else
      103: 3779:    yystate = yydefgoto[yyn - YYNTOKENS];
        -: 3780:
        -: 3781:  goto yynewstate;
        -: 3782:
        -: 3783:
        -: 3784:/*--------------------------------------.
        -: 3785:| yyerrlab -- here on detecting error.  |
        -: 3786:`--------------------------------------*/
    #####: 3787:yyerrlab:
        -: 3788:  /* Make sure we have latest lookahead translation.  See comments at
        -: 3789:     user semantic actions for why this is necessary.  */
    #####: 3790:  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3791:
        -: 3792:  /* If not already recovering from an error, report this error.  */
    #####: 3793:  if (!yyerrstatus)
branch  0 never executed
branch  1 never executed
        -: 3794:    {
        -: 3795:      ++yynerrs;
        -: 3796:#if ! YYERROR_VERBOSE
        -: 3797:      yyerror (yyscanner, compiler, YY_("syntax error"));
        -: 3798:#else
        -: 3799:# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
        -: 3800:                                        yyssp, yytoken)
        -: 3801:      {
        -: 3802:        char const *yymsgp = YY_("syntax error");
        -: 3803:        int yysyntax_error_status;
    #####: 3804:        yysyntax_error_status = YYSYNTAX_ERROR;
call    0 never executed
    #####: 3805:        if (yysyntax_error_status == 0)
branch  0 never executed
branch  1 never executed
    #####: 3806:          yymsgp = yymsg;
    #####: 3807:        else if (yysyntax_error_status == 1)
branch  0 never executed
branch  1 never executed
        -: 3808:          {
    #####: 3809:            if (yymsg != yymsgbuf)
branch  0 never executed
branch  1 never executed
    #####: 3810:              YYSTACK_FREE (yymsg);
call    0 never executed
    #####: 3811:            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
call    0 never executed
    #####: 3812:            if (!yymsg)
branch  0 never executed
branch  1 never executed
        -: 3813:              {
    #####: 3814:                yymsg = yymsgbuf;
    #####: 3815:                yymsg_alloc = sizeof yymsgbuf;
        -: 3816:                yysyntax_error_status = 2;
        -: 3817:              }
        -: 3818:            else
        -: 3819:              {
    #####: 3820:                yysyntax_error_status = YYSYNTAX_ERROR;
call    0 never executed
    #####: 3821:                yymsgp = yymsg;
        -: 3822:              }
        -: 3823:          }
    #####: 3824:        yyerror (yyscanner, compiler, yymsgp);
call    0 never executed
    #####: 3825:        if (yysyntax_error_status == 2)
branch  0 never executed
branch  1 never executed
        -: 3826:          goto yyexhaustedlab;
        -: 3827:      }
        -: 3828:# undef YYSYNTAX_ERROR
        -: 3829:#endif
        -: 3830:    }
        -: 3831:
        -: 3832:
        -: 3833:
    #####: 3834:  if (yyerrstatus == 3)
branch  0 never executed
branch  1 never executed
        -: 3835:    {
        -: 3836:      /* If just tried and failed to reuse lookahead token after an
        -: 3837:         error, discard it.  */
        -: 3838:
    #####: 3839:      if (yychar <= YYEOF)
branch  0 never executed
branch  1 never executed
        -: 3840:        {
        -: 3841:          /* Return failure if at end of input.  */
    #####: 3842:          if (yychar == YYEOF)
branch  0 never executed
branch  1 never executed
        -: 3843:            YYABORT;
        -: 3844:        }
        -: 3845:      else
        -: 3846:        {
    #####: 3847:          yydestruct ("Error: discarding",
call    0 never executed
        -: 3848:                      yytoken, &yylval, yyscanner, compiler);
        -: 3849:          yychar = YYEMPTY;
        -: 3850:        }
        -: 3851:    }
        -: 3852:
        -: 3853:  /* Else will try to reuse lookahead token after shifting the error
        -: 3854:     token.  */
        -: 3855:  goto yyerrlab1;
        -: 3856:
        -: 3857:
        -: 3858:/*---------------------------------------------------.
        -: 3859:| yyerrorlab -- error raised explicitly by YYERROR.  |
        -: 3860:`---------------------------------------------------*/
    #####: 3861:yyerrorlab:
        -: 3862:
        -: 3863:  /* Pacify compilers like GCC when the user code never invokes
        -: 3864:     YYERROR and the label yyerrorlab therefore never appears in user
        -: 3865:     code.  */
        -: 3866:  if (/*CONSTCOND*/ 0)
        -: 3867:     goto yyerrorlab;
        -: 3868:
        -: 3869:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 3870:     this YYERROR.  */
    #####: 3871:  YYPOPSTACK (yylen);
        -: 3872:  yylen = 0;
        -: 3873:  YY_STACK_PRINT (yyss, yyssp);
    #####: 3874:  yystate = *yyssp;
    #####: 3875:  goto yyerrlab1;
        -: 3876:
        -: 3877:
        -: 3878:/*-------------------------------------------------------------.
        -: 3879:| yyerrlab1 -- common code for both syntax error and YYERROR.  |
        -: 3880:`-------------------------------------------------------------*/
    #####: 3881:yyerrlab1:
        -: 3882:  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
        -: 3883:
        -: 3884:  for (;;)
        -: 3885:    {
    #####: 3886:      yyn = yypact[yystate];
    #####: 3887:      if (!yypact_value_is_default (yyn))
branch  0 never executed
branch  1 never executed
        -: 3888:        {
    #####: 3889:          yyn += YYTERROR;
    #####: 3890:          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3891:            {
    #####: 3892:              yyn = yytable[yyn];
    #####: 3893:              if (0 < yyn)
branch  0 never executed
branch  1 never executed
        -: 3894:                break;
        -: 3895:            }
        -: 3896:        }
        -: 3897:
        -: 3898:      /* Pop the current state because it cannot handle the error token.  */
    #####: 3899:      if (yyssp == yyss)
branch  0 never executed
branch  1 never executed
        -: 3900:        YYABORT;
        -: 3901:
        -: 3902:
    #####: 3903:      yydestruct ("Error: popping",
call    0 never executed
    #####: 3904:                  yystos[yystate], yyvsp, yyscanner, compiler);
    #####: 3905:      YYPOPSTACK (1);
    #####: 3906:      yystate = *yyssp;
        -: 3907:      YY_STACK_PRINT (yyss, yyssp);
        -: 3908:    }
        -: 3909:
        -: 3910:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    #####: 3911:  *++yyvsp = yylval;
        -: 3912:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 3913:
        -: 3914:
        -: 3915:  /* Shift the error token.  */
        -: 3916:  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
        -: 3917:
        -: 3918:  yystate = yyn;
    #####: 3919:  goto yynewstate;
        -: 3920:
        -: 3921:
        -: 3922:/*-------------------------------------.
        -: 3923:| yyacceptlab -- YYACCEPT comes here.  |
        -: 3924:`-------------------------------------*/
        8: 3925:yyacceptlab:
        -: 3926:  yyresult = 0;
        -: 3927:  goto yyreturn;
        -: 3928:
        -: 3929:/*-----------------------------------.
        -: 3930:| yyabortlab -- YYABORT comes here.  |
        -: 3931:`-----------------------------------*/
    #####: 3932:yyabortlab:
        -: 3933:  yyresult = 1;
        -: 3934:  goto yyreturn;
        -: 3935:
        -: 3936:#if !defined yyoverflow || YYERROR_VERBOSE
        -: 3937:/*-------------------------------------------------.
        -: 3938:| yyexhaustedlab -- memory exhaustion comes here.  |
        -: 3939:`-------------------------------------------------*/
    #####: 3940:yyexhaustedlab:
    #####: 3941:  yyerror (yyscanner, compiler, YY_("memory exhausted"));
call    0 never executed
        -: 3942:  yyresult = 2;
        -: 3943:  /* Fall through.  */
        -: 3944:#endif
        -: 3945:
        4: 3946:yyreturn:
        4: 3947:  if (yychar != YYEMPTY)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
        -: 3948:    {
        -: 3949:      /* Make sure we have latest lookahead translation.  See comments at
        -: 3950:         user semantic actions for why this is necessary.  */
    #####: 3951:      yytoken = YYTRANSLATE (yychar);
branch  0 never executed
branch  1 never executed
    #####: 3952:      yydestruct ("Cleanup: discarding lookahead",
call    0 never executed
        -: 3953:                  yytoken, &yylval, yyscanner, compiler);
        -: 3954:    }
        -: 3955:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 3956:     this YYABORT or YYACCEPT.  */
        -: 3957:  YYPOPSTACK (yylen);
        -: 3958:  YY_STACK_PRINT (yyss, yyssp);
       12: 3959:  while (yyssp != yyss)
branch  0 taken 8
branch  1 taken 4 (fallthrough)
        -: 3960:    {
        8: 3961:      yydestruct ("Cleanup: popping",
call    0 returned 8
        8: 3962:                  yystos[*yyssp], yyvsp, yyscanner, compiler);
        8: 3963:      YYPOPSTACK (1);
        -: 3964:    }
        -: 3965:#ifndef yyoverflow
        4: 3966:  if (yyss != yyssa)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 3967:    YYSTACK_FREE (yyss);
call    0 never executed
        -: 3968:#endif
        -: 3969:#if YYERROR_VERBOSE
        4: 3970:  if (yymsg != yymsgbuf)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 3971:    YYSTACK_FREE (yymsg);
call    0 never executed
        -: 3972:#endif
        4: 3973:  return yyresult;
        -: 3974:}
        -: 3975:#line 1968 "grammar.y" /* yacc.c:1906  */
        -: 3976:
